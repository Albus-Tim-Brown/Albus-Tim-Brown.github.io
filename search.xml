<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hexo博客配置(一)、Hexo部署并应用Butterfly主题</title>
    <url>/p/e1ce0840/</url>
    <content><![CDATA[<p>内容正在迁移，在未来的某个时间将完成！</p>
]]></content>
      <categories>
        <category>博客相关</category>
        <category>Hexo设置</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Butterfly</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客配置(三)、Hexo Butterfly基本配置</title>
    <url>/p/e2f269d8/</url>
    <content><![CDATA[<p>内容正在迁移，在未来的某个时间将完成！</p>
]]></content>
      <categories>
        <category>博客相关</category>
        <category>Hexo设置</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Butterfly</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客配置(二)、Hexo基本配置</title>
    <url>/p/e67e2b64/</url>
    <content><![CDATA[<p>内容正在迁移，在未来的某个时间将完成！</p>
]]></content>
      <categories>
        <category>博客相关</category>
        <category>Hexo设置</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Butterfly</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客配置(五)、Hexo Butterfly自定义组件相关配置</title>
    <url>/p/8b1160c2/</url>
    <content><![CDATA[<p>内容正在迁移，在未来的某个时间将完成！</p>
]]></content>
      <categories>
        <category>博客相关</category>
        <category>Hexo设置</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Butterfly</tag>
        <tag>CSS</tag>
        <tag>JS</tag>
        <tag>PUG</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客配置(四)、Hexo Butterfly自定义美化配置</title>
    <url>/p/c30d8154/</url>
    <content><![CDATA[<p>内容正在迁移，在未来的某个时间将完成！</p>
]]></content>
      <categories>
        <category>博客相关</category>
        <category>Hexo设置</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Butterfly</tag>
        <tag>CSS</tag>
        <tag>JS</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-Web-Study</title>
    <url>/p/b96134ee/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>学习本文需要先学习JavaSE内容</p>
<p>本文最初编辑时间：2022年10月26日 星期三</p>
<p>java   数据库  jdbc&#x3D;&#x3D;&#x3D;&#x3D;通过java程序访问数据库</p>
<p>HTML  CSS  JS  Jquery&#x3D;&#x3D;&#x3D;&#x3D;开发静态网页</p>
<p>servlet  JSP&#x3D;&#x3D;&#x3D;&#x3D;开发动态网页</p>
<p>概念   servlet   JSP   脚本元素   指令元素  动作元素   九大内置对象   </p>
<p>EL   JSTL  文件上传下载   过滤器  监听器   AJAX</p>
 <span id="more"></span>



<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="一、web相关的概念："><a href="#一、web相关的概念：" class="headerlink" title="一、web相关的概念："></a>一、web相关的概念：</h2><h3 id="1、什么是互联网："><a href="#1、什么是互联网：" class="headerlink" title="1、什么是互联网："></a>1、什么是互联网：</h3><p>internet—–互联网</p>
<p>互联网是计算机网络，由多个服务器和局域网组成。</p>
<p>没有主次服务器之分，不受地理位置限制。</p>
<p>优点：信息共享。</p>
<p>信息格式统一：要遵循HTML标准编写。</p>
<h3 id="2、什么是web："><a href="#2、什么是web：" class="headerlink" title="2、什么是web："></a>2、什么是web：</h3><p>web又称为万维网，是目前internet上使用最广泛的信息服务类型。另外还有邮件服务、新闻服务等等</p>
<p>web程序都是以超文本标记语言（HTML）进行组织。以超文本传输协议（HTTP）进行传输。</p>
<h3 id="3、URL和URI：（重点）"><a href="#3、URL和URI：（重点）" class="headerlink" title="3、URL和URI：（重点）"></a>3、URL和URI：（重点）</h3><p>URL：Uniform   Resource   Locator  统一资源定位器。</p>
<p>组成：协议名   服务器名或IP地址+端口号  路径名   文件名 四部分组成。</p>
<p>如：<a href="http://localhost:8080/sub/ok.jsp">http://localhost:8080/sub/ok.jsp</a>      localhost主机名—-127.0.0.1</p>
<p>URI：Uniform   Resource   Identifier  统一资源标识符</p>
<p>组成：协议名   服务器名或IP地址+端口号  路径名  三部分组成。</p>
<p>URL 是 URI 的一个子集。</p>
<h3 id="4、什么是web程序："><a href="#4、什么是web程序：" class="headerlink" title="4、什么是web程序："></a>4、什么是web程序：</h3><p>web程序在服务器上存储。</p>
<p>web程序在服务器上执行。</p>
<p>通过浏览器给服务器发送请求，服务器收到请求后，根据请求的URL解析出要执行的文件执行，将执行结果响应给客户端的浏览器，浏览器接收到服务器端响应的数据，执行该代码，在浏览器上显示。</p>
<p>web程序处理的结果信息格式要符合HTML格式要求。</p>
<p>浏览器通过超链接、表单、地址栏、JS程序等方式给服务器发送请求。</p>
<h3 id="5、B-S架构和C-S架构：（重点）"><a href="#5、B-S架构和C-S架构：（重点）" class="headerlink" title="5、B&#x2F;S架构和C&#x2F;S架构：（重点）"></a>5、B&#x2F;S架构和C&#x2F;S架构：（重点）</h3><p>B&#x2F;S：Browser&#x2F;Server  浏览器&#x2F;服务器     web程序开发   如：搜狐、网易等web程序</p>
<p>C&#x2F;S：Client&#x2F;Server	客户端&#x2F;服务器端    网络通信–TCP套接字、UDP套接字  如：QQ、微信等程序</p>
<p>相同：网络程序开发。</p>
<p>B&#x2F;S优点：</p>
<p>开发成本低。</p>
<p>管理维护简单。</p>
<p>产品升级便利。</p>
<p>用户使用方便，出现故障的概率小。</p>
<p>B&#x2F;S缺点：</p>
<p>安全性不足。</p>
<p>客户端不能随心变化，受浏览器的影响。</p>
<p>作业：</p>
<p>抄写 B&#x2F;S架构 和 C&#x2F;S架构 。</p>
<p>抄写 URL 和 URI 。</p>
<h2 id="二、服务器相关的概念："><a href="#二、服务器相关的概念：" class="headerlink" title="二、服务器相关的概念："></a>二、服务器相关的概念：</h2><h3 id="1、什么是web服务器："><a href="#1、什么是web服务器：" class="headerlink" title="1、什么是web服务器："></a>1、什么是web服务器：</h3><p>web服务器：安装了web服务器程序的主机。保持web程序、运行web程序。</p>
<p>web服务器程序常用的有：Tomcat、IIS、Apache等。</p>
<h3 id="2、服务器的命名："><a href="#2、服务器的命名：" class="headerlink" title="2、服务器的命名："></a>2、服务器的命名：</h3><p>局域网：主机名（LAPTOP-RIPPDF2E）。—-192.168.1.103</p>
<p>互联网：按照互联网方式命名，即域名。</p>
<p>localhost—-127.0.0.1</p>
<h3 id="3、Tomcat目录结构：（重点）"><a href="#3、Tomcat目录结构：（重点）" class="headerlink" title="3、Tomcat目录结构：（重点）"></a>3、Tomcat目录结构：（重点）</h3><p><strong>bin</strong>：保存bat文件。shutdown.bat：关闭服务器程序；startup.bat：启动服务器程序。</p>
<p>​		<a href="http://localhost:8080/index.jsp%E7%BB%99%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82%E3%80%82">http://localhost:8080/index.jsp给服务器发送请求。</a></p>
<p><strong>conf</strong>：保存配置文件。server.xml、web.xml 等。</p>
<p>lib：保存jar文件。tomcat程序对应的代码。</p>
<p><strong>webapps</strong>：保存web程序。</p>
<p><strong>work</strong>：jsp文件转换成的servlet文件。</p>
<p>logs：保存日志文件。</p>
<p>temp：保存临时问题。</p>
<h3 id="4、主目录：（重点）"><a href="#4、主目录：（重点）" class="headerlink" title="4、主目录：（重点）"></a>4、主目录：（重点）</h3><p>主目录：站点域名映射的目录。tomcat服务器的主目录为：webapps</p>
<p>主目录是站点访问者的起始点。</p>
<h3 id="5、虚拟目录：（重点）"><a href="#5、虚拟目录：（重点）" class="headerlink" title="5、虚拟目录：（重点）"></a>5、虚拟目录：（重点）</h3><p>定义虚拟目录：conf&#x2F;server.xml</p>
<p><a href="http://localhost:8080/virtualweb/">http://localhost:8080/virtualweb/</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在&lt;Host&gt;标签中增加以下配置信息：</span><br><span class="line">&lt;Context </span><br><span class="line">			path=&quot;/虚拟目录名&quot;</span><br><span class="line">			docBase=&quot;虚拟目录映射的物理路径&quot;</span><br><span class="line">			&gt;</span><br><span class="line">&lt;/Context&gt;</span><br><span class="line">如：</span><br><span class="line">&lt;Context </span><br><span class="line">			path=&quot;/virtualweb&quot;</span><br><span class="line">			docBase=&quot;C:\\vweb&quot;</span><br><span class="line">			&gt;</span><br><span class="line">&lt;/Context&gt;</span><br></pre></td></tr></table></figure>

<h3 id="6、更改服务器端口号：（重点）"><a href="#6、更改服务器端口号：（重点）" class="headerlink" title="6、更改服务器端口号：（重点）"></a>6、更改服务器端口号：（重点）</h3><p>在conf&#x2F;server.xml文件中修改：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;Connector port=&quot;8088&quot; protocol=&quot;HTTP/1.1&quot;</span><br><span class="line">               connectionTimeout=&quot;20000&quot;</span><br><span class="line">               redirectPort=&quot;8443&quot; /</span><br></pre></td></tr></table></figure>



<p>作业：</p>
<p>1、将html文件放在webapps目录下，测试主目录，</p>
<p>2、定义虚拟目录。</p>
<p>3、修改端口号。</p>
<h2 id="三、HTTP协议：（重点）"><a href="#三、HTTP协议：（重点）" class="headerlink" title="三、HTTP协议：（重点）"></a>三、HTTP协议：（重点）</h2><p>HTTP协议：HyperText Transfer Protocol  超文本传输协议。</p>
<p>HTTP协议使 请求 响应 式协议。</p>
<p>请求方式：get   post</p>
<p><strong>get：不安全的，传输的数据大小2KB，传输速度快。</strong></p>
<p><strong>post：安全的，传输的数据大，可以是几百兆，传输速度慢。</strong></p>
<p><strong>HTTP1.1 长连接，也称持久连接，是使用同一个 TCP 连接来发送和接收多个 HTTP 请求&#x2F;应答，而不是为每个新的请求&#x2F;应答打开新的 TCP 连接。</strong></p>
<p><strong>HTTP1.0 短连接，浏览器和服务器每进行一次 HTTP 操作，就会建立一次连接，但任务结束后就中断连接，不会像长连接那样保持连接。</strong></p>
<p>HTTPS(全称：Hypertext Transfer Protocol over Secure Socket Layer)，是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层（“Secure Sockets Layer” ，中文名为 “ 安全套接字协议层 ” ），HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 用于安全的HTTP数据传输。</p>
<h1 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h1><h2 id="一、什么是servlet技术：（重点）"><a href="#一、什么是servlet技术：（重点）" class="headerlink" title="一、什么是servlet技术：（重点）"></a>一、什么是servlet技术：（重点）</h2><p><strong>servlet技术是用java语言开发的java程序。</strong></p>
<p><strong>使用 Servlet接口 或 实现了Servlet接口的类 开发程序。</strong></p>
<h2 id="二、servlet的功能："><a href="#二、servlet的功能：" class="headerlink" title="二、servlet的功能："></a>二、servlet的功能：</h2><p>创建并返回一个包含了基于客户端请求的动态内容的完整的HTML页面。</p>
<p>与其他的服务器资源（如：数据库）进行通信。</p>
<h2 id="三、serlet程序的调用方式：（重点）"><a href="#三、serlet程序的调用方式：（重点）" class="headerlink" title="三、serlet程序的调用方式：（重点）"></a>三、serlet程序的调用方式：（重点）</h2><p>超连接给服务器发送请求</p>
<p>表单给服务器发送请求</p>
<p>JS程序给服务器发送请求</p>
<p>浏览器地址栏输入url给服务器发送请求</p>
<h2 id="四、开发servlet程序："><a href="#四、开发servlet程序：" class="headerlink" title="四、开发servlet程序："></a>四、开发servlet程序：</h2><h3 id="1、用记事本开发，实现Servlet接口"><a href="#1、用记事本开发，实现Servlet接口" class="headerlink" title="1、用记事本开发，实现Servlet接口"></a>1、用记事本开发，实现Servlet接口</h3><h4 id="1-1、在webapps目录中创建目录和文件："><a href="#1-1、在webapps目录中创建目录和文件：" class="headerlink" title="1.1、在webapps目录中创建目录和文件："></a>1.1、在webapps目录中创建目录和文件：</h4><h4 id="1-2、配置CLASSPATH环境变量："><a href="#1-2、配置CLASSPATH环境变量：" class="headerlink" title="1.2、配置CLASSPATH环境变量："></a>1.2、配置CLASSPATH环境变量：</h4><h4 id="1-3、开发编译java程序，实现Servlet接口："><a href="#1-3、开发编译java程序，实现Servlet接口：" class="headerlink" title="1.3、开发编译java程序，实现Servlet接口："></a>1.3、开发编译java程序，实现Servlet接口：</h4><h4 id="1-4、配置web-xml文件："><a href="#1-4、配置web-xml文件：" class="headerlink" title="1.4、配置web.xml文件："></a>1.4、配置web.xml文件：</h4><h4 id="1-5、启动服务器："><a href="#1-5、启动服务器：" class="headerlink" title="1.5、启动服务器："></a>1.5、启动服务器：</h4><h4 id="1-6、给服务器发送请求："><a href="#1-6、给服务器发送请求：" class="headerlink" title="1.6、给服务器发送请求："></a>1.6、给服务器发送请求：</h4><h3 id="2、继承GenericServlet类"><a href="#2、继承GenericServlet类" class="headerlink" title="2、继承GenericServlet类"></a>2、继承GenericServlet类</h3><h3 id="3、使用idea开发，继承HttpServlet类（重点）"><a href="#3、使用idea开发，继承HttpServlet类（重点）" class="headerlink" title="3、使用idea开发，继承HttpServlet类（重点）"></a>3、使用idea开发，继承HttpServlet类（重点）</h3><p> Intellij IDEA2021.1创建Java web项目：<a href="https://blog.csdn.net/llplllll/article/details/116903198">https://blog.csdn.net/llplllll/article/details/116903198</a></p>
<h4 id="1-1、使用idea工具创建web项目："><a href="#1-1、使用idea工具创建web项目：" class="headerlink" title="1.1、使用idea工具创建web项目："></a>1.1、使用idea工具创建web项目：</h4><img src="C:\Users\wangchao\AppData\Roaming\Typora\typora-user-images\image-20220901193954284.png" alt="image-20220901193954284" style="zoom:50%;" />

<h4 id="1-2、编写servlet程序："><a href="#1-2、编写servlet程序：" class="headerlink" title="1.2、编写servlet程序："></a>1.2、编写servlet程序：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ServletDemo01 extends HttpServlet &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">        System.out.println(&quot;servlet demo=======&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">        doGet(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@WebServlet(&quot;/url&quot;)</span><br><span class="line">该注解的作用和在web.xml文件中配置&lt;servlet&gt;标签的作用基本相同，设置servlet类和url的映射关系。</span><br></pre></td></tr></table></figure>



<h4 id="1-3、配置web-xml文件："><a href="#1-3、配置web-xml文件：" class="headerlink" title="1.3、配置web.xml文件："></a>1.3、配置web.xml文件：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span><br><span class="line">         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span><br><span class="line">         version=&quot;4.0&quot;&gt;</span><br><span class="line">    &lt;servlet&gt;</span><br><span class="line">        &lt;servlet-name&gt;aaa&lt;/servlet-name&gt;</span><br><span class="line">        &lt;servlet-class&gt;cn.tedu.ServletDemo01&lt;/servlet-class&gt;</span><br><span class="line">    &lt;/servlet&gt;</span><br><span class="line">    &lt;servlet-mapping&gt;</span><br><span class="line">        &lt;servlet-name&gt;aaa&lt;/servlet-name&gt;</span><br><span class="line">        &lt;url-pattern&gt;/aaa&lt;/url-pattern&gt;</span><br><span class="line">    &lt;/servlet-mapping&gt;</span><br><span class="line">&lt;/web-app&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">配置url-pattern：</span><br><span class="line">精确匹配：具体的路径名和文件名。如：/a/b/a.jsp</span><br><span class="line">目录匹配：指定路径。如：/a/*</span><br><span class="line">扩展匹配：*.后缀名。如：*.jsp</span><br></pre></td></tr></table></figure>

<h4 id="1-4、启动服务器："><a href="#1-4、启动服务器：" class="headerlink" title="1.4、启动服务器："></a>1.4、启动服务器：</h4><h4 id="1-5、发送请求："><a href="#1-5、发送请求：" class="headerlink" title="1.5、发送请求："></a>1.5、发送请求：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://localhost:8080/lesson04_war_exploded/aaa</span><br></pre></td></tr></table></figure>



<p>作业：</p>
<p>1、抄写HTTP协议黑体部分。</p>
<p>2、用记事本开发servlet。</p>
<h2 id="五、servlet的生命周期：（重点）"><a href="#五、servlet的生命周期：（重点）" class="headerlink" title="五、servlet的生命周期：（重点）"></a>五、servlet的生命周期：（重点）</h2><p>1、第一次给servlet发送请求时，服务器端将改servlet类加载到内存，创建改类对象。</p>
<p>2、服务器端创建请求对象（request）、响应对象（response）</p>
<p>3、调用servlet中的init方法</p>
<p>4、调用servlet中的service方法。获取请求对象（request）的信息，处理请求，访问其他资源（数据库）、获取需要的信息，使用响应对象（response），将响应发送给客户端。</p>
<p>5、以后再给servlet发送请求时，服务器创建创建请求对象（request）、响应对象（response）对象，仍然激活此servlet对象，调用servlet中的service方法。</p>
<p>6、当服务器关闭，服务器会调用servlet中的destroy方法，销毁servlet对象。</p>
<h1 id="servlet常用类（重点）"><a href="#servlet常用类（重点）" class="headerlink" title="servlet常用类（重点）"></a>servlet常用类（重点）</h1><h2 id="一、HttpServletRequest："><a href="#一、HttpServletRequest：" class="headerlink" title="一、HttpServletRequest："></a>一、HttpServletRequest：</h2><h3 id="1、获取客户端发送的数据："><a href="#1、获取客户端发送的数据：" class="headerlink" title="1、获取客户端发送的数据："></a>1、获取客户端发送的数据：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">getParameter(&quot;参数名&quot;)</span><br><span class="line">getParameterValues(&quot;参数名&quot;)</span><br></pre></td></tr></table></figure>

<h3 id="2、设置客户端发送的中文编码："><a href="#2、设置客户端发送的中文编码：" class="headerlink" title="2、设置客户端发送的中文编码："></a>2、设置客户端发送的中文编码：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setCharacterEncoding(&quot;utf-8&quot;)</span><br></pre></td></tr></table></figure>

<h3 id="3、页面的跳转—转发："><a href="#3、页面的跳转—转发：" class="headerlink" title="3、页面的跳转—转发："></a>3、页面的跳转—转发：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">getRequestDispatcher(&quot;/fail.jsp&quot;).forward(request, response);</span><br><span class="line">注意：url中的第一个/表示上下文路径。</span><br></pre></td></tr></table></figure>

<h3 id="4、域对象："><a href="#4、域对象：" class="headerlink" title="4、域对象："></a>4、域对象：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setAttribute(String, Object);</span><br><span class="line">getAttribute(String);</span><br></pre></td></tr></table></figure>

<h2 id="二、HttpServletResponse："><a href="#二、HttpServletResponse：" class="headerlink" title="二、HttpServletResponse："></a>二、HttpServletResponse：</h2><h3 id="1、给客户端响应数据："><a href="#1、给客户端响应数据：" class="headerlink" title="1、给客户端响应数据："></a>1、给客户端响应数据：</h3><p>public java.io.PrintWriter <strong>getWriter</strong>() </p>
<p>print()   write()</p>
<h3 id="2、设置给客户端发送中文的编码："><a href="#2、设置给客户端发送中文的编码：" class="headerlink" title="2、设置给客户端发送中文的编码："></a>2、设置给客户端发送中文的编码：</h3><p>public void <strong>setContentType</strong>(“text&#x2F;html;charset&#x3D;UTF-8”) </p>
<h3 id="3、页面的跳转—-重定向："><a href="#3、页面的跳转—-重定向：" class="headerlink" title="3、页面的跳转—-重定向："></a>3、页面的跳转—-重定向：</h3><p>public void <strong>sendRedirect</strong>(String location) </p>
<p>第一个  &#x2F;  表示服务器名。</p>
<h3 id="4、转发和重定向的区别：（重点）"><a href="#4、转发和重定向的区别：（重点）" class="headerlink" title="4、转发和重定向的区别：（重点）"></a>4、转发和重定向的区别：（重点）</h3><p>4.1、转发是客户端给服务器端发送了一次请求；重定向是客户端给服务器端发送了两次请求；</p>
<p>4.2、转发时浏览器地址栏地址不变；重定向时浏览器地址栏地址改变；</p>
<p>4.3、转发设置url时，第一个 &#x2F; 表示上下文路径；重定向设置url时，第一个 &#x2F; 表示服务器名；</p>
<p>4.4、转发只能跳转到本网站中的页面；重定向可以跳转到任意页面；</p>
<p>4.5、转发效率高；重定向效率低；能使用转发就不使用重定向。</p>
<p>4.6、转发可以跳转到WEB-INF目录下的页面；重定向不可以跳转到WEB-INF目录下的页面；</p>
<p>作业：</p>
<p>抄写转发和重定向的区别。</p>
<p>测试response的功能。截图发群里。</p>
<h2 id="三、ServletConfig："><a href="#三、ServletConfig：" class="headerlink" title="三、ServletConfig："></a>三、ServletConfig：</h2><h3 id="1、获取ServletConfig对象："><a href="#1、获取ServletConfig对象：" class="headerlink" title="1、获取ServletConfig对象："></a>1、获取ServletConfig对象：</h3><p>HttpServlet类中提供以下方法：</p>
<p>public <a href="../javax.servlet.ServletConfig.html">ServletConfig</a> <strong>getServletConfig</strong>()</p>
<h3 id="2、获取标签中的标签中配置的数据："><a href="#2、获取标签中的标签中配置的数据：" class="headerlink" title="2、获取标签中的标签中配置的数据："></a>2、获取<servlet>标签中的<init-param>标签中配置的数据：</h3><p>public String <strong>getInitParameter</strong>(String name) </p>
<p>只能在该servlet中可以获取配置的数据。</p>
<h2 id="四、HttpSession：（重点）"><a href="#四、HttpSession：（重点）" class="headerlink" title="四、HttpSession：（重点）"></a>四、HttpSession：（重点）</h2><h3 id="1、获取HttpSession对象："><a href="#1、获取HttpSession对象：" class="headerlink" title="1、获取HttpSession对象："></a>1、获取HttpSession对象：</h3><p>HttpServletRequest对象中提供以下方法：</p>
<p>public <a href="../javax.servlet.http.HttpSession.html">HttpSession</a> <strong>getSession</strong>()</p>
<h3 id="2、域对象："><a href="#2、域对象：" class="headerlink" title="2、域对象："></a>2、域对象：</h3><p>setAttribute(String, Object);<br>getAttribute(String);</p>
<h2 id="五、ServletContext："><a href="#五、ServletContext：" class="headerlink" title="五、ServletContext："></a>五、ServletContext：</h2><h3 id="1、获取ServletContext对象："><a href="#1、获取ServletContext对象：" class="headerlink" title="1、获取ServletContext对象："></a>1、获取ServletContext对象：</h3><p>HttpServlet提供了以下方法：</p>
<p>public <a href="../javax.servlet.ServletContext.html">ServletContext</a>  <strong>getServletContext</strong>()</p>
<h3 id="2、获取标签中的标签中的数据"><a href="#2、获取标签中的标签中的数据" class="headerlink" title="2、获取标签中的标签中的数据"></a>2、获取<web-app>标签中的<context-param>标签中的数据</h3><p>public String <strong>getInitParameter</strong>(String name)</p>
<p>可以在所有的servlet中获取配置的数据。</p>
<h3 id="3、域对象："><a href="#3、域对象：" class="headerlink" title="3、域对象："></a>3、域对象：</h3><p>setAttribute(String, Object);<br>getAttribute(String);</p>
<p>作业：</p>
<p>抄写servlet的生命周期</p>
<p>测试上面讲的三个类</p>
<h2 id="六、request、session、servletContext三种域对象的区别：（重点）"><a href="#六、request、session、servletContext三种域对象的区别：（重点）" class="headerlink" title="六、request、session、servletContext三种域对象的区别：（重点）"></a>六、request、session、servletContext三种域对象的区别：（重点）</h2><p>生命期不同。</p>
<p>request：一次请求。给服务器端发送请求到给客户端响应数据。如：转发</p>
<p>session：一次会话。浏览器的打开到关闭。</p>
<p>servletContext：服务器的启动到关闭。</p>
<h1 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h1><h2 id="一、概念："><a href="#一、概念：" class="headerlink" title="一、概念："></a>一、概念：</h2><p>JSP：Java  Server  Page  java服务器页面</p>
<p>作用：方便的开发动态页面。</p>
<p>本质：一个JSP文件转换为servlet文件，执行servlet。</p>
<h2 id="二、JSP脚本元素：（重点）"><a href="#二、JSP脚本元素：（重点）" class="headerlink" title="二、JSP脚本元素：（重点）"></a>二、JSP脚本元素：（重点）</h2><h3 id="1、"><a href="#1、" class="headerlink" title="1、&lt;% java程序块 %&gt;"></a>1、&lt;% java程序块 %&gt;</h3><p>将java代码块中的程序添加到 _jspService 方法中。</p>
<h3 id="2、"><a href="#2、" class="headerlink" title="2、&lt;%!  java程序声明 %&gt;"></a>2、&lt;%!  java程序声明 %&gt;</h3><p>定义成员变量、成员方法。</p>
<h3 id="3、"><a href="#3、" class="headerlink" title="3、&lt;%&#x3D; java表达式 %&gt;"></a>3、&lt;%&#x3D; java表达式 %&gt;</h3><p>使用 java表达式 的结果 替换 该标签。</p>
<p>表达式末尾不能有分号。</p>
<p>在html标签中使用。</p>
<p>本质：out.print( 表达式 );</p>
<p>脚本元素中不能出现标签。</p>
<p>print(int)：将int数值转换为字符串，将对应的字符串响应给客户端。如：print(65)，页面显示65</p>
<p>write(int)：将int当作编码，将该编码对应的字符响应给客户端。如：write(65)，页面显示A</p>
<p>作业：</p>
<p>在&lt;%%&gt;中打印菱形。</p>
<p>在&lt;%!%&gt;中定义排序方法。在&lt;%%&gt;中调用。</p>
<h2 id="三、JSP指令元素："><a href="#三、JSP指令元素：" class="headerlink" title="三、JSP指令元素："></a>三、JSP指令元素：</h2><h3 id="1、概念："><a href="#1、概念：" class="headerlink" title="1、概念："></a>1、概念：</h3><p>指令元素是提供给服务器，指明如何编译生成servlet程序。</p>
<p>语法格式：&lt;%@ 指令名  属性&#x3D;“值”  属性&#x3D;“值” …… %&gt;</p>
<p>指令名有：page   include   taglib</p>
<h3 id="2、page：（重点）"><a href="#2、page：（重点）" class="headerlink" title="2、page：（重点）"></a>2、page：（重点）</h3><p>language：属性值为编程语言名，缺点嵌入程序的语言。如：java</p>
<p>import：属性值为类的包名，导入包中的类。如：java.util.HashSet</p>
<p>session：属性值为boolean，设置session对象是否可以使用。如：true</p>
<p>contentType：属性值为编码名，设置页面中中文的编码。如：text&#x2F;html;charset&#x3D;UTF-8</p>
<p>error Page：属性值为错误页面的url，设置页面出500错误 转发 的页面。</p>
<p>其他错误跳转的页面需要配置web.xml文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;error-page&gt;</span><br><span class="line">    &lt;error-code&gt;404&lt;/error-code&gt;</span><br><span class="line">    &lt;!--转发--&gt;</span><br><span class="line">    &lt;location&gt;/404.jsp&lt;/location&gt;</span><br><span class="line">&lt;/error-page&gt;</span><br><span class="line">&lt;error-page&gt;</span><br><span class="line">    &lt;error-code&gt;500&lt;/error-code&gt;</span><br><span class="line">    &lt;location&gt;/ok.jsp&lt;/location&gt;</span><br><span class="line">&lt;/error-page&gt;</span><br></pre></td></tr></table></figure>

<p>isErrorPage：属性值是boolean值，确定该页面是否是错误页面。如果是错误页面，则生成servlet时会创建exception对象。</p>
<p>pageEncoding：属性值是编码名，确定客户端发送的中文的编码。</p>
<p>auto Flush：属性值是boolean值，确定是否自动刷新缓存区的内容。</p>
<p>page指令元素可以有多个。</p>
<p>import属性可以设置多次值。其他属性只能设置一次值。</p>
<h3 id="3、include：（重点）"><a href="#3、include：（重点）" class="headerlink" title="3、include：（重点）"></a>3、include：（重点）</h3><p>功能类似于 iframe 标签。将某个页面包含到本页面中。</p>
<p>file：指定需要包含进来的页面文件名。</p>
<p>注意：</p>
<p>子页面中设置的样式会影响到当前页面的标签。</p>
<p>include指令元素本质是将子页面中的代码添加到了当前页面，生成一个servelt文件。</p>
<h3 id="4、taglib："><a href="#4、taglib：" class="headerlink" title="4、taglib："></a>4、taglib：</h3><p>将系统提供的标准标签库导入到当前页面，则在当前页面中可以使用。</p>
<p>在 JSTL 章节</p>
<h2 id="四、JSP动作元素："><a href="#四、JSP动作元素：" class="headerlink" title="四、JSP动作元素："></a>四、JSP动作元素：</h2><h3 id="1、jsp-forward：（重点）"><a href="#1、jsp-forward：（重点）" class="headerlink" title="1、jsp:forward：（重点）"></a>1、<a href="jsp:forward">jsp:forward</a>：（重点）</h3><p>进行页面的跳转—转发</p>
<p>page属性：跳转的url</p>
<h3 id="2、jsp-param"><a href="#2、jsp-param" class="headerlink" title="2、jsp:param"></a>2、<a href="jsp:param">jsp:param</a></h3><p>通过该标签设置参数，本质是将参数添加的了 request 域对象中。</p>
<p>在  <a href="jsp:forward">jsp:forward</a>  和  <a href="jsp:include">jsp:include</a> 中使用。</p>
<h3 id="3、jsp-include：（重点）"><a href="#3、jsp-include：（重点）" class="headerlink" title="3、jsp:include：（重点）"></a>3、<a href="jsp:include">jsp:include</a>：（重点）</h3><p>作用：将一个页面包含到当前页面。</p>
<p>注意：</p>
<p>子页面中设置的样式会影响到当前页面的标签。</p>
<p>include动作元素本质是每个jsp文件都会生成对应的servlet文件，当执行动作元素时，才会执行子页面对应的servlet程序。</p>
<p>page属性：设置包含的页面。</p>
<h3 id="4、jsp-useBean"><a href="#4、jsp-useBean" class="headerlink" title="4、jsp:useBean"></a>4、<a href="jsp:useBean">jsp:useBean</a></h3><p>创建指定的类对象，并将类对象添加到指定的域对象中。</p>
<p>指定类中一定要有无参构造方法。</p>
<p>id属性：添加到域对象中时，设置的名字。</p>
<p>class属性：创建指定的类对象。</p>
<p>scope属性：添加到指定的域对象中。</p>
<h3 id="5、jsp-setProperty"><a href="#5、jsp-setProperty" class="headerlink" title="5、jsp:setProperty"></a>5、<a href="jsp:setProperty">jsp:setProperty</a></h3><p>给指定的对象设置属性值。</p>
<p>name属性：指定设置属性值的对象。</p>
<p>property属性：指定属性名。</p>
<p>value属性：指定属性值。</p>
<h3 id="6、jsp-getProperty"><a href="#6、jsp-getProperty" class="headerlink" title="6、jsp:getProperty"></a>6、<a href="jsp:getProperty">jsp:getProperty</a></h3><p>从指定的对象中指定的属性获取属性值，将该值发送给客户端。类似于&lt;%&#x3D;%&gt;</p>
<p>name属性：指定设置属性值的对象。</p>
<p>property属性：指定属性名。</p>
<h1 id="九大内置对象"><a href="#九大内置对象" class="headerlink" title="九大内置对象"></a>九大内置对象</h1><h2 id="一、概念：（重点）"><a href="#一、概念：（重点）" class="headerlink" title="一、概念：（重点）"></a>一、概念：（重点）</h2><p>request   response   out   application   session   exception   page   pageContext   config </p>
<p>九大内置对象可以直接在jsp文件的 &lt;%%&gt; 或 &lt;%&#x3D;%&gt; 中的java程序中使用。</p>
<p>本质是 _jspService 中定义的对象。</p>
<h2 id="二、request（重点）"><a href="#二、request（重点）" class="headerlink" title="二、request（重点）"></a>二、request（重点）</h2><p>内置对象的类型：javax.servlet.http.HttpServletRequest</p>
<h3 id="1、获取客户端发送的参数："><a href="#1、获取客户端发送的参数：" class="headerlink" title="1、获取客户端发送的参数："></a>1、获取客户端发送的参数：</h3><h3 id="2、设置中文编码："><a href="#2、设置中文编码：" class="headerlink" title="2、设置中文编码："></a>2、设置中文编码：</h3><h3 id="3、页面的转发："><a href="#3、页面的转发：" class="headerlink" title="3、页面的转发："></a>3、页面的转发：</h3><h3 id="4、域对象：-1"><a href="#4、域对象：-1" class="headerlink" title="4、域对象："></a>4、域对象：</h3><h3 id="5、获取客户端发送请求的方式："><a href="#5、获取客户端发送请求的方式：" class="headerlink" title="5、获取客户端发送请求的方式："></a>5、获取客户端发送请求的方式：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">request.getMethod()</span><br></pre></td></tr></table></figure>

<h3 id="6、获取请求头中的数据："><a href="#6、获取请求头中的数据：" class="headerlink" title="6、获取请求头中的数据："></a>6、获取请求头中的数据：</h3><p>​	general：</p>
<p>​		Request URL: <a href="http://127.0.0.1:8080/lesson/request.jsp">http://127.0.0.1:8080/lesson/request.jsp</a>	 请求的url</p>
<p>​		Request Method: GET			请求方式</p>
<p>​		Status Code: 200 					请求状态</p>
<p>​		Remote Address: 127.0.0.1:8080		客户端的IP地址和端口</p>
<p>​	response head：响应头，服务器端给客户端发送的数据</p>
<p>​		Content-Length: 106				相应给客户端的数据字节数</p>
<p>​		Content-Type: text&#x2F;html;charset&#x3D;UTF-8		中文编码</p>
<p>​		Date: Wed, 21 Sep 2022 00:33:13 GMT		 响应时间</p>
<p>​	request  head：请求头，客户端给服务器端发送的数据</p>
<pre><code>    Accept:text/html,application/xhtml+xml   客户端可以接收html格式的文本
</code></pre>
<p>​		Accept-Encoding: gzip, deflate, br			客户端可以接收压缩格式的数据</p>
<p>​		Accept-Language: zh-CN,zh;q&#x3D;0.9			客户端可以接收中文</p>
<p>​		Connection: keep-alive					客户端是长连接</p>
<p>​		Host: 127.0.0.1:8080						客户端给服务器端的IP地址和端口号发送请求</p>
<p>​		User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; WOW64)  客户端的浏览器内核</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Enumeration&lt;String&gt; headerNames = request.getHeaderNames();</span><br><span class="line">while (headerNames.hasMoreElements())&#123;</span><br><span class="line">    String name = headerNames.nextElement();</span><br><span class="line">    String header = request.getHeader(name);</span><br><span class="line">    System.out.println(name+&quot;:&quot;+header);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7、获取上下文路径："><a href="#7、获取上下文路径：" class="headerlink" title="7、获取上下文路径："></a>7、获取上下文路径：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">request.getContextPath();</span><br></pre></td></tr></table></figure>

<h3 id="8、获取客户端的IP地址和端口号："><a href="#8、获取客户端的IP地址和端口号：" class="headerlink" title="8、获取客户端的IP地址和端口号："></a>8、获取客户端的IP地址和端口号：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">request.getRemoteAddr();</span><br><span class="line">request.getRemotePort();</span><br></pre></td></tr></table></figure>

<h3 id="9、发送请求的URL："><a href="#9、发送请求的URL：" class="headerlink" title="9、发送请求的URL："></a>9、发送请求的URL：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">request.getRequestURL();</span><br></pre></td></tr></table></figure>

<h3 id="10、获取客户端发送的cookie对象：（重点）"><a href="#10、获取客户端发送的cookie对象：（重点）" class="headerlink" title="10、获取客户端发送的cookie对象：（重点）"></a>10、获取客户端发送的cookie对象：（重点）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Cookie[] cookies = request.getCookies();</span><br><span class="line">for (Cookie c: cookies)&#123;</span><br><span class="line">    String name = c.getName();</span><br><span class="line">    String value = c.getValue();</span><br><span class="line">    int maxAge = c.getMaxAge();</span><br><span class="line">    String path = c.getPath();</span><br><span class="line">    System.out.println(name+&quot; &quot;+value+&quot; &quot;+maxAge+&quot; &quot;+path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="三、response（重点）"><a href="#三、response（重点）" class="headerlink" title="三、response（重点）"></a>三、response（重点）</h2><p>功能：将服务器端的数据响应给客户端。影响 响应头 中的数据。</p>
<p>类型：HttpServletResponse</p>
<h3 id="1、给客户端响应完整页面。"><a href="#1、给客户端响应完整页面。" class="headerlink" title="1、给客户端响应完整页面。"></a>1、给客户端响应完整页面。</h3><h3 id="2、设置响应页面中的中文编码格式。"><a href="#2、设置响应页面中的中文编码格式。" class="headerlink" title="2、设置响应页面中的中文编码格式。"></a>2、设置响应页面中的中文编码格式。</h3><h3 id="3、进行页面的跳转—-重定向"><a href="#3、进行页面的跳转—-重定向" class="headerlink" title="3、进行页面的跳转—-重定向"></a>3、进行页面的跳转—-重定向</h3><h3 id="4、设置页面自动刷新："><a href="#4、设置页面自动刷新：" class="headerlink" title="4、设置页面自动刷新："></a>4、设置页面自动刷新：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">response.setHeader(&quot;refresh&quot;, &quot;4&quot;);     //4s</span><br></pre></td></tr></table></figure>

<h3 id="5、设置页面定时跳转（重定向）到其他页面："><a href="#5、设置页面定时跳转（重定向）到其他页面：" class="headerlink" title="5、设置页面定时跳转（重定向）到其他页面："></a>5、设置页面定时跳转（重定向）到其他页面：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">response.setHeader(&quot;refresh&quot;, &quot;4;URL=/lesson/ok.jsp&quot;);</span><br></pre></td></tr></table></figure>

<h3 id="6、添加cookie对象（重点）"><a href="#6、添加cookie对象（重点）" class="headerlink" title="6、添加cookie对象（重点）"></a>6、添加cookie对象（重点）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//cookie：是类对象，保存一个键值对。有一定的生命期。以文件的形式保存在客户端。</span><br><span class="line">//客户端给服务器端发送请求的时候，客户端会将保存的cookie发送给服务器端。</span><br><span class="line">//清除cookie：cookie对象.setMaxAge(0);</span><br><span class="line">Cookie c1 = new Cookie(&quot;user&quot;, &quot;wang&quot;);</span><br><span class="line">//设置cookie的生命期，单位是秒</span><br><span class="line">c1.setMaxAge(20);</span><br><span class="line">//设置cookie的路径，固定为 /</span><br><span class="line">c1.setPath(&quot;/&quot;);</span><br><span class="line">//将cookie对象添加到response中，响应给客户端</span><br><span class="line">response.addCookie(c1);</span><br></pre></td></tr></table></figure>



<p><strong>案例：30天免登录。登录成功后30天内不需要再次登录，直接进入到登录成功页面。选择退出后，进入退出成功页面，再次请求登录页面，则需要进行登录操作。（重点）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;登录页面&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;%</span><br><span class="line">        Cookie[] cs = request.getCookies();</span><br><span class="line">        if (cs != null) &#123;</span><br><span class="line">            for (Cookie c : cs) &#123;</span><br><span class="line">                String name = c.getName();</span><br><span class="line">                String value = c.getValue();</span><br><span class="line">                if (&quot;wang&quot;.equals(name) &amp;&amp; &quot;123&quot;.equals(value)) &#123;</span><br><span class="line">                    request.getRequestDispatcher(&quot;/ok.jsp&quot;).forward(request, response);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    %&gt;</span><br><span class="line">    &lt;form action=&quot;/lesson/login&quot;&gt;</span><br><span class="line">        用户名：&lt;input type=&quot;text&quot; name=&quot;user&quot;&gt;&lt;br&gt;</span><br><span class="line">        密码：&lt;input type=&quot;password&quot; name=&quot;pwd&quot;&gt;&lt;br&gt;</span><br><span class="line">        &lt;input type=&quot;checkbox&quot; name=&quot;ten&quot; value=&quot;30&quot;&gt;30天免登录&lt;br&gt;</span><br><span class="line">        &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@WebServlet(value = &quot;/login&quot;)</span><br><span class="line">public class LoginServlet extends HttpServlet &#123;</span><br><span class="line">    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        String user = request.getParameter(&quot;user&quot;);</span><br><span class="line">        String pwd = request.getParameter(&quot;pwd&quot;);</span><br><span class="line">        if (&quot;wang&quot;.equals(user) &amp;&amp; &quot;123&quot;.equals(pwd))&#123;</span><br><span class="line">            String ten = request.getParameter(&quot;ten&quot;);</span><br><span class="line">            if (ten == null)&#123;</span><br><span class="line">                request.getRequestDispatcher(&quot;/ok.jsp&quot;).forward(request, response);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                //如果用户名密码正确，同时十天免登录勾选</span><br><span class="line">                Cookie c = new Cookie(user, pwd);</span><br><span class="line">                c.setMaxAge(200);</span><br><span class="line">                c.setPath(&quot;/&quot;);</span><br><span class="line">                response.addCookie(c);</span><br><span class="line">                request.getRequestDispatcher(&quot;/ok.jsp&quot;).forward(request, response);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            request.getRequestDispatcher(&quot;/fail.jsp&quot;).forward(request, response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        doPost(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;退出页面&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;%</span><br><span class="line">        Cookie c = new Cookie(&quot;wang&quot;, &quot;123&quot;);</span><br><span class="line">        c.setMaxAge(0);</span><br><span class="line">        c.setPath(&quot;/&quot;);</span><br><span class="line">        response.addCookie(c);</span><br><span class="line">    %&gt;</span><br><span class="line">    成功退出页面========================</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>



<h2 id="四、session（重点）"><a href="#四、session（重点）" class="headerlink" title="四、session（重点）"></a>四、session（重点）</h2><p>类型：HttpSession</p>
<p>开关：&lt;%@ page session&#x3D;”true” %&gt;</p>
<h3 id="1、域对象，一次会话。"><a href="#1、域对象，一次会话。" class="headerlink" title="1、域对象，一次会话。"></a>1、域对象，一次会话。</h3><h3 id="2、设置会话有效时间：（重点）"><a href="#2、设置会话有效时间：（重点）" class="headerlink" title="2、设置会话有效时间：（重点）"></a>2、设置会话有效时间：（重点）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在conf/web.xml文件中配置了session的生命期为 30 分钟。</span><br><span class="line">&lt;session-config&gt;</span><br><span class="line">        &lt;session-timeout&gt;30&lt;/session-timeout&gt;</span><br><span class="line">&lt;/session-config&gt;</span><br></pre></td></tr></table></figure>

<p>public void <strong>setMaxInactiveInterval</strong>(int interval)</p>
<p>指定在 servlet 容器使此会话失效之前客户端请求之间的时间间隔，以秒为单位。负数时间指示会话永远不会超时。</p>
<h3 id="3、获取session对象的ID值："><a href="#3、获取session对象的ID值：" class="headerlink" title="3、获取session对象的ID值："></a>3、获取session对象的ID值：</h3><p>session的id值的意义：每个session对象都有一个ID值，该session对象的ID值保存在cookie中。客户端给服务器端发送请求时会将该cookie对象发送过去，服务器端根据cookie对象中的JSESSIONID对应的值确定使用哪个session对象。</p>
<p>获取session的id值：getId()</p>
<h3 id="4、手动销毁session对象：（重点）"><a href="#4、手动销毁session对象：（重点）" class="headerlink" title="4、手动销毁session对象：（重点）"></a>4、手动销毁session对象：（重点）</h3><p>销毁session对象：invalidate()</p>
<p>注意：销毁session对象后，就不能再使用session对象，否则，报异常。</p>
<h3 id="5、案例"><a href="#5、案例" class="headerlink" title="5、案例"></a>5、案例</h3><p>登录成功页面显示用户名；</p>
<p>给某个页面发送请求，在该页面中判断是否登录成功，如果没有成功，则跳转到登录页面；</p>
<h2 id="五、application（重点）"><a href="#五、application（重点）" class="headerlink" title="五、application（重点）"></a>五、application（重点）</h2><p>类型：ServletContext</p>
<h3 id="1、域对象："><a href="#1、域对象：" class="headerlink" title="1、域对象："></a>1、域对象：</h3><p>生命期为服务器的启动到关闭。</p>
<h3 id="2、获取web-xml文件中标签中配置的数据："><a href="#2、获取web-xml文件中标签中配置的数据：" class="headerlink" title="2、获取web.xml文件中标签中配置的数据："></a>2、获取web.xml文件中<context-param>标签中配置的数据：</h3><h3 id="3、获取文件在服务器中的绝对路径："><a href="#3、获取文件在服务器中的绝对路径：" class="headerlink" title="3、获取文件在服务器中的绝对路径："></a>3、获取文件在服务器中的绝对路径：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">getRealPath(&quot;/index.jsp&quot;)</span><br></pre></td></tr></table></figure>

<h3 id="4、案例："><a href="#4、案例：" class="headerlink" title="4、案例："></a>4、案例：</h3><p>在页面中显示该页面被所有的客户端一共访问的次数。把application当作一个计数器使用。</p>
<h2 id="六、config"><a href="#六、config" class="headerlink" title="六、config"></a>六、config</h2><p>类型：ServletConfig</p>
<h3 id="1、获取标签中的标签中配置的数据："><a href="#1、获取标签中的标签中配置的数据：" class="headerlink" title="1、获取标签中的标签中配置的数据："></a>1、获取<servlet>标签中的<init-param>标签中配置的数据：</h3><p>只能给<url-pattern>标签中配置的url发送请求时，才能获取到配置的数据。</p>
<p>直接给jsp文件发送请求，则不能获取到配置的数据。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">    &lt;servlet-name&gt;conf&lt;/servlet-name&gt;</span><br><span class="line">    &lt;!-- 文件路径前一定要加 / , 该 / 表示web目录--&gt;</span><br><span class="line">    &lt;jsp-file&gt;/conf.jsp&lt;/jsp-file&gt;</span><br><span class="line">    &lt;init-param&gt;</span><br><span class="line">        &lt;param-name&gt;charset&lt;/param-name&gt;</span><br><span class="line">        &lt;param-value&gt;utf-8&lt;/param-value&gt;</span><br><span class="line">    &lt;/init-param&gt;</span><br><span class="line">&lt;/servlet&gt;</span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">    &lt;servlet-name&gt;conf&lt;/servlet-name&gt;</span><br><span class="line">    &lt;url-pattern&gt;/config&lt;/url-pattern&gt;</span><br><span class="line">&lt;/servlet-mapping&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2、重定向到WEB-INF目录下的jsp文件"><a href="#2、重定向到WEB-INF目录下的jsp文件" class="headerlink" title="2、重定向到WEB-INF目录下的jsp文件"></a>2、重定向到WEB-INF目录下的jsp文件</h3><p>可以转发到WEB-INF目录下的jsp文件；不能直接重定向到WEB-INF目录下的jsp文件；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">       &lt;servlet-name&gt;ok&lt;/servlet-name&gt;</span><br><span class="line">       &lt;!-- 文件路径前一定要加 / , 该 / 表示web目录--&gt;</span><br><span class="line">       &lt;jsp-file&gt;/WEB-INF/ok.jsp&lt;/jsp-file&gt;</span><br><span class="line">   &lt;/servlet&gt;</span><br><span class="line">   &lt;servlet-mapping&gt;</span><br><span class="line">       &lt;servlet-name&gt;ok&lt;/servlet-name&gt;</span><br><span class="line">       &lt;url-pattern&gt;/ok&lt;/url-pattern&gt;</span><br><span class="line">   &lt;/servlet-mapping&gt;</span><br></pre></td></tr></table></figure>



<h2 id="七、out"><a href="#七、out" class="headerlink" title="七、out"></a>七、out</h2><p>类型：JspWriter</p>
<h3 id="1、将页面相应给客户端："><a href="#1、将页面相应给客户端：" class="headerlink" title="1、将页面相应给客户端："></a>1、将页面相应给客户端：</h3><p>public void write(String str)</p>
<h3 id="2、将缓冲区的数据发送给客户端："><a href="#2、将缓冲区的数据发送给客户端：" class="headerlink" title="2、将缓冲区的数据发送给客户端："></a>2、将缓冲区的数据发送给客户端：</h3><p>public void <strong>flush</strong>() </p>
<h3 id="3、判断是否设置了自动刷新缓冲区"><a href="#3、判断是否设置了自动刷新缓冲区" class="headerlink" title="3、判断是否设置了自动刷新缓冲区"></a>3、判断是否设置了自动刷新缓冲区</h3><p>public boolean <strong>isAutoFlush</strong>()</p>
<h3 id="4、获取缓冲区的大小（字节）："><a href="#4、获取缓冲区的大小（字节）：" class="headerlink" title="4、获取缓冲区的大小（字节）："></a>4、获取缓冲区的大小（字节）：</h3><p>public int <strong>getBufferSize</strong>() </p>
<h2 id="八、exception"><a href="#八、exception" class="headerlink" title="八、exception"></a>八、exception</h2><p>类型：Throwable</p>
<p>开关：&lt;%@ page isErrorPage&#x3D;”true” %&gt;</p>
<h3 id="1、获取上个页面从错误信息"><a href="#1、获取上个页面从错误信息" class="headerlink" title="1、获取上个页面从错误信息"></a>1、获取上个页面从错误信息</h3><p> public String getMessage(); </p>
<h2 id="九、page"><a href="#九、page" class="headerlink" title="九、page"></a>九、page</h2><p>page &#x3D; this;</p>
<h2 id="十、pageContext（重要）"><a href="#十、pageContext（重要）" class="headerlink" title="十、pageContext（重要）"></a>十、pageContext（重要）</h2><p>类型：PageContext</p>
<h3 id="1、域对象：-1"><a href="#1、域对象：-1" class="headerlink" title="1、域对象："></a>1、域对象：</h3><p>生命期为当前页面。</p>
<p>void <strong>setAttribute</strong>(String name, Object value)</p>
<h3 id="2、域对象：-1"><a href="#2、域对象：-1" class="headerlink" title="2、域对象："></a>2、域对象：</h3><p>public void <strong>setAttribute</strong>(String name, Object value,  int scope) </p>
<p>第三个参数的取值：PAGE_SCOPE  REQUEST_SCOPE  SESSION_SCOPE  APPLICATION_SCOPE</p>
<p>3、获取其他内置对象：</p>
<p>public <a href="../javax.servlet.ServletRequest.html">ServletRequest</a>  <strong>getRequest</strong>()</p>
<h1 id="文件上传与下载"><a href="#文件上传与下载" class="headerlink" title="文件上传与下载"></a>文件上传与下载</h1><h2 id="一、文件下载："><a href="#一、文件下载：" class="headerlink" title="一、文件下载："></a>一、文件下载：</h2><p>1、获取客户端发送文件名</p>
<p>2、处理文件名中的中文乱码问题</p>
<p>3、给response设置响应头。</p>
<p>4、根据下载的文件创建输入流。</p>
<p>5、根据response创建输出流。</p>
<p>6、根据输入流从文件读取数据，将读取的 数据根据输出流发送给客户端。</p>
<p>7、关闭流</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;title&gt;$Title$&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">  &lt;%</span><br><span class="line">    String path;</span><br><span class="line">    path = request.getContextPath();</span><br><span class="line">  %&gt;</span><br><span class="line">  &lt;a href=&quot;&lt;%=path%&gt;/down?file=apache-tomcat-8.5.33.zip&quot;&gt;apache-tomcat-8.5.33.zip&lt;/a&gt;</span><br><span class="line">  &lt;a href=&quot;&lt;%=path%&gt;/down?file=Typora文档工具(无需破解).rar&quot;&gt;Typora文档工具(无需破解).rar&lt;/a&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@WebServlet(value = &quot;/down&quot;)</span><br><span class="line">public class DownloadServlet extends HttpServlet &#123;</span><br><span class="line">    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">//        1、获取客户端发送文件名</span><br><span class="line">        request.setCharacterEncoding(&quot;utf-8&quot;);</span><br><span class="line">        String file = request.getParameter(&quot;file&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//        2、处理文件名中的中文乱码问题</span><br><span class="line">        response.setContentType(&quot;text/html;charset=UTF-8&quot;);</span><br><span class="line"></span><br><span class="line">//        3、给response设置响应头。</span><br><span class="line">        response.setHeader(&quot;Content-Disposition&quot;, &quot;attachment;fileName=&quot;</span><br><span class="line">                + URLEncoder.encode(file, &quot;utf-8&quot;));</span><br><span class="line">        System.out.println(file);</span><br><span class="line"></span><br><span class="line">//        4、根据下载的文件创建输入流。</span><br><span class="line">        FileInputStream in = new FileInputStream(&quot;D:\\work\\榆林学院\\20级资料\\资料\\&quot; + file);</span><br><span class="line"></span><br><span class="line">//        5、根据response创建输出流。</span><br><span class="line">        ServletOutputStream out = response.getOutputStream();</span><br><span class="line"></span><br><span class="line">//        6、根据输入流从文件读取数据，将读取的 数据根据输出流发送给客户端。</span><br><span class="line">        byte[] b = new byte[1024];</span><br><span class="line">        while (true)&#123;</span><br><span class="line">            int len = in.read(b);</span><br><span class="line">            if (len &lt;= 0)</span><br><span class="line">                break;</span><br><span class="line">            out.write(b, 0, len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">//        7、关闭流</span><br><span class="line">        out.close();</span><br><span class="line">        in.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        doPost(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="二、文件上传："><a href="#二、文件上传：" class="headerlink" title="二、文件上传："></a>二、文件上传：</h2><p>配置环境：添加两个jar文件。</p>
<h3 id="1、前端：（重要）"><a href="#1、前端：（重要）" class="headerlink" title="1、前端：（重要）"></a>1、前端：（重要）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;title&gt;$Title$&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;form action=&quot;&lt;%=request.getContextPath()%&gt;/upload&quot;</span><br><span class="line">          method=&quot;post&quot;</span><br><span class="line">          enctype=&quot;multipart/form-data&quot;&gt;</span><br><span class="line">      &lt;input type=&quot;file&quot; name=&quot;f1&quot;&gt;&lt;br&gt;</span><br><span class="line">      &lt;input type=&quot;file&quot; name=&quot;f2&quot;&gt;&lt;br&gt;</span><br><span class="line">      &lt;input type=&quot;submit&quot; value=&quot;上传&quot;&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>



<h3 id="2、后端："><a href="#2、后端：" class="headerlink" title="2、后端："></a>2、后端：</h3><p>检查是否为多媒体上传</p>
<p>创建磁盘工厂</p>
<p>创建文件上传工具</p>
<p>接收request中表单的所有内容</p>
<p>遍历接收的表单内容，将多媒体数据保存到文件中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@WebServlet(value = &quot;/upload&quot;)</span><br><span class="line">public class UploadServlet extends HttpServlet &#123;</span><br><span class="line">    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">//        设置编码</span><br><span class="line">        request.setCharacterEncoding(&quot;utf-8&quot;);</span><br><span class="line">        response.setContentType(&quot;text/html;charset=UTF-8&quot;);</span><br><span class="line">//        检查是否为多媒体上传</span><br><span class="line">        if (!ServletFileUpload.isMultipartContent(request))&#123;</span><br><span class="line">            PrintWriter out = response.getWriter();</span><br><span class="line">            out.write(&quot;Error：表单中没有多媒体内容，必须包含：enctype=multipart/form-data&quot;);</span><br><span class="line">            out.flush();</span><br><span class="line">            out.close();</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">//        创建磁盘工厂</span><br><span class="line">        DiskFileItemFactory factory = new DiskFileItemFactory();</span><br><span class="line">//        创建文件上传工具</span><br><span class="line">        ServletFileUpload upload = new ServletFileUpload(factory);</span><br><span class="line">//        接收request中表单的所有内容</span><br><span class="line">        List&lt;FileItem&gt; list = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            list = upload.parseRequest(request);</span><br><span class="line">        &#125; catch (FileUploadException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">//        遍历接收的表单内容，将多媒体数据保存到文件中</span><br><span class="line">        for (FileItem item: list)&#123;</span><br><span class="line">            //判断该表单项是否为file类型的表单元素</span><br><span class="line">            if (!item.isFormField())&#123;</span><br><span class="line">                String name = item.getName();</span><br><span class="line">                File file = new File(&quot;D:\\work\\榆林学院\\20级资料\\JavaWeb基础\\&quot; + name);</span><br><span class="line">                try &#123;</span><br><span class="line">                    item.write(file);</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        doPost(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="EL表达式语言"><a href="#EL表达式语言" class="headerlink" title="EL表达式语言"></a>EL表达式语言</h1><h2 id="一、概念：-1"><a href="#一、概念：-1" class="headerlink" title="一、概念："></a>一、概念：</h2><h3 id="1、EL："><a href="#1、EL：" class="headerlink" title="1、EL："></a>1、EL：</h3><p>Expression  Language 表达式语言</p>
<h3 id="2、功能："><a href="#2、功能：" class="headerlink" title="2、功能："></a>2、功能：</h3><p>更  方便  的从某些内置对象中  读取  数据。如：request、session、application、pageContext等</p>
<h3 id="3、开关："><a href="#3、开关：" class="headerlink" title="3、开关："></a>3、开关：</h3><p>&lt;%@ page isELIgnored&#x3D;”false” %&gt;</p>
<h3 id="4、语法：（重点）"><a href="#4、语法：（重点）" class="headerlink" title="4、语法：（重点）"></a>4、语法：（重点）</h3><p>${表达式} </p>
<p>作用等同于 &lt;%&#x3D;表达式%&gt;</p>
<p>操作数可以是数值、字符串、boolean数据</p>
<h2 id="二、读取数据"><a href="#二、读取数据" class="headerlink" title="二、读取数据"></a>二、读取数据</h2><p>隐式对象.name 或  隐式对象[“name”]</p>
<p>如果name名字中有特殊符号，如 - . 等，则需要使用第二中格式。</p>
<p>如：请求头、参数、cookie、attribute数据等。</p>
<p>bean对象：隐式对象.name.成员变量名</p>
<p>数组：隐式对象.name[下标]</p>
<p>list集合：隐式对象.name[下标]</p>
<p>map集合：隐式对象.name.key  或  隐式对象.name[“key”]</p>
<h2 id="三、运算符："><a href="#三、运算符：" class="headerlink" title="三、运算符："></a>三、运算符：</h2><h3 id="1、算术运算符："><a href="#1、算术运算符：" class="headerlink" title="1、算术运算符："></a>1、算术运算符：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+ - * / % 		div  mod</span><br></pre></td></tr></table></figure>

<h3 id="2、逻辑运算符："><a href="#2、逻辑运算符：" class="headerlink" title="2、逻辑运算符："></a>2、逻辑运算符：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&amp;&amp;  ||  !   and   or   not</span><br></pre></td></tr></table></figure>

<h3 id="3、关系运算符："><a href="#3、关系运算符：" class="headerlink" title="3、关系运算符："></a>3、关系运算符：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; &lt; &gt;= &lt;=  != ==	eq  ne  lt  le  gt  ge</span><br></pre></td></tr></table></figure>

<h3 id="4、条件运算符："><a href="#4、条件运算符：" class="headerlink" title="4、条件运算符："></a>4、条件运算符：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?  :</span><br></pre></td></tr></table></figure>

<h3 id="5、空运算符：（重点）"><a href="#5、空运算符：（重点）" class="headerlink" title="5、空运算符：（重点）"></a>5、空运算符：（重点）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">empty 表达式</span><br><span class="line">表达式的值为 null  或  &quot;&quot;  ，则结果为true</span><br></pre></td></tr></table></figure>



<h2 id="四、隐式对象：（重点）"><a href="#四、隐式对象：（重点）" class="headerlink" title="四、隐式对象：（重点）"></a>四、隐式对象：（重点）</h2><p>语法：${隐式对象.名字}</p>
<h3 id="1、pageScope、requestScope、sessionScope、applicationScope"><a href="#1、pageScope、requestScope、sessionScope、applicationScope" class="headerlink" title="1、pageScope、requestScope、sessionScope、applicationScope"></a>1、pageScope、requestScope、sessionScope、applicationScope</h3><p>${隐式对象.属性名} 等同于 域对象名.getAttribue(属性名);</p>
<p>${属性名} 按照作用域从小到大的域对象中查找该属性名对应的值。</p>
<h3 id="2、param"><a href="#2、param" class="headerlink" title="2、param"></a>2、param</h3><p>${param.参数名} 等同于 request.getParameter(“参数名”);</p>
<h3 id="3、paramValues"><a href="#3、paramValues" class="headerlink" title="3、paramValues"></a>3、paramValues</h3><p>${paramValues.参数名} 等同于 request.getParameterValues(“参数名”)</p>
<h3 id="4、header"><a href="#4、header" class="headerlink" title="4、header"></a>4、header</h3><p>${header.名字}  等同于  request.getHeader(“名字”)</p>
<h3 id="5、cookie"><a href="#5、cookie" class="headerlink" title="5、cookie"></a>5、cookie</h3><p>${cookie.名字} 功能：从request中接收到的cookie中查找名字叫 该名字 的Cookie对象。</p>
<h1 id="JSTL"><a href="#JSTL" class="headerlink" title="JSTL"></a>JSTL</h1><h2 id="一、概念：-2"><a href="#一、概念：-2" class="headerlink" title="一、概念："></a>一、概念：</h2><h3 id="1、概念：-1"><a href="#1、概念：-1" class="headerlink" title="1、概念："></a>1、概念：</h3><p>JSTL：JSP  Standard   Tag   Library   JSP标准标签库</p>
<p><strong>EL封装了数据访问的功能。</strong></p>
<p><strong>JSTL逻辑控制（分支、循环）、数据格式的功能。</strong></p>
<h3 id="2、好处："><a href="#2、好处：" class="headerlink" title="2、好处："></a>2、好处：</h3><p><strong>简化</strong> 了JSP和web应用程序的开发。</p>
<p>JSTL还引入了EL。</p>
<p>JSTL为条件处理、迭代、国际化、数据库访问、可扩展标记语言（xml）处理提供了支持。</p>
<h3 id="3、配置JSTL："><a href="#3、配置JSTL：" class="headerlink" title="3、配置JSTL："></a>3、配置JSTL：</h3><p>一个标签对应了若干个类。</p>
<p>导入jar文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;</span><br></pre></td></tr></table></figure>

<h2 id="二、JSTL常用标签："><a href="#二、JSTL常用标签：" class="headerlink" title="二、JSTL常用标签："></a>二、JSTL常用标签：</h2><h3 id="1、c-out（重点）"><a href="#1、c-out（重点）" class="headerlink" title="1、c:out（重点）"></a>1、c:out（重点）</h3><p>使用value属性值替换该标签。类似于&lt;%&#x3D;表达式%&gt;   ${表达式}</p>
<p>value：该属性值替换该标签。属性值可以是EL表达式。</p>
<p>default：如果value的EL表达式为空，则用defalt属性值替换该标签。</p>
<p>escapeXml：属性值为boolean类型。如果是true，则将value属性值种的标签当作普通字符显示；</p>
<h3 id="2、c-set"><a href="#2、c-set" class="headerlink" title="2、c:set"></a>2、c:set</h3><p>添加修改域对象中的数据。</p>
<p>添加：</p>
<p>var：设置需要保存的信息的属性名。</p>
<p>value：设置需要保存的信息。可以是EL表达式或常量。</p>
<p>scope：设置保存信息的范围。page   request   session   application</p>
<p>修改域对象中保存的对象的属性值：</p>
<p>target：设置需要修改的域对象中的实例名。格式：${实例名}</p>
<p>property：设置需要修改的对象的成员变量名。</p>
<p>value：设置需要修改的值。</p>
<h3 id="3、c-if（重点）"><a href="#3、c-if（重点）" class="headerlink" title="3、c:if（重点）"></a>3、c:if（重点）</h3><p>test：设置条件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;c:if test=&quot;表达式&quot;&gt;</span><br><span class="line">	脚本元素</span><br><span class="line">	HTML标签</span><br><span class="line">&lt;/c:if&gt;</span><br></pre></td></tr></table></figure>

<h3 id="4、c-choose"><a href="#4、c-choose" class="headerlink" title="4、c:choose"></a>4、c:choose</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;c:choose&gt;</span><br><span class="line">	&lt;c:when test=&quot;表达式&quot;&gt;</span><br><span class="line">		脚本元素</span><br><span class="line">		HTML标签</span><br><span class="line">	&lt;/c:when&gt;</span><br><span class="line">	&lt;c:when test=&quot;表达式&quot;&gt;</span><br><span class="line">		脚本元素</span><br><span class="line">		HTML标签</span><br><span class="line">	&lt;/c:when&gt;</span><br><span class="line">	&lt;c:when test=&quot;表达式&quot;&gt;</span><br><span class="line">		脚本元素</span><br><span class="line">		HTML标签</span><br><span class="line">	&lt;/c:when&gt;</span><br><span class="line">	......</span><br><span class="line">	&lt;c:otherwise&gt;</span><br><span class="line">		脚本元素</span><br><span class="line">		HTML标签</span><br><span class="line">	&lt;/c:otherwise&gt;</span><br><span class="line">&lt;/c:choose&gt;</span><br></pre></td></tr></table></figure>

<p>使用 c:when 和 c:otherwise 可以实现if-else的功能。</p>
<h3 id="5、c-foreach（重点）"><a href="#5、c-foreach（重点）" class="headerlink" title="5、c:foreach（重点）"></a>5、c:foreach（重点）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;c:foreach&gt;</span><br><span class="line">	循环体：  脚本元素   HTML标签	</span><br><span class="line">&lt;/c:foreach&gt;</span><br></pre></td></tr></table></figure>

<h4 id="5-1、指定循环次数："><a href="#5-1、指定循环次数：" class="headerlink" title="5.1、指定循环次数："></a>5.1、指定循环次数：</h4><p>begin：开始值</p>
<p>end：结束值</p>
<p>step：步长</p>
<p>var：pageContext域对象中的属性名，保存循环过程中的值。</p>
<h4 id="5-2、对数组或集合进行遍历：（重点）"><a href="#5-2、对数组或集合进行遍历：（重点）" class="headerlink" title="5.2、对数组或集合进行遍历：（重点）"></a>5.2、对数组或集合进行遍历：（重点）</h4><p>var：pageContext域对象中的属性名，保存循环过程中的值。</p>
<p>items：数组或集合</p>
<p>varStatus：pageContext域对象中的属性名，保存循环状态</p>
<p>​		index：begin—step—end变化过程中的值。如果没有给begin–step–end赋值，则 0 1 2 3 4 5……</p>
<p>​		count：计数器，从1开始。1 2 3 4 5……</p>
<p>​		first：是否是第一个元素</p>
<p>​		last：是否是最后一个元素</p>
<h1 id="案例：登录案例。MVC模型。"><a href="#案例：登录案例。MVC模型。" class="headerlink" title="案例：登录案例。MVC模型。"></a>案例：登录案例。MVC模型。</h1><h2 id="一、搭建环境"><a href="#一、搭建环境" class="headerlink" title="一、搭建环境"></a>一、搭建环境</h2><p>导入jdbc对应的jar文件。</p>
<p>创建数据库、创建表、插入 记录</p>
<p><img src="C:\Users\wangchao\AppData\Roaming\Typora\typora-user-images\image-20221013205545138.png" alt="image-20221013205545138"></p>
<p>u_name类型是varchar</p>
<p>pwd类型是int</p>
<h2 id="二、登录页面、判断登录成功servlet、成功页面、失败页面"><a href="#二、登录页面、判断登录成功servlet、成功页面、失败页面" class="headerlink" title="二、登录页面、判断登录成功servlet、成功页面、失败页面"></a>二、登录页面、判断登录成功servlet、成功页面、失败页面</h2><h2 id="三、编写servlet"><a href="#三、编写servlet" class="headerlink" title="三、编写servlet"></a>三、编写servlet</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@WebServlet(value = &quot;/login&quot;)</span><br><span class="line">public class LoginServlet extends HttpServlet &#123;</span><br><span class="line">    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            //获取客户端发送的用户名和密码</span><br><span class="line">            String user = request.getParameter(&quot;user&quot;);</span><br><span class="line">            int pwd = Integer.parseInt(request.getParameter(&quot;pwd&quot;));</span><br><span class="line">            //访问数据库</span><br><span class="line">            Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span><br><span class="line">            String url = &quot;jdbc:mysql://localhost:3306/wang?serverTimezone=GMT&amp;characterEncoding=utf8&quot;;</span><br><span class="line">            String name = &quot;root&quot;;</span><br><span class="line">            String password = &quot;root&quot;;</span><br><span class="line">            Connection connection = DriverManager.getConnection(url, name, password);</span><br><span class="line">            String sql = &quot;SELECT count(*) from `user`\n&quot; +</span><br><span class="line">                    &quot;where u_name=? and pwd=?&quot;;</span><br><span class="line">            PreparedStatement ps = connection.prepareStatement(sql);</span><br><span class="line">            ps.setString(1, user);</span><br><span class="line">            ps.setInt(2, pwd);</span><br><span class="line">            ResultSet set = ps.executeQuery();</span><br><span class="line">            int count = 0;</span><br><span class="line">            if (set.next())&#123;</span><br><span class="line">                count = set.getInt(1);</span><br><span class="line">            &#125;</span><br><span class="line">            //判断是否登录成功</span><br><span class="line">            boolean ok;</span><br><span class="line">            ok = count &gt; 0;</span><br><span class="line">            //根据结果进行跳转</span><br><span class="line">            if (ok)&#123;</span><br><span class="line">                HttpSession session = request.getSession();</span><br><span class="line">                session.setAttribute(&quot;user&quot;, user);</span><br><span class="line">                response.sendRedirect(&quot;/lesson/ok.jsp&quot;);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                response.sendRedirect(&quot;/lesson/fail.jsp&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        doPost(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="四、引入MVC模型（分层）"><a href="#四、引入MVC模型（分层）" class="headerlink" title="四、引入MVC模型（分层）"></a>四、引入MVC模型（分层）</h2><p>M：model    数据—访问数据库java文件   </p>
<p>​		service层：业务处理</p>
<p>​		dao层：访问数据库</p>
<p>V：view	视图—前端页面—jsp文件</p>
<p>C：controller   控制器—servlet文件</p>
<p>​		controller层：接收客户端发送的数据、根据service层返回的结果进行页面跳转</p>
<p>controller层：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@WebServlet(value = &quot;/login01&quot;)</span><br><span class="line">public class LoginServlet extends HttpServlet &#123;</span><br><span class="line">    private UserService userService = new UserService();</span><br><span class="line">    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            //获取客户端发送的用户名和密码</span><br><span class="line">            String user = request.getParameter(&quot;user&quot;);</span><br><span class="line">            String pwd = request.getParameter(&quot;pwd&quot;);</span><br><span class="line">            //调用service中的方法，判断登录是否成功</span><br><span class="line">            boolean ok = userService.judgeLogin(user, pwd);</span><br><span class="line">            //根据结果进行跳转</span><br><span class="line">            if (ok) &#123;</span><br><span class="line">                HttpSession session = request.getSession();</span><br><span class="line">                session.setAttribute(&quot;user&quot;, user);</span><br><span class="line">                response.sendRedirect(&quot;/lesson/ok.jsp&quot;);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                response.sendRedirect(&quot;/lesson/fail.jsp&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        doPost(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>service层：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class UserService &#123;</span><br><span class="line">    private UserDao userDao = new UserDao();</span><br><span class="line">    //根据dao层返回的数据判断是否登录成功。</span><br><span class="line">    public boolean judgeLogin(String user, String pwd) throws SQLException, ClassNotFoundException &#123;</span><br><span class="line">        int pwdint;</span><br><span class="line">        pwdint = Integer.parseInt(pwd);</span><br><span class="line">        int res = userDao.userPwdNumber(user, pwdint);</span><br><span class="line">        return res &gt; 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>dao层：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class UserDao &#123;</span><br><span class="line">    //根据用户名和密码查找记录数。</span><br><span class="line">    public int userPwdNumber(String user, int pwd) throws ClassNotFoundException, SQLException &#123;</span><br><span class="line">        Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span><br><span class="line">        String url = &quot;jdbc:mysql://localhost:3306/wang?serverTimezone=GMT&amp;characterEncoding=utf8&quot;;</span><br><span class="line">        String name = &quot;root&quot;;</span><br><span class="line">        String password = &quot;root&quot;;</span><br><span class="line">        Connection connection = DriverManager.getConnection(url, name, password);</span><br><span class="line">        String sql = &quot;SELECT count(*) from `user`\n&quot; +</span><br><span class="line">                &quot;where u_name=? and pwd=?&quot;;</span><br><span class="line">        PreparedStatement ps = connection.prepareStatement(sql);</span><br><span class="line">        ps.setString(1, user);</span><br><span class="line">        ps.setInt(2, pwd);</span><br><span class="line">        ResultSet set = ps.executeQuery();</span><br><span class="line">        int count = 0;</span><br><span class="line">        if (set.next())&#123;</span><br><span class="line">            count = set.getInt(1);</span><br><span class="line">        &#125;</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="监听器和过滤器"><a href="#监听器和过滤器" class="headerlink" title="监听器和过滤器"></a>监听器和过滤器</h1><h2 id="一、监听器：（重点）"><a href="#一、监听器：（重点）" class="headerlink" title="一、监听器：（重点）"></a>一、监听器：（重点）</h2><p>监听器：实现了 ****listener 接口。</p>
<p>作用：监听某些事件，一旦监听的事件产生，则执行设定的程序。</p>
<p><strong>使用：定义监听器类；在web.xml文件中配置listener标签；</strong></p>
<h3 id="1、applicaton监听：（重点）"><a href="#1、applicaton监听：（重点）" class="headerlink" title="1、applicaton监听：（重点）"></a>1、applicaton监听：（重点）</h3><h4 id="1-1、监听创建和销毁："><a href="#1-1、监听创建和销毁：" class="headerlink" title="1.1、监听创建和销毁："></a>1.1、监听创建和销毁：</h4><p>实现 ServletContextListener 接口。</p>
<p>通过参数可以获取到 ServletContext 对象。</p>
<h4 id="1-2、监听属性增删改："><a href="#1-2、监听属性增删改：" class="headerlink" title="1.2、监听属性增删改："></a>1.2、监听属性增删改：</h4><p>实现 ServletContextAttibuteListener 接口。</p>
<p>通过形参可以获取操作的属性名和属性值。</p>
<h3 id="2、session监听："><a href="#2、session监听：" class="headerlink" title="2、session监听："></a>2、session监听：</h3><h4 id="2-1、监听创建和销毁："><a href="#2-1、监听创建和销毁：" class="headerlink" title="2.1、监听创建和销毁："></a>2.1、监听创建和销毁：</h4><p>实现 HttpSessionListener 接口。</p>
<p>通过参数可以获取到 session 对象。</p>
<h4 id="2-2、监听属性增删改："><a href="#2-2、监听属性增删改：" class="headerlink" title="2.2、监听属性增删改："></a>2.2、监听属性增删改：</h4><p>实现 HttpSessionAttibuteListener 接口。</p>
<p>通过形参可以获取操作的属性名和属性值。</p>
<h3 id="3、request监听："><a href="#3、request监听：" class="headerlink" title="3、request监听："></a>3、request监听：</h3><h4 id="2-1、监听创建和销毁：-1"><a href="#2-1、监听创建和销毁：-1" class="headerlink" title="2.1、监听创建和销毁："></a>2.1、监听创建和销毁：</h4><p>实现 ServletRequestListener 接口。</p>
<p>通过参数可以获取到 request 对象。</p>
<h4 id="2-2、监听属性增删改：-1"><a href="#2-2、监听属性增删改：-1" class="headerlink" title="2.2、监听属性增删改："></a>2.2、监听属性增删改：</h4><p>实现 ServletRequestAttibuteListener 接口。</p>
<p>通过形参可以获取操作的属性名和属性值。</p>
<h2 id="二、过滤器：（重点）"><a href="#二、过滤器：（重点）" class="headerlink" title="二、过滤器：（重点）"></a>二、过滤器：（重点）</h2><h3 id="1、概念-："><a href="#1、概念-：" class="headerlink" title="1、概念 ："></a>1、概念 ：</h3><p>过滤器：实现了Filter接口的类。</p>
<p>作用：可以对servlet的请求和响应进行检查和修改。</p>
<p><strong>工作原理：客户端发送的请求被过滤器拦截，过滤器执行结束后可以执行请求的页面。</strong></p>
<p><strong>使用：定义过滤器类；配置web.xml文件中的filter 和 filter-mapping标签</strong>；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">配置url-pattern：</span><br><span class="line">精确匹配：具体的路径名和文件名。如：/a/b/a.jsp</span><br><span class="line">目录匹配：指定路径。如：/a/*</span><br><span class="line">扩展匹配：*.后缀名。如：*.jsp</span><br></pre></td></tr></table></figure>

<p>过滤器链：给一个web程序发送请求时，可能被多个过滤器捕获，则执行多个过滤器，按照web.xml文件中配置的顺序执行。</p>
<h3 id="2、范例："><a href="#2、范例：" class="headerlink" title="2、范例："></a>2、范例：</h3><p>登录页面、登录成功页面、商品信息页面、购买商品页面。</p>
<p>当给购买商品页面发送请求时，判断是否登录成功，如果已经登录成功，则显示购买商品页面，否则，显示登录页面。所有页面通过过滤器设施编码为utf-8。</p>
<h1 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h1><h2 id="一、概念：-3"><a href="#一、概念：-3" class="headerlink" title="一、概念："></a>一、概念：</h2><h3 id="1、概念：-2"><a href="#1、概念：-2" class="headerlink" title="1、概念："></a>1、概念：</h3><p>AJAX：Asynchronous  Javascript  And  Xml  异步JS和XML</p>
<h3 id="2、好处：（重点）"><a href="#2、好处：（重点）" class="headerlink" title="2、好处：（重点）"></a>2、好处：（重点）</h3><p>页面不会改变，只会更新页面的局部。</p>
<h2 id="二、工作原理：（重点）"><a href="#二、工作原理：（重点）" class="headerlink" title="二、工作原理：（重点）"></a>二、工作原理：（重点）</h2><p>客户端的 JS对象 XMLHttpRequest 给服务器端发送请求，服务器端响应的数据被客户端的 JS对象 接收，通过JS程序修改页面的局部，页面不改变。该 JS对象称为 AJAX引擎。</p>
<p>在AJAX操作中，在服务器端无法进行页面跳转。</p>
<h2 id="三、使用JavaScript实现AJAX步骤：（重点）"><a href="#三、使用JavaScript实现AJAX步骤：（重点）" class="headerlink" title="三、使用JavaScript实现AJAX步骤：（重点）"></a>三、使用JavaScript实现AJAX步骤：（重点）</h2><p>1、创建JS对象实例，并进行初始化。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function ajaxFunction()</span><br><span class="line">&#123;</span><br><span class="line">  try</span><br><span class="line">  &#123;</span><br><span class="line">    // Firefox, Opera 8.0+, Safari</span><br><span class="line">    xmlHttp=new XMLHttpRequest();</span><br><span class="line">  &#125;</span><br><span class="line">  catch (e)</span><br><span class="line">  &#123;</span><br><span class="line">    // Internet Explorer</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">      xmlHttp=new ActiveXObject(&quot;Msxml2.XMLHTTP&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    catch (e)</span><br><span class="line">    &#123;</span><br><span class="line">      try</span><br><span class="line">      &#123;</span><br><span class="line">        xmlHttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      catch (e)</span><br><span class="line">      &#123;</span><br><span class="line">        alert(&quot;您的浏览器不支持AJAX！&quot;);</span><br><span class="line">        return false;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、指定响应处理函数，同时定义响应处理函数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xmlHttp.onreadystatechange=function()</span><br><span class="line">&#123;</span><br><span class="line">  // 我们需要在这里写一些代码</span><br><span class="line">  if(xmlHttp.readyState==4)&#123;</span><br><span class="line">    var data;</span><br><span class="line">    data = xmlHttp.responseText;</span><br><span class="line">    if (data == &#x27;true&#x27;)&#123;</span><br><span class="line">      //页面跳转</span><br><span class="line">      window.location.href = &quot;/lesson/ok.jsp&quot;;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      //显示span标签内容</span><br><span class="line">      var span;</span><br><span class="line">      span = document.getElementById(&quot;span&quot;);</span><br><span class="line">      span.style.display = &quot;inline&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、通过调用open方法 设置发送请求的URL、请求方式、是否异步。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xmlHttp.open(&quot;get&quot;, &quot;/lesson/login?user=wang&amp;pwd=1123&quot;, true);</span><br></pre></td></tr></table></figure>

<p>4、通过调用send方法 通过JS对象发送请求。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xmlHttp.send(null);</span><br></pre></td></tr></table></figure>

<p>通过“名字&#x3D;值&amp;名字&#x3D;值&amp;名字&#x3D;值…..”给服务器端发送参数</p>
<h2 id="四、使用JQuery实现AJAX："><a href="#四、使用JQuery实现AJAX：" class="headerlink" title="四、使用JQuery实现AJAX："></a>四、使用JQuery实现AJAX：</h2><h3 id="1、JQuery："><a href="#1、JQuery：" class="headerlink" title="1、JQuery："></a>1、JQuery：</h3><p>使用JS程序开发的代码库。JS框架。</p>
<p>初衷：写的少，做的多。</p>
<h3 id="2、使用JQuery实现ajax："><a href="#2、使用JQuery实现ajax：" class="headerlink" title="2、使用JQuery实现ajax："></a>2、使用JQuery实现ajax：</h3><h4 id="2-1、-get-pos"><a href="#2-1、-get-pos" class="headerlink" title="2.1、$.get  $.pos"></a>2.1、$.get  $.pos</h4><p>$.get(url,data,callback,datatype)</p>
<p>$.post(url,data,callback,datatype)</p>
<p>url：给服务器端发送请求的url</p>
<p>data：给服务器端发送请求时发送的数据。数据格式通常为JSON格式。{“名字”:值，”名字”:值……}</p>
<p>callback：函数。接收服务器端响应的数据后进行的事件处理程序。</p>
<p>​		第一个参数：接收服务器端响应的数据。</p>
<p>​		第二个参数：接收服务器端响应数据的状态。值为 “success” 则说明接收完成。</p>
<p>​		第三个参数：接收 AJAX引擎对象。即：XMLHttpRequest 对象。</p>
<p>datatype：设定发送给服务器端的数据类型。</p>
<h4 id="2-2、-ajax（重点）"><a href="#2-2、-ajax（重点）" class="headerlink" title="2.2、$.ajax（重点）"></a>2.2、$.ajax（重点）</h4><p>$.ajax(<em>{name:value, name:value, … }</em>)		（重点）</p>
<p>该参数规定 AJAX 请求的一个或多个名称&#x2F;值对。</p>
<p>下面的表格中列出了可能的名称&#x2F;值：</p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">值&#x2F;描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>async</strong></td>
<td align="left">布尔值，表示请求是否异步处理。默认是 true。</td>
</tr>
<tr>
<td align="left">beforeSend(<em>xhr</em>)</td>
<td align="left">发送请求前运行的函数。</td>
</tr>
<tr>
<td align="left">cache</td>
<td align="left">布尔值，表示浏览器是否缓存被请求页面。默认是 true。</td>
</tr>
<tr>
<td align="left">complete(<em>xhr,status</em>)</td>
<td align="left">请求完成时运行的函数（在请求成功或失败之后均调用，即在 success 和 error 函数之后）。</td>
</tr>
<tr>
<td align="left">contentType</td>
<td align="left">发送数据到服务器时所使用的内容类型。默认是：”application&#x2F;x-www-form-urlencoded”。</td>
</tr>
<tr>
<td align="left">context</td>
<td align="left">为所有 AJAX 相关的回调函数规定 “this” 值。</td>
</tr>
<tr>
<td align="left"><strong>data</strong></td>
<td align="left">规定要发送到服务器的数据。</td>
</tr>
<tr>
<td align="left">dataFilter(<em>data</em>,<em>type</em>)</td>
<td align="left">用于处理 XMLHttpRequest 原始响应数据的函数。</td>
</tr>
<tr>
<td align="left">dataType</td>
<td align="left">预期的服务器响应的数据类型。</td>
</tr>
<tr>
<td align="left">error(<em>xhr,status,error</em>)</td>
<td align="left">如果请求失败要运行的函数。</td>
</tr>
<tr>
<td align="left">global</td>
<td align="left">布尔值，规定是否为请求触发全局 AJAX 事件处理程序。默认是 true。</td>
</tr>
<tr>
<td align="left">ifModified</td>
<td align="left">布尔值，规定是否仅在最后一次请求以来响应发生改变时才请求成功。默认是 false。</td>
</tr>
<tr>
<td align="left">jsonp</td>
<td align="left">在一个 jsonp 中重写回调函数的字符串。</td>
</tr>
<tr>
<td align="left">jsonpCallback</td>
<td align="left">在一个 jsonp 中规定回调函数的名称。</td>
</tr>
<tr>
<td align="left">password</td>
<td align="left">规定在 HTTP 访问认证请求中使用的密码。</td>
</tr>
<tr>
<td align="left">processData</td>
<td align="left">布尔值，规定通过请求发送的数据是否转换为查询字符串。默认是 true。</td>
</tr>
<tr>
<td align="left">scriptCharset</td>
<td align="left">规定请求的字符集。</td>
</tr>
<tr>
<td align="left"><strong>success(<em>result,status,xhr</em>)</strong></td>
<td align="left">当请求成功时运行的函数。</td>
</tr>
<tr>
<td align="left">timeout</td>
<td align="left">设置本地的请求超时时间（以毫秒计）。</td>
</tr>
<tr>
<td align="left">traditional</td>
<td align="left">布尔值，规定是否使用参数序列化的传统样式。</td>
</tr>
<tr>
<td align="left"><strong>type</strong></td>
<td align="left">规定请求的类型（GET 或 POST）。</td>
</tr>
<tr>
<td align="left"><strong>url</strong></td>
<td align="left">规定发送请求的 URL。默认是当前页面。</td>
</tr>
<tr>
<td align="left">username</td>
<td align="left">规定在 HTTP 访问认证请求中使用的用户名。</td>
</tr>
<tr>
<td align="left">xhr</td>
<td align="left">用于创建 XMLHttpRequest 对象的函数。</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JSON 与 JS 对象的关系</span><br><span class="line">JSON 是 JS 对象的字符串表示法，它使用文本表示一个 JS 对象的信息，本质是一个字符串。如</span><br><span class="line">var obj = &#123;a: &#x27;Hello&#x27;, b: &#x27;World&#x27;&#125;; //这是一个对象，注意键名也是可以使用引号包裹的</span><br><span class="line">var json = &#x27;&#123;&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;&#125;&#x27;; //这是一个 JSON 字符串，本质是一个字符串</span><br><span class="line">JSON 和 JS 对象互转</span><br><span class="line">要实现从JSON字符串转换为JS对象，使用 JSON.parse() 方法：</span><br><span class="line">var obj = JSON.parse(&#x27;&#123;&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;&#125;&#x27;); //结果是 &#123;a: &#x27;Hello&#x27;, b: &#x27;World&#x27;&#125;</span><br><span class="line">要实现从JS对象转换为JSON字符串，使用 JSON.stringify() 方法：</span><br><span class="line">var json = JSON.stringify(&#123;a: &#x27;Hello&#x27;, b: &#x27;World&#x27;&#125;); //结果是 &#x27;&#123;&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;&#125;&#x27;</span><br></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Java</category>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Web</tag>
        <tag>后端</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>Java面试笔记(自学加总结)</title>
    <url>/p/3ccd8a0/</url>
    <content><![CDATA[<h1 id="Java基础面试题"><a href="#Java基础面试题" class="headerlink" title="Java基础面试题"></a>Java基础面试题</h1><h2 id="Java的特点"><a href="#Java的特点" class="headerlink" title="Java的特点"></a>Java的特点</h2><p><strong>Java是一个面向对象的语言</strong></p>
<p><strong>Java具有平台独立性和移植性</strong></p>
<ul>
<li>Java有一句口号：<code>Write once, run anywhere</code>，一次编写、到处运行。这也是Java的魅力所在。而实现这种特性的正是Java虚拟机JVM。已编译的Java程序可以在任何带有JVM的平台上运行。你可以在windows平台编写代码，然后拿到linux上运行。只要你在编写完代码后，将代码编译成.class文件，再把class文件打成Java包，这个jar包就可以在不同的平台上运行了。</li>
</ul>
<p><strong>Java具有稳健性</strong></p>
<ul>
<li>Java是一个强类型语言，它允许扩展编译时检查潜在类型不匹配问题的功能。Java要求显式的方法声明，它不支持C风格的隐式声明。这些严格的要求保证编译程序能捕捉调用错误，这就导致更可靠的程序。</li>
<li>异常处理是Java中使得程序更稳健的另一个特征。异常是某种类似于错误的异常条件出现的信号。使用<code>try/catch/finally</code>语句，程序员可以找到出错的处理代码，这就简化了出错处理和恢复的任务。</li>
</ul>
<span id="more"></span>

<h2 id="Java是如何实现跨平台的"><a href="#Java是如何实现跨平台的" class="headerlink" title="Java是如何实现跨平台的"></a>Java是如何实现跨平台的</h2><p>Java通过JVM（即Java虚拟机）实现跨平台</p>
<p>JVM可以理解为一个软件，不同的平台有不同的版本。而我们编写的Java代码会通过编译生成.class文件（也叫字节码文件）。而JVM就是负责将字节码文件翻译成特定平台下的机器码，通过JVM翻译成机器码后才能运行。不同的平台下编译的生成的字节码是一样的，但是通过JVM翻译成的机器码是不一样的。</p>
<p>只要在不同的平台安装对应的JVM，就可以运行字节码文件，运行我们编写的Java程序。</p>
<p>因此，运行Java程序必须有JVM的支持，因为编译的结果不是机器码，必须要经过JVM的翻译才能执行。</p>
<h2 id="Java与C-的区别"><a href="#Java与C-的区别" class="headerlink" title="Java与C++的区别"></a>Java与C++的区别</h2><ul>
<li>Java是纯粹的面向对象的语言，所有的对象都继承自java.lang.Object，而C++兼容C，不但支持面向对象也支持面向过程</li>
<li>Java通过虚拟机从而实现跨平台特性，C++依赖于特定的平台</li>
<li>Java没有指针，它的引用可以理解为安全指针，而C++和C具有一样的指针</li>
<li>Java支持自动垃圾回收，而C++需要手动回收</li>
<li>Java不支持多重继承，只能通过实现多个接口来达到相同的目的，而C++支持多重继承</li>
</ul>
<h2 id="JDK-JRE-JVM三者的关系"><a href="#JDK-JRE-JVM三者的关系" class="headerlink" title="JDK&#x2F;JRE&#x2F;JVM三者的关系"></a>JDK&#x2F;JRE&#x2F;JVM三者的关系</h2><p><strong>JDK</strong></p>
<p>全名Java Development Kit，也就是Java开发工具包</p>
<p>JDK的目录内包含JRE，也就是说安装JDK之后不需要单独安装JRE</p>
<p>而且JDK还有jinfo，jps，jstack等工具</p>
<p><strong>JRE</strong></p>
<p>全名Java RuntimeEnvironment，也就是Java运行时环境</p>
<p>我们编写的Java程序需要在JRE中运行。其主要包含JVM和Java核心类库</p>
<p>JRE是Java的运行时环境，不是一个开发环境，所以没有编译器和调试器</p>
<p>如果只需要运行Java程序而不是开发Java程序，那么就只需要安装JRE</p>
<p><strong>JVM</strong></p>
<p>全名Java Virtual Machine，也就是我们耳熟能详的Java虚拟机</p>
<p>Java语言能够跨平台的核心就在于JVM</p>
<p>所有的Java程序首先都会被编译为.class类文件，这种类型的文件可以在虚拟机上执行。也就是说，class文件不直接与机器的操作系统交互，而是通过虚拟机间接与操作系统交互，由虚拟机将程序解释给本地系统执行。</p>
<p>针对不同的系统有不同的JVM实现，有Linux版本的JVM实现，也有Windows版本的JVM实现，但是同样的一段代码在编译后的字节码是一样的。这也是Java能够实现跨平台，即一次编写，多处运行的原因所在</p>
<h2 id="Java程序是先编译执行还是先解释执行"><a href="#Java程序是先编译执行还是先解释执行" class="headerlink" title="Java程序是先编译执行还是先解释执行"></a>Java程序是先编译执行还是先解释执行</h2><p>首先我们需要了解什么是编译型执行，什么是解释型执行</p>
<p><strong>编译型执行</strong></p>
<p>在程序运行之前，通过编译器将源程序编译成机器码可运行的二进制，以后执行这个程序的时候，就不需要再进行编译了。</p>
<p>优点：</p>
<p>编译器一般会有预编译的过程将代码进行优化。因为编译至做一次，运行时不需要编译，所以编译型语言的程序执行效率高，可以脱离语言环境独立运行。</p>
<p>缺点：</p>
<p>编译之后，如果需要修改就需要将整个模块重新编译。编译的时候根据对应的运行环境生成的机器码，不同的操作系统之间移植代码就会存在问题，需要根据运行的操作系统编译不同的可执行文件。</p>
<p>代表语言：C，C++</p>
<p><strong>解释性语言</strong></p>
<p>解释型语言的源代码不是直接翻译成机器码，而是先翻译成中间代码，再由解释器对中间代码进行解释运行。在运行的时候才将源代码翻译成机器码，翻译一句，然后执行一句，直至结束。</p>
<p>优点：</p>
<ol>
<li>良好的平台兼容性，在任何环境都可以运行，前提是安装了解释器（比如虚拟机）。</li>
<li>灵活，修改代码的时候可以直接修改，可以快速部署，不用停机维护。</li>
</ol>
<p>缺点：</p>
<p>每一次运行都需要解释一遍，性能上不让编译型语言</p>
<p>代表语言：Python，JavaScript，PHP</p>
<p>对于Java语言，它的源代码会先通过javac编译成字节码，然后再通过JVM将字节码转换成机器码执行，即解释运行和编译运行配合使用，所以可以称之为混合型或者是半编译型</p>
<h2 id="面向对象和面向过程的区别"><a href="#面向对象和面向过程的区别" class="headerlink" title="面向对象和面向过程的区别"></a>面向对象和面向过程的区别</h2><p>面向对象和面向过程是一种软件开发思想。</p>
<ul>
<li>面向过程就是分析出解决问题所需要的步骤，然后用函数按这些步骤实现，使用的时候依次调用就可以了</li>
<li>面向对象是把构成问题事务分解成各个对象，分别设计这些对象，然后将他们组装成有完整功能的系统。面向过程只用函数实现，面试对象是用类实现各个功能模块。</li>
</ul>
<h2 id="面向对象有哪些特性？"><a href="#面向对象有哪些特性？" class="headerlink" title="面向对象有哪些特性？"></a>面向对象有哪些特性？</h2><p>面向对象四大特性：封装，继承，多态，抽象</p>
<ol>
<li>封装就是将类的信息隐藏在类内部，不允许外部程序直接访问，而是通过该类的实现方法对隐藏信息的操作和访问。良好的封装可以减少耦合。</li>
<li>继承是从已有的类中派生出新的类，新的类继承父类的属性和行为，并能扩展新的能力，大大增加程序的重用性和易维护性。在Java中是单继承的，也就是说一个子类只有一个父类。</li>
<li>多态是同一个行为具有多个不同表现形式的能力。在不修改程序代码的情况下改变程序运行时绑定的代码。实现多态的三要素：继承、重写、父类引用指向子类对象。<ul>
<li>静态多态性：通过重载实现，相同的方法有不同的参数列表，可以根据参数的不同，做出不同的处理。</li>
<li>动态多态性：在子类中重写父类的方法。运行期间判断所引用的对象的实际类型，根据实际类型调用相应的方法。</li>
</ul>
</li>
<li>抽象。把客观事物用代码抽象出来。</li>
</ol>
<h2 id="面向对象的六大原则"><a href="#面向对象的六大原则" class="headerlink" title="面向对象的六大原则"></a>面向对象的六大原则</h2><ul>
<li><strong>对象单一职责</strong>：我们设计创建的对象，必须职责明确，比如商品类，里面相关的属性和方法都必须跟商品相关，不能出现订单等不相关的内容。这里的类可以是模块、类库、程序集，而不单单指类。</li>
<li><strong>里式替换原则</strong>：子类能够完全替代父类，反之则不行。通常用于实现接口时运用。因为子类能够完全替代基（父）类，那么这样父类就拥有很多子类，在后续的程序扩展中就很容易进行扩展，程序完全不需要进行修改即可进行扩展。比如IA的实现为A，因为项目需求变更，现在需要新的实现，直接在容器注入处更换接口即可.</li>
<li><strong>迪米特法则</strong>，也叫最小原则，或者说最小耦合。通常在设计程序或开发程序的时候，尽量要高内聚，低耦合。当两个类进行交互的时候，会产生依赖。而迪米特法则就是建议这种依赖越少越好。就像构造函数注入父类对象时一样，当需要依赖某个对象时，并不在意其内部是怎么实现的，而是在容器中注入相应的实现，既符合里式替换原则，又起到了解耦的作用。</li>
<li>开闭原则：开放扩展，封闭修改。当项目需求发生变更时，要尽可能的不去对原有的代码进行修改，而在原有的基础上进行扩展。</li>
<li><strong>依赖倒置原则</strong>：高层模块不应该直接依赖于底层模块的具体实现，而应该依赖于底层的抽象。接口和抽象类不应该依赖于实现类，而实现类依赖接口或抽象类。</li>
<li><strong>接口隔离原则</strong>：一个对象和另外一个对象交互的过程中，依赖的内容最小。也就是说在接口设计的时候，在遵循对象单一职责的情况下，尽量减少接口的内容。</li>
</ul>
<p><strong>简化为：</strong></p>
<ul>
<li>单一职责：对象设计要求独立，不能设计万能对象。</li>
<li>开闭原则：对象修改最小化。</li>
<li>里式替换：程序扩展中抽象被具体可以替换（接口、父类、可以被实现类对象、子类替换对象）</li>
<li>迪米特：高内聚，低耦合。尽量不要依赖细节。</li>
<li>依赖倒置：面向抽象编程。也就是参数传递，或者返回值，可以使用父类类型或者接口类型。从广义上讲：基于接口编程，提前设计好接口框架。</li>
<li>接口隔离：接口设计大小要适中。过大导致污染，过小，导致调用麻烦。</li>
</ul>
<h2 id="数组到底是不是对象"><a href="#数组到底是不是对象" class="headerlink" title="数组到底是不是对象"></a>数组到底是不是对象</h2><p>先说说对象的概念：对象是根据某个类创建出来的一个实例，表示某类事务中一个具体的个体</p>
<p>对象具有各种属性，并且具有一些特定的行为。站在计算机的角度，对象就是内存中的一个内存块，在这个内存块封装了一些数据，也就是类中定义的各个属性。</p>
<p>所以，对象是用来封装数据的。</p>
<p>java中的数组具有java中其他对象的一些基本特点。比如封装了一些数据，可以访问属性，也可以调用方法。</p>
<p>因此可以说，数组是对象</p>
<p>也可以通过代码来验证数组是不是对象。比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clz</span> <span class="operator">=</span> <span class="type">int</span>[].class;</span><br><span class="line">System.out.println(clz.getSuperclass().getName());</span><br></pre></td></tr></table></figure>

<p>查看输出结果，可以看出，数组的父类就是Object类，那么可以推断出数组就是对象</p>
<h2 id="Java的基本数据类型"><a href="#Java的基本数据类型" class="headerlink" title="Java的基本数据类型"></a>Java的基本数据类型</h2><table>
<thead>
<tr>
<th>类型</th>
<th>占用的比特数</th>
<th>占用的字节数</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>8bit</td>
<td>1Byte</td>
</tr>
<tr>
<td>char</td>
<td>16bit</td>
<td>2Byte</td>
</tr>
<tr>
<td>short</td>
<td>16bit</td>
<td>2Byte</td>
</tr>
<tr>
<td>int</td>
<td>32bit</td>
<td>4Byte</td>
</tr>
<tr>
<td>float</td>
<td>32bit</td>
<td>4Byte</td>
</tr>
<tr>
<td>long</td>
<td>64bit</td>
<td>8Byte</td>
</tr>
<tr>
<td>double</td>
<td>64bit</td>
<td>8Byte</td>
</tr>
<tr>
<td>boolean</td>
<td>1bit，true or flase</td>
<td>1Byte，4Byte</td>
</tr>
</tbody></table>
<h2 id="Java的基本数据类型的包装类"><a href="#Java的基本数据类型的包装类" class="headerlink" title="Java的基本数据类型的包装类"></a>Java的基本数据类型的包装类</h2><table>
<thead>
<tr>
<th>简单类型</th>
<th>boolean</th>
<th>byte</th>
<th>char</th>
<th>short</th>
<th>Int</th>
<th>long</th>
<th>float</th>
<th>double</th>
</tr>
</thead>
<tbody><tr>
<td>二进制位数</td>
<td>1</td>
<td>8</td>
<td>16</td>
<td>16</td>
<td>32</td>
<td>64</td>
<td>32</td>
<td>64</td>
</tr>
<tr>
<td>包装类</td>
<td>Boolean</td>
<td>Byte</td>
<td>Character</td>
<td>Short</td>
<td>Integer</td>
<td>Long</td>
<td>Float</td>
<td>Double</td>
</tr>
</tbody></table>
<h2 id="了解Java的包装类型吗？为什么需要包装类？"><a href="#了解Java的包装类型吗？为什么需要包装类？" class="headerlink" title="了解Java的包装类型吗？为什么需要包装类？"></a>了解Java的包装类型吗？为什么需要包装类？</h2><p>Java 是一种面向对象语言，很多地方都需要使用对象而不是基本数据类型。比如，在集合类中，我们是无法将 int 、double 等类型放进去的。因为集合的容器要求元素是 Object 类型。</p>
<p>为了让基本类型也具有对象的特征，就出现了包装类型。相当于将基本类型包装起来，使得它具有了对象的性质，并且为其添加了属性和方法，丰富了基本类型的操作。</p>
<h2 id="自动装箱和拆箱"><a href="#自动装箱和拆箱" class="headerlink" title="自动装箱和拆箱"></a>自动装箱和拆箱</h2><p>装箱：将基础类型转化为包装类型。</p>
<p>拆箱：将包装类型转化为基础类型。</p>
<p>当基础类型与它们的包装类有如下几种情况时，编译器会<strong>自动</strong>帮我们进行装箱或拆箱：</p>
<ul>
<li>赋值操作（装箱或拆箱）</li>
<li>进行加减乘除混合运算 （拆箱）</li>
<li>进行&gt;,&lt;,&#x3D;&#x3D;比较运算（拆箱）</li>
<li>调用equals进行比较（装箱）</li>
<li>ArrayList、HashMap等集合类添加基础类型数据时（装箱）</li>
</ul>
<p>比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// 装箱 调⽤ Integer.valueOf(1)</span></span><br><span class="line"><span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> x; <span class="comment">// 拆箱 调⽤了 X.intValue()</span></span><br></pre></td></tr></table></figure>

<p>面试题：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">System.out.println(a == b);</span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line">System.out.println(c == d);</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">true</span><br><span class="line">false</span><br></pre></td></tr></table></figure>



<p>查看源码可以得知：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Integer c = 200;</code> 会调用<code>Integer.valueOf(200)</code>。</p>
<p>而从Integer的valueOf()源码可以看到，这里的实现并不是简单的new Integer，而是用IntegerCache做一个cache。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">IntegerCache</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> -<span class="number">128</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> high;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// high value may be configured by property</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">integerCacheHighPropValue</span> <span class="operator">=</span></span><br><span class="line">            sun.misc.VM.getSavedProperty(<span class="string">&quot;java.lang.Integer.IntegerCache.high&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (integerCacheHighPropValue != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> parseInt(integerCacheHighPropValue);</span><br><span class="line">                i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">                <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">                h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">                <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        high = h;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是IntegerCache静态代码块中的一段，<strong>默认Integer cache 的下限是-128，上限默认127。</strong>当赋值100给Integer时，刚好在这个范围内，所以从cache中取对应的Integer并返回，所以a和b返回的是同一个对象，所以<code>==</code>比较是相等的，当赋值200给Integer时，不在cache 的范围内，所以会new Integer并返回，当然<code>==</code>比较的结果是不相等的。</p>
<h2 id="什么是不可变对象？"><a href="#什么是不可变对象？" class="headerlink" title="什么是不可变对象？"></a>什么是不可变对象？</h2><p>如果一个对象，在它<strong>创建完成之后</strong>，<strong>不能再改变它的状态</strong>，那么这个对象就是不可变的。</p>
<p>不能改变状态的意思是，不能改变对象内的<strong>成员变量</strong>，包括<strong>基本数据类型的值不能改变</strong>，<strong>引用类型的变量不能指向其他的对象</strong>，<strong>引用类型指向的对象的状态也不能改变</strong>。</p>
<h2 id="String类为什么不可变？"><a href="#String类为什么不可变？" class="headerlink" title="String类为什么不可变？"></a>String类为什么不可变？</h2><p>先看Java8内，String类的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Cache the hash code for the string */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> hash; <span class="comment">// Default to 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从源码可以看出，String对象其实在内部就是一个个字符，存储在这个value数组里面的。</p>
<p>value数组用final修饰，final 修饰的变量，值不能被修改。因此value不可以指向其他对象。</p>
<p>String类内部所有的字段都是私有的，也就是被private修饰。而且String没有对外提供修改内部状态的方法，因此value数组不能改变。</p>
<p>所以，String是不可变的。</p>
<p>而为什么不能改变主要有以下原因：</p>
<ol>
<li><strong>线程安全</strong>。同一个字符串实例可以被多个线程共享，因为字符串不可变，本身就是线程安全的。</li>
<li><strong>支持hash映射和缓存</strong>。因为String的hash值经常会使用到，比如作为 Map 的键，不可变的特性使得 hash 值也不会变，不需要重新计算。</li>
<li><strong>出于安全考虑</strong>。网络地址URL、文件路径path、密码通常情况下都是以String类型保存，假若String不是固定不变的，将会引起各种安全隐患。比如将密码用String的类型保存，那么它将一直留在内存中，直到垃圾收集器把它清除。假如String类不是固定不变的，那么这个密码可能会被改变，导致出现安全隐患。</li>
<li><strong>字符串常量池优化</strong>。String对象创建之后，会缓存到字符串常量池中，下次需要创建同样的对象时，可以直接返回缓存的引用。</li>
</ol>
<p>既然我们的String是不可变的，它内部还有很多substring， replace， replaceAll这些操作的方法。这些方法好像会改变String对象？怎么解释呢？</p>
<p>其实不是的，我们每次调用replace等方法，其实会在堆内存中<strong>创建了一个新的对象</strong>。然后<strong>其value数组引用指向不同的对象</strong>。</p>
<h2 id="为何JDK9要将String的底层实现由char-改成byte"><a href="#为何JDK9要将String的底层实现由char-改成byte" class="headerlink" title="为何JDK9要将String的底层实现由char[]改成byte[]?"></a>为何JDK9要将String的底层实现由char[]改成byte[]?</h2><p>主要是为了<strong>节约String占用的内存</strong>。</p>
<p>在大部分Java程序的堆内存中，<strong>String占用的空间最大</strong>，并且<strong>绝大多数String只有Latin-1字符</strong>，这些<strong>Latin-1字符只需要1个字节</strong>就够了。</p>
<p>而在JDK9之前，JVM因为String使用char数组存储，<strong>每个char占2个字节</strong>，所以<strong>即使字符串只需要1字节，它也要按照2字节进行分配</strong>，浪费了一半的内存空间。</p>
<p>到了JDK9之后，<strong>对于每个字符串，会先判断它是不是只有Latin-1字符</strong>，<strong>如果是，就按照1字节的规格进行分配内存</strong>，<strong>如果不是，就按照2字节的规格进行分配</strong>，这样便提高了内存使用率，同时GC次数也会减少，提升效率。</p>
<p>不过Latin-1编码集支持的字符有限，比如不支持中文字符，因此<strong>对于中文字符串，用的是UTF16编码（两个字节）</strong>，所以用byte[]和char[]实现没什么区别。</p>
<h2 id="String-StringBuffer-和-StringBuilder区别"><a href="#String-StringBuffer-和-StringBuilder区别" class="headerlink" title="String, StringBuffer 和 StringBuilder区别"></a>String, StringBuffer 和 StringBuilder区别</h2><p><strong>1. 可变性</strong></p>
<ul>
<li>String 不可变</li>
<li>StringBuffer 和 StringBuilder 可变</li>
</ul>
<p><strong>2. 线程安全</strong></p>
<ul>
<li>String 不可变，因此是线程安全的</li>
<li>StringBuilder 不是线程安全的</li>
<li>StringBuffer 是线程安全的，内部使用 synchronized 进行同步</li>
</ul>
<h2 id="什么是StringJoiner？"><a href="#什么是StringJoiner？" class="headerlink" title="什么是StringJoiner？"></a>什么是StringJoiner？</h2><p>StringJoiner是 Java 8 新增的一个 API，它基于 StringBuilder 实现，用于实现对字符串之间通过分隔符拼接的场景。</p>
<p>StringJoiner 有两个构造方法，第一个构造要求依次传入分隔符、前缀和后缀。第二个构造则只要求传入分隔符即可（前缀和后缀默认为空字符串）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringJoiner(CharSequence delimiter, CharSequence prefix, CharSequence suffix)</span><br><span class="line">StringJoiner(CharSequence delimiter)</span><br></pre></td></tr></table></figure>

<p>有些字符串拼接场景，使用 StringBuffer 或 StringBuilder 则显得比较繁琐。</p>
<p>比如下面的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; values = Arrays.asList(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;(&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; values.size(); i++) &#123;</span><br><span class="line">	sb.append(values.get(i));</span><br><span class="line">	<span class="keyword">if</span> (i != values.size() -<span class="number">1</span>) &#123;</span><br><span class="line">		sb.append(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sb.append(<span class="string">&quot;)&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>而通过StringJoiner来实现拼接List的各个元素，代码看起来更加简洁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; values = Arrays.asList(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line"><span class="type">StringJoiner</span> <span class="variable">sj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringJoiner</span>(<span class="string">&quot;,&quot;</span>, <span class="string">&quot;(&quot;</span>, <span class="string">&quot;)&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Integer value : values) &#123;</span><br><span class="line">	sj.add(value.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，像平时经常使用的Collectors.joining(“,”)，底层就是通过StringJoiner实现的。</p>
<p>源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Collector&lt;CharSequence, ?, String&gt; joining(</span><br><span class="line">    CharSequence delimiter,CharSequence prefix,CharSequence suffix) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CollectorImpl</span>&lt;&gt;(</span><br><span class="line">            () -&gt; <span class="keyword">new</span> <span class="title class_">StringJoiner</span>(delimiter, prefix, suffix),</span><br><span class="line">            StringJoiner::add, StringJoiner::merge,</span><br><span class="line">            StringJoiner::toString, CH_NOID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="String类的常用方法有哪些"><a href="#String类的常用方法有哪些" class="headerlink" title="String类的常用方法有哪些"></a>String类的常用方法有哪些</h2><ul>
<li>indexOf()：返回指定字符的索引。</li>
<li>charAt()：返回指定索引处的字符。</li>
<li>replace()：字符串替换。</li>
<li>trim()：去除字符串两端空白。</li>
<li>split()：分割字符串，返回一个分割后的字符串数组。</li>
<li>getBytes()：返回字符串的 byte 类型数组。</li>
<li>length()：返回字符串长度。</li>
<li>toLowerCase()：将字符串转成小写字母。</li>
<li>toUpperCase()：将字符串转成大写字符。</li>
<li>substring()：截取字符串。</li>
<li>equals()：字符串比较。</li>
</ul>
<h2 id="为什么不能用浮点型表示金额？建议使用什么类型"><a href="#为什么不能用浮点型表示金额？建议使用什么类型" class="headerlink" title="为什么不能用浮点型表示金额？建议使用什么类型"></a>为什么不能用浮点型表示金额？建议使用什么类型</h2><p>由于计算机中保存的小数其实是十进制的小数的近似值，并不是准确值，所以，千万不要在代码中使用浮点数来表示金额等重要的指标。</p>
<p>建议使用BigDecimal或者Long来表示金额。</p>
<h2 id="什么是值传递和引用传递"><a href="#什么是值传递和引用传递" class="headerlink" title="什么是值传递和引用传递"></a>什么是值传递和引用传递</h2><ul>
<li>值传递是对基本型变量而言的，传递的是该变量的一个副本，改变副本不影响原变量。</li>
<li>引用传递一般是对于对象型变量而言的，传递的是该对象地址的一个副本，并不是原对象本身，两者指向同一片内存空间。所以对引用对象进行操作会同时改变原对象。</li>
</ul>
<h2 id="new-String-“MySQL”-会创建几个对象？"><a href="#new-String-“MySQL”-会创建几个对象？" class="headerlink" title="new String(“MySQL”)会创建几个对象？"></a>new String(“MySQL”)会创建几个对象？</h2><p>使用这种方式会创建两个字符串对象（前提是字符串常量池中没有 “MySQL” 这个字符串对象）。</p>
<ul>
<li>“MySQL” 属于字符串字面量，因此编译时期会在字符串常量池中创建一个字符串对象，指向这个 “MySQL” 字符串字面量；</li>
<li>使用 new 的方式会在堆中创建一个字符串对象。</li>
</ul>
<h2 id="什么是字符串常量池？"><a href="#什么是字符串常量池？" class="headerlink" title="什么是字符串常量池？"></a>什么是字符串常量池？</h2><p>字符串常量池（String Pool）保存着所有字符串字面量，这些字面量在编译时期就确定。</p>
<p>字符串常量池位于堆内存中，专门用来存储字符串常量。在创建字符串时，JVM首先会检查字符串常量池，如果该字符串已经存在池中，则返回其引用，如果不存在，则创建此字符串并放入池中，并返回其引用。</p>
<h2 id="String最大长度是多少？"><a href="#String最大长度是多少？" class="headerlink" title="String最大长度是多少？"></a>String最大长度是多少？</h2><p>String类提供了一个length方法，返回值为int类型，而int的取值上限为2^31 -1。</p>
<p>所以理论上String的最大长度为2^31 -1。</p>
<p><strong>达到这个长度的话需要多大的内存吗</strong>？</p>
<p>String内部是使用一个char数组来维护字符序列的，一个char占用两个字节。如果说String最大长度是2^31 -1的话，那么最大的字符串占用内存空间约等于4GB。</p>
<p>也就是说，我们需要有大于4GB的JVM运行内存才行。</p>
<p><strong>那String一般都存储在JVM的哪块区域呢</strong>？</p>
<p>字符串在JVM中的存储分两种情况，一种是String对象，存储在JVM的堆栈中。一种是字符串常量，存储在常量池里面。</p>
<p><strong>什么情况下字符串会存储在常量池呢</strong>？</p>
<p>当通过字面量进行字符串声明时，比如String s &#x3D; “我喜欢MySQL”;，这个字符串在编译之后会以常量的形式进入到常量池。</p>
<p><strong>那常量池中的字符串最大长度是2^31-1吗</strong>？</p>
<p>不是的，常量池对String的长度是有另外限制的。。Java中的UTF-8编码的Unicode字符串在常量池中以CONSTANT_Utf8类型表示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CONSTANT_Utf8_info &#123;</span><br><span class="line">    u1 tag;</span><br><span class="line">    u2 length;</span><br><span class="line">    u1 bytes[length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>length在这里就是代表字符串的长度，length的类型是u2，u2是无符号的16位整数，也就是说最大长度可以做到2^16-1 即 65535。</p>
<p>不过javac编译器做了限制，需要length &lt; 65535。所以字符串常量在常量池中的最大长度是65535 - 1 &#x3D; 65534。</p>
<p>最后总结一下：</p>
<p><strong>String在不同的状态下，具有不同的长度限制。</strong></p>
<ul>
<li><strong>字符串常量长度不能超过65534</strong></li>
<li><strong>堆内字符串的长度不超过2^31-1</strong></li>
</ul>
<h2 id="1MB等于多少，1MiB等于多少，两者的区别"><a href="#1MB等于多少，1MiB等于多少，两者的区别" class="headerlink" title="1MB等于多少，1MiB等于多少，两者的区别"></a>1MB等于多少，1MiB等于多少，两者的区别</h2><p>$$<br>1MB &#x3D; 10^3KB &#x3D; 10^6Byte &#x3D; 1,000,000Byte<br>$$</p>
<p>$$<br>1MiB &#x3D; 2^{10} KiB &#x3D; 2^{20} Byte &#x3D; 1,048,576Byte<br>$$</p>
<p>MB：也叫兆字节，单位以<strong>10为底数的指数</strong>。</p>
<p>MiB：单位以<strong>2为底数的指数</strong>。</p>
<h2 id="Object常用方法有哪些？"><a href="#Object常用方法有哪些？" class="headerlink" title="Object常用方法有哪些？"></a>Object常用方法有哪些？</h2><p>Object常用方法有：<code>toString()</code>、<code>equals()</code>、<code>hashCode()</code>、<code>clone()</code>等。</p>
<p><strong>toString</strong></p>
<p>默认输出对象地址。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(<span class="type">int</span> age, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">18</span>, <span class="string">&quot;Tim Brown&quot;</span>).toString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//output</span></span><br><span class="line">    <span class="comment">//me.tyson.java.core.Person@4554617c</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以重写toString方法，按照重写逻辑输出对象值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(<span class="type">int</span> age, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name + <span class="string">&quot;:&quot;</span> + age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">18</span>, <span class="string">&quot;Tim Brown&quot;</span>).toString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//output</span></span><br><span class="line">    <span class="comment">//Tim Brown:18</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>equals</strong></p>
<p>默认比较两个引用变量是否指向同一个对象（内存地址）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(<span class="type">int</span> age, String name)</span> &#123;</span><br><span class="line">       <span class="built_in">this</span>.age = age;</span><br><span class="line">       <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;Tim Brown&quot;</span>;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">18</span>, name);</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">18</span>, name);</span><br><span class="line"></span><br><span class="line">        System.out.println(p1.equals(p2));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//output</span></span><br><span class="line">    <span class="comment">//false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以重写equals方法，按照age和name是否相等来判断：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(<span class="type">int</span> age, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Person) &#123;</span><br><span class="line">            <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> (Person) o;</span><br><span class="line">            <span class="keyword">return</span> age == p.age &amp;&amp; name.equals(p.name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;Tim Brown&quot;</span>;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">18</span>, name);</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">18</span>, name);</span><br><span class="line"></span><br><span class="line">        System.out.println(p1.equals(p2));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//output</span></span><br><span class="line">    <span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>hashCode</strong></p>
<p>将与对象相关的信息映射成一个哈希值，默认的实现hashCode值是根据内存地址换算出来。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">Cat</span>().hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//out</span></span><br><span class="line">    <span class="comment">//1349277854</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>clone</strong></p>
<p>Java赋值是复制对象引用，如果我们想要得到一个对象的副本，使用赋值操作是无法达到目的的。Object对象有个clone()方法，实现了对</p>
<p>象中各个属性的复制，但它的可见范围是protected的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException;</span><br></pre></td></tr></table></figure>

<p>所以实体类使用克隆的前提是：</p>
<ul>
<li>实现Cloneable接口，这是一个标记接口，自身没有方法，这应该是一种约定。调用clone方法时，会判断有没有实现Cloneable接口，没有实现Cloneable的话会抛异常CloneNotSupportedException。</li>
<li>覆盖clone()方法，可见性提升为public。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="type">Cat</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        c.name = <span class="string">&quot;Tim Brown&quot;</span>;</span><br><span class="line">        <span class="type">Cat</span> <span class="variable">cloneCat</span> <span class="operator">=</span> (Cat) c.clone();</span><br><span class="line">        c.name = <span class="string">&quot;Brown&quot;</span>;</span><br><span class="line">        System.out.println(cloneCat.name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//output</span></span><br><span class="line">    <span class="comment">//Tim Brown</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>getClass</strong></p>
<p>返回此 Object 的运行时类，常用于java反射机制。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tim Brown&quot;</span>);</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clz</span> <span class="operator">=</span> p.getClass();</span><br><span class="line">        System.out.println(clz);</span><br><span class="line">        <span class="comment">//获取类名</span></span><br><span class="line">        System.out.println(clz.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * class com.tyson.basic.Person</span></span><br><span class="line"><span class="comment">     * com.tyson.basic.Person</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>wait</strong></p>
<p>当前线程调用对象的wait()方法之后，当前线程会释放对象锁，进入等待状态。等待其他线程调用此对象的notify()&#x2F;notifyAll()唤醒或者等待超时时间wait(long timeout)自动唤醒。线程需要获取obj对象锁之后才能调用 obj.wait()。</p>
<p><strong>notify</strong></p>
<p>obj.notify()唤醒在此对象上等待的单个线程，选择是任意性的。notifyAll()唤醒在此对象上等待的所有线程。</p>
<h2 id="讲讲深拷贝和浅拷贝？"><a href="#讲讲深拷贝和浅拷贝？" class="headerlink" title="讲讲深拷贝和浅拷贝？"></a>讲讲深拷贝和浅拷贝？</h2><p><strong>浅拷贝</strong>：拷⻉对象和原始对象的引⽤类型引用同⼀个对象。</p>
<p>以下例子，Cat对象里面有个Person对象，调用clone之后，克隆对象和原对象的Person引用的是同一个对象，这就是浅拷贝。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Person owner;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="type">Cat</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">18</span>, <span class="string">&quot;Tim Brown&quot;</span>);</span><br><span class="line">        c.owner = p;</span><br><span class="line"></span><br><span class="line">        <span class="type">Cat</span> <span class="variable">cloneCat</span> <span class="operator">=</span> (Cat) c.clone();</span><br><span class="line">        p.setName(<span class="string">&quot;Brown&quot;</span>);</span><br><span class="line">        System.out.println(cloneCat.owner.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//output</span></span><br><span class="line">    <span class="comment">//Brown</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>深拷贝</strong>：拷贝对象和原始对象的引用类型引用不同的对象。</p>
<p>以下例子，在clone函数中不仅调用了super.clone，而且调用Person对象的clone方法（Person也要实现Cloneable接口并重写clone方法），从而实现了深拷贝。可以看到，拷贝对象的值不会受到原对象的影响。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Person owner;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="type">Cat</span> <span class="variable">c</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        c = (Cat) <span class="built_in">super</span>.clone();</span><br><span class="line">        c.owner = (Person) owner.clone();<span class="comment">//拷贝Person对象</span></span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="type">Cat</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">18</span>, <span class="string">&quot;Tim Brown&quot;</span>);</span><br><span class="line">        c.owner = p;</span><br><span class="line"></span><br><span class="line">        <span class="type">Cat</span> <span class="variable">cloneCat</span> <span class="operator">=</span> (Cat) c.clone();</span><br><span class="line">        p.setName(<span class="string">&quot;Brown&quot;</span>);</span><br><span class="line">        System.out.println(cloneCat.owner.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//output</span></span><br><span class="line">    <span class="comment">//Tim Brown</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="两个对象的hashCode-相同，则-equals-是否也一定为-true？"><a href="#两个对象的hashCode-相同，则-equals-是否也一定为-true？" class="headerlink" title="两个对象的hashCode()相同，则 equals()是否也一定为 true？"></a>两个对象的hashCode()相同，则 equals()是否也一定为 true？</h2><p>equals与hashcode的关系：</p>
<ol>
<li>如果两个对象调用equals比较返回true，那么它们的hashCode值一定要相同；</li>
<li>如果两个对象的hashCode相同，它们并不一定相同。</li>
</ol>
<p>hashcode方法主要是用来<strong>提升对象比较的效率</strong>，先进行hashcode()的比较，如果不相同，那就不必在进行equals的比较，这样就大大减少了equals比较的次数，当比较对象的数量很大的时候能提升效率。</p>
<h2 id="为什么重写-equals-时一定要重写-hashCode？"><a href="#为什么重写-equals-时一定要重写-hashCode？" class="headerlink" title="为什么重写 equals 时一定要重写 hashCode？"></a>为什么重写 equals 时一定要重写 hashCode？</h2><p>之所以重写<code>equals()</code>要重写<code>hashcode()</code>，是为了保证<code>equals()</code>方法返回true的情况下hashcode值也要一致，如果重写了<code>equals()</code>没有重写<code>hashcode()</code>，就会<strong>出现两个对象相等但<code>hashcode()</code>不相等的情况</strong>。这样，当用其中的一个对象作为键保存到hashMap、hashTable或hashSet中，再以另一个对象作为键值去查找他们的时候，则会查找不到。</p>
<h2 id="Java创建对象有几种方式？"><a href="#Java创建对象有几种方式？" class="headerlink" title="Java创建对象有几种方式？"></a>Java创建对象有几种方式？</h2><p>Java创建对象有以下几种方式：</p>
<ul>
<li>用new语句创建对象。</li>
<li>使用反射，使用Class.newInstance()创建对象。</li>
<li>调用对象的clone()方法。</li>
<li>运用反序列化手段，调用java.io.ObjectInputStream对象的readObject()方法。</li>
</ul>
<h2 id="说说类实例化的顺序"><a href="#说说类实例化的顺序" class="headerlink" title="说说类实例化的顺序"></a>说说类实例化的顺序</h2><p>Java中类实例化顺序：</p>
<ol>
<li>静态属性，静态代码块。</li>
<li>普通属性，普通代码块。</li>
<li>构造方法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LifeCycle</span> &#123;</span><br><span class="line">    <span class="comment">// 静态属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">staticField</span> <span class="operator">=</span> getStaticField();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态代码块</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(staticField);</span><br><span class="line">        System.out.println(<span class="string">&quot;静态代码块初始化&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 普通属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">field</span> <span class="operator">=</span> getField();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 普通代码块</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(field);</span><br><span class="line">        System.out.println(<span class="string">&quot;普通代码块初始化&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LifeCycle</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;构造方法初始化&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getStaticField</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">statiFiled</span> <span class="operator">=</span> <span class="string">&quot;静态属性初始化&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> statiFiled;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 普通方法</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getField</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">filed</span> <span class="operator">=</span> <span class="string">&quot;普通属性初始化&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> filed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argc)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">LifeCycle</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *      静态属性初始化</span></span><br><span class="line"><span class="comment">     *      静态代码块初始化</span></span><br><span class="line"><span class="comment">     *      普通属性初始化</span></span><br><span class="line"><span class="comment">     *      普通代码块初始化</span></span><br><span class="line"><span class="comment">     *      构造方法初始化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="equals和-有什么区别？"><a href="#equals和-有什么区别？" class="headerlink" title="equals和&#x3D;&#x3D;有什么区别？"></a>equals和&#x3D;&#x3D;有什么区别？</h2><ul>
<li>对于基本数据类型，&#x3D;&#x3D;比较的是他们的值。基本数据类型没有equal方法；</li>
<li>对于复合数据类型，&#x3D;&#x3D;比较的是它们的存放地址(是否是同一个对象)。<code>equals()</code>默认比较地址值，重写的话按照重写逻辑去比较。</li>
</ul>
<h2 id="常见的关键字有哪些？"><a href="#常见的关键字有哪些？" class="headerlink" title="常见的关键字有哪些？"></a>常见的关键字有哪些？</h2><p><strong>static</strong></p>
<p>static可以用来修饰类的成员方法、类的成员变量。</p>
<p>static变量也称作<strong>静态变量</strong>，静态变量和非静态变量的区别是：静态变量被所有的对象所共享，在内存中只有一个副本，它当且仅当在类初次加载时会被初始化。而非静态变量是对象所拥有的，在创建对象的时候被初始化，存在多个副本，各个对象拥有的副本互不影响。</p>
<p>以下例子，age为非静态变量，则p1打印结果是：<code>Name:zhangsan, Age:10</code>；若age使用static修饰，则p1打印结果是：<code>Name:zhangsan, Age:12</code>，因为static变量在内存只有一个副本。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Name:&quot;</span> + name + <span class="string">&quot;, Age:&quot;</span> + age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        p1.name = <span class="string">&quot;zhangsan&quot;</span>;</span><br><span class="line">        p1.age = <span class="number">10</span>;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        p2.name = <span class="string">&quot;lisi&quot;</span>;</span><br><span class="line">        p2.age = <span class="number">12</span>;</span><br><span class="line">        System.out.println(p1);</span><br><span class="line">        System.out.println(p2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**Output</span></span><br><span class="line"><span class="comment">     * Name:zhangsan, Age:10</span></span><br><span class="line"><span class="comment">     * Name:lisi, Age:12</span></span><br><span class="line"><span class="comment">     */</span><span class="comment">//~</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>static方法一般称作<strong>静态方法</strong>。静态方法不依赖于任何对象就可以进行访问，通过类名即可调用静态方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Utils</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello world: &quot;</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Utils.print(<span class="string">&quot;程序员大彬&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>静态代码块</strong>只会在类加载的时候执行一次。以下例子，startDate和endDate在类加载的时候进行赋值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>  &#123;</span><br><span class="line">    <span class="keyword">private</span> Date birthDate;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Date startDate, endDate;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        startDate = Date.valueOf(<span class="string">&quot;2008&quot;</span>);</span><br><span class="line">        endDate = Date.valueOf(<span class="string">&quot;2021&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(Date birthDate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.birthDate = birthDate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>静态内部类</strong></p>
<p><strong>在静态方法里</strong>，使用⾮静态内部类依赖于外部类的实例，也就是说需要先创建外部类实例，才能用这个实例去创建非静态内部类。⽽静态内部类不需要。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OuterClass</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">InnerClass</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">StaticInnerClass</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 在静态方法里，不能直接使用OuterClass.this去创建InnerClass的实例</span></span><br><span class="line">        <span class="comment">// 需要先创建OuterClass的实例o，然后通过o创建InnerClass的实例</span></span><br><span class="line">        <span class="comment">// InnerClass innerClass = new InnerClass();</span></span><br><span class="line">        <span class="type">OuterClass</span> <span class="variable">outerClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OuterClass</span>();</span><br><span class="line">        <span class="type">InnerClass</span> <span class="variable">innerClass</span> <span class="operator">=</span> outerClass.<span class="keyword">new</span> <span class="title class_">InnerClass</span>();</span><br><span class="line">        <span class="type">StaticInnerClass</span> <span class="variable">staticInnerClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StaticInnerClass</span>();</span><br><span class="line"></span><br><span class="line">        outerClass.test();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">nonStaticMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">InnerClass</span> <span class="variable">innerClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InnerClass</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;nonStaticMethod...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>final</strong></p>
<ol>
<li><strong>基本数据</strong>类型用final修饰，则不能修改，是常量；<strong>对象引用</strong>用final修饰，则引用只能指向该对象，不能指向别的对象，但是对象本身可以修改。</li>
<li>final修饰的方法不能被子类重写</li>
<li>final修饰的类不能被继承。</li>
</ol>
<p><strong>this</strong></p>
<p><code>this.属性名称</code>指访问类中的成员变量，可以用来区分成员变量和局部变量。如下代码所示，<code>this.name</code>访问类Person当前实例的变量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: 程序员大彬</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span>: 2021-08-17 00:29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>this.方法名称</code>用来访问本类的方法。以下代码中，<code>this.born()</code>调用类 Person 的当前实例的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: 程序员大彬</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span>: 2021-08-17 00:29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.born();</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">born</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>super</strong></p>
<p>super 关键字用于在子类中访问父类的变量和方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;大彬&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类:&quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="built_in">super</span>.name);</span><br><span class="line">        <span class="built_in">super</span>.getName();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">        b.getName();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 大彬</span></span><br><span class="line"><span class="comment">     * 父类:大彬</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在子类B中，我们重写了父类的<code>getName()</code>方法，如果在重写的<code>getName()</code>方法中我们要调用父类的相同方法，必须要通过super关键字显式指出。</p>
<h2 id="final-finally-finalize-的区别"><a href="#final-finally-finalize-的区别" class="headerlink" title="final, finally, finalize 的区别"></a>final, finally, finalize 的区别</h2><ul>
<li>final 用于<strong>修饰属性、方法和类</strong>, 分别表示<strong>属性不能被重新赋值</strong>，<strong>方法不可被覆盖</strong>，<strong>类不可被继承</strong>。</li>
<li>finally 是<strong>异常处理语句结构的一部分</strong>，一般<strong>以<code>try-catch-finally</code>出现</strong>，**<code>finally</code>代码块表示总是被执行**。</li>
<li>finalize 是<strong>Object类的一个方法</strong>，该方法<strong>一般由垃圾回收器来调用</strong>，当我们<strong>调用<code>System.gc()</code>方法的时候</strong>，由<strong>垃圾回收器调用<code>finalize()</code>方法</strong>，回收垃圾，JVM<strong>并不保证此方法总被调用</strong>。</li>
</ul>
<h2 id="方法重载和重写的区别？"><a href="#方法重载和重写的区别？" class="headerlink" title="方法重载和重写的区别？"></a>方法重载和重写的区别？</h2><p><strong>同个类中的多个方法可以有相同的方法名称，但是有不同的参数列表，这就称为方法重载</strong>。参数列表又叫参数签名，包括参数的类型、参数的个数、参数的顺序，只要有一个不同就叫做参数列表不同。</p>
<p>重载是面向对象的一个基本特性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OverrideTest</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setPerson</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setPerson</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="comment">//set name</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setPerson</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="comment">//set name and age</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法的重写描述的是父类和子类之间的。当父类的功能无法满足子类的需求，可以在子类对方法进行重写</strong>。方法重写时， 方法名与形参列表必须一致。</p>
<p>如下代码，Person为父类，Student为子类，在Student中重写了dailyTask方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dailyTask</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;work eat sleep&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dailyTask</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;study eat sleep&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="接口与抽象类区别？"><a href="#接口与抽象类区别？" class="headerlink" title="接口与抽象类区别？"></a>接口与抽象类区别？</h2><p>1、<strong>语法层面</strong>上的区别</p>
<ul>
<li>抽象类可以有方法实现，而接口的方法中只能是抽象方法（Java 8 之后接口方法可以有默认实现）；</li>
<li>抽象类中的成员变量可以是各种类型的，接口中的成员变量只能是public static final类型；</li>
<li>接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法（Java 8之后接口可以有静态方法）；</li>
<li>一个类只能继承一个抽象类，而一个类却可以实现多个接口。</li>
</ul>
<p>2、<strong>设计层面</strong>上的区别</p>
<ul>
<li>抽象层次不同。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口只是对类行为进行抽象。继承抽象类是一种”是不是”的关系，而接口实现则是 “有没有”的关系。如果一个类继承了某个抽象类，则子类必定是抽象类的种类，而接口实现则是具备不具备的关系，比如鸟是否能飞。</li>
<li>继承抽象类的是具有相似特点的类，而实现接口的却可以不同的类。</li>
</ul>
<p>门和警报的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AlarmDoor</span> <span class="keyword">extends</span> <span class="title class_">Door</span> <span class="keyword">implements</span> <span class="title class_">Alarm</span> &#123;</span><br><span class="line">    <span class="comment">//code</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BMWCar</span> <span class="keyword">extends</span> <span class="title class_">Car</span> <span class="keyword">implements</span> <span class="title class_">Alarm</span> &#123;</span><br><span class="line">    <span class="comment">//code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="常见的Exception有哪些？"><a href="#常见的Exception有哪些？" class="headerlink" title="常见的Exception有哪些？"></a>常见的Exception有哪些？</h2><p>常见的RuntimeException：</p>
<ol>
<li><code>ClassCastException</code> &#x2F;&#x2F;类型转换异常</li>
<li><code>IndexOutOfBoundsException</code> &#x2F;&#x2F;数组越界异常</li>
<li><code>NullPointerException</code> &#x2F;&#x2F;空指针异常</li>
<li><code>ArrayStoreException</code> &#x2F;&#x2F;数组存储异常</li>
<li><code>NumberFormatException</code> &#x2F;&#x2F;数字格式化异常</li>
<li><code>ArithmeticException</code> &#x2F;&#x2F;数学运算异常</li>
</ol>
<p>checked Exception：</p>
<ol>
<li><code>NoSuchFieldException</code> &#x2F;&#x2F;反射异常，没有对应的字段</li>
<li><code>ClassNotFoundException</code> &#x2F;&#x2F;类没有找到异常</li>
<li><code>IllegalAccessException</code> &#x2F;&#x2F;安全权限异常，可能是反射时调用了private方法</li>
</ol>
<h2 id="Error和Exception的区别？"><a href="#Error和Exception的区别？" class="headerlink" title="Error和Exception的区别？"></a>Error和Exception的区别？</h2><p><strong>Error</strong>：JVM 无法解决的严重问题，如栈溢出<code>StackOverflowError</code>、内存溢出<code>OOM</code>等。程序无法处理的错误。</p>
<p><strong>Exception</strong>：其它因编程错误或偶然的外在因素导致的一般性问题。可以在代码中进行处理。如：空指针异常、数组下标越界等。</p>
<h2 id="运行时异常和非运行时异常（checked）的区别？"><a href="#运行时异常和非运行时异常（checked）的区别？" class="headerlink" title="运行时异常和非运行时异常（checked）的区别？"></a>运行时异常和非运行时异常（checked）的区别？</h2><p><code>unchecked exception</code>包括<code>RuntimeException</code>和<code>Error</code>类，其他所有异常称为检查（checked）异常。</p>
<ol>
<li><code>RuntimeException</code>由程序错误导致，应该修正程序避免这类异常发生。</li>
<li><code>checked Exception</code>由具体的环境（读取的文件不存在或文件为空或sql异常）导致的异常。必须进行处理，不然编译不通过，可以catch或者throws。</li>
</ol>
<h2 id="throw和throws的区别？"><a href="#throw和throws的区别？" class="headerlink" title="throw和throws的区别？"></a>throw和throws的区别？</h2><ul>
<li><strong>throw</strong>：用于抛出一个具体的异常对象。</li>
<li><strong>throws</strong>：用在方法签名中，用于声明该方法可能抛出的异常。子类方法抛出的异常范围更加小，或者根本不抛异常。</li>
</ul>
<h2 id="通过故事讲清楚NIO"><a href="#通过故事讲清楚NIO" class="headerlink" title="通过故事讲清楚NIO"></a>通过故事讲清楚NIO</h2><p>下面通过一个例子来讲解下。</p>
<p>假设某银行只有10个职员。该银行的业务流程分为以下4个步骤：</p>
<p>1） 顾客填申请表（5分钟）；</p>
<p>2） 职员审核（1分钟）；</p>
<p>3） 职员叫保安去金库取钱（3分钟）；</p>
<p>4） 职员打印票据，并将钱和票据返回给顾客（1分钟）。</p>
<p>下面我们看看银行不同的工作方式对其工作效率到底有何影响。</p>
<!-- more -->

<p>首先是BIO方式。</p>
<p>每来一个顾客，马上由一位职员来接待处理，并且这个职员需要负责以上4个完整流程。当超过10个顾客时，剩余的顾客需要排队等候。</p>
<p>一个职员处理一个顾客需要10分钟（5+1+3+1）时间。一个小时（60分钟）能处理6个顾客，一共10个职员，那就是只能处理60个顾客。</p>
<p>可以看到银行职员的工作状态并不饱和，比如在第1步，其实是处于等待中。</p>
<p>这种工作其实就是BIO，每次来一个请求（顾客），就分配到线程池中由一个线程（职员）处理，如果超出了线程池的最大上限（10个），就扔到队列等待 。</p>
<p>那么如何提高银行的吞吐量呢？</p>
<p>思路就是：<strong>分而治之</strong>，将任务拆分开来，由专门的人负责专门的任务。</p>
<p>具体来讲，银行专门指派一名职员A，A的工作就是每当有顾客到银行，他就递上表格让顾客填写。每当有顾客填好表后，A就将其随机指派给剩余的9名职员完成后续步骤。</p>
<p>这种方式下，假设顾客非常多，职员A的工作处于饱和中，他不断的将填好表的顾客带到柜台处理。</p>
<p>柜台一个职员5分钟能处理完一个顾客，一个小时9名职员能处理：9*（60&#x2F;5）&#x3D;108。</p>
<p>可见工作方式的转变能带来效率的极大提升。</p>
<p>这种工作方式其实就NIO的思路。</p>
<p>下图是非常经典的NIO说明图，<code>mainReactor</code>线程负责监听server socket，接收新连接，并将建立的socket分派给<code>subReactor</code></p>
<p><code>subReactor</code>可以是一个线程，也可以是线程池，负责多路分离已连接的socket，读写网络数据。这里的读写网络数据可类比顾客填表这一耗时动作，对具体的业务处理功能，其扔给worker线程池完成</p>
<p>可以看到典型NIO有三类线程，分别是<code>mainReactor</code>线程、<code>subReactor</code>线程、<code>work</code>线程。</p>
<p>不同的线程干专业的事情，最终每个线程都没空着，系统的吞吐量自然就上去了。</p>
<p><strong>那这个流程还有没有什么可以提高的地方呢？</strong></p>
<p>可以看到，在这个业务流程里边第3个步骤，职员叫保安去金库取钱（3分钟）。这3分钟柜台职员是在等待中度过的，可以把这3分钟利用起来。</p>
<p>还是分而治之的思路，指派1个职员B来专门负责第3步骤。</p>
<p>每当柜台员工完成第2步时，就通知职员B来负责与保安沟通取钱。这时候柜台员工可以继续处理下一个顾客。</p>
<p>当职员B拿到钱之后，通知顾客钱已经到柜台了，让顾客重新排队处理，当柜台职员再次服务该顾客时，发现该顾客前3步已经完成，直接执行第4步即可。</p>
<p>在当今web服务中，经常需要通过RPC或者Http等方式调用第三方服务，这里对应的就是第3步，如果这步耗时较长，通过异步方式将能极大降低资源使用率。</p>
<p>NIO+异步的方式能让少量的线程做大量的事情。这适用于很多应用场景，比如代理服务、api服务、长连接服务等等。这些应用如果用同步方式将耗费大量机器资源。</p>
<p>不过虽然NIO+异步能提高系统吞吐量，但其并不能让一个请求的等待时间下降，相反可能会增加等待时间。</p>
<p>最后，NIO基本思想总结起来就是：<strong>分而治之，将任务拆分开来，由专门的人负责专门的任务</strong></p>
<h2 id="BIO-NIO-AIO区别的区别？"><a href="#BIO-NIO-AIO区别的区别？" class="headerlink" title="BIO&#x2F;NIO&#x2F;AIO区别的区别？"></a>BIO&#x2F;NIO&#x2F;AIO区别的区别？</h2><p><strong>同步阻塞IO</strong> : 用户进程发起一个IO操作以后，必须等待IO操作的真正完成后，才能继续运行。</p>
<p><strong>同步非阻塞IO</strong>: 客户端与服务器通过Channel连接，采用多路复用器轮询注册的<code>Channel</code>。提高吞吐量和可靠性。用户进程发起一个IO操作以后，可做其它事情，但用户进程需要轮询IO操作是否完成，这样造成不必要的CPU资源浪费。</p>
<p><strong>异步非阻塞IO</strong>: 非阻塞异步通信模式，NIO的升级版，采用异步通道实现异步通信，其read和write方法均是异步方法。用户进程发起一个IO操作，然后立即返回，等IO操作真正的完成以后，应用程序会得到IO操作完成的通知。类似Future模式。</p>
<h2 id="守护线程是什么？"><a href="#守护线程是什么？" class="headerlink" title="守护线程是什么？"></a>守护线程是什么？</h2><ul>
<li>守护线程是运行在后台的一种特殊进程。</li>
<li>它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。</li>
<li>在 Java 中垃圾回收线程就是特殊的守护线程。</li>
</ul>
<h2 id="Java支持多继承吗？"><a href="#Java支持多继承吗？" class="headerlink" title="Java支持多继承吗？"></a>Java支持多继承吗？</h2><p>java中，<strong>类不支持</strong>多继承。<strong>接口才支持</strong>多继承。接口的作用是拓展对象功能。当一个子接口继承了多个父接口时，说明子接口拓展了多个功能。当一个类实现该接口时，就拓展了多个的功能。</p>
<p><strong>Java不支持多继承的原因：</strong></p>
<ul>
<li>出于安全性的考虑，如果子类继承的多个父类里面有相同的方法或者属性，子类将不知道具体要继承哪个。</li>
<li>Java提供了接口和内部类以达到实现多继承功能，弥补单继承的缺陷。</li>
</ul>
<h2 id="如何实现对象克隆？"><a href="#如何实现对象克隆？" class="headerlink" title="如何实现对象克隆？"></a>如何实现对象克隆？</h2><ul>
<li>实现<code>Cloneable</code>接口，重写 <code>clone()</code> 方法。这种方式是<strong>浅拷贝</strong>，即如果类中属性有自定义引用类型，只拷贝引用，不拷贝引用指向的对象。如果对象的属性的Class也实现 <code>Cloneable</code> 接口，那么在克隆对象时也会克隆属性，即深拷贝。</li>
<li>结合序列化，<strong>深拷贝</strong>。</li>
<li>通过<code>org.apache.commons</code>中的工具类<code>BeanUtils</code>和<code>PropertyUtils</code>进行对象复制。</li>
</ul>
<h2 id="同步和异步的区别？"><a href="#同步和异步的区别？" class="headerlink" title="同步和异步的区别？"></a>同步和异步的区别？</h2><p>同步：发出一个调用时，在没有得到结果之前，该调用就不返回。</p>
<p>异步：在调用发出后，被调用者返回结果之后会通知调用者，或通过回调函数处理这个调用。</p>
<h2 id="阻塞和非阻塞的区别？"><a href="#阻塞和非阻塞的区别？" class="headerlink" title="阻塞和非阻塞的区别？"></a>阻塞和非阻塞的区别？</h2><p>阻塞和非阻塞关注的是<strong>线程的状态</strong>。</p>
<p>阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会恢复运行。</p>
<p>非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。</p>
<blockquote>
<p>举个例子，理解下同步、阻塞、异步、非阻塞的区别：<br>同步就是烧开水，要自己来看开没开；异步就是水开了，然后水壶响了通知你水开了（回调通知）。阻塞是烧开水的过程中，你不能干其他事情，必须在旁边等着；非阻塞是烧开水的过程里可以干其他事情。</p>
</blockquote>
<h2 id="Java8的新特性有哪些？"><a href="#Java8的新特性有哪些？" class="headerlink" title="Java8的新特性有哪些？"></a>Java8的新特性有哪些？</h2><ul>
<li>Lambda 表达式：Lambda允许把函数作为一个方法的参数</li>
<li>Stream API ：新添加的Stream API（java.util.stream） 把真正的函数式编程风格引入到Java中</li>
<li>默认方法：默认方法就是一个在接口里面有了一个实现的方法。</li>
<li>Optional 类 ：Optional 类已经成为 Java 8 类库的一部分，用来解决空指针异常。</li>
<li>Date Time API ：加强对日期与时间的处理。</li>
</ul>
<h2 id="Java11的新特性"><a href="#Java11的新特性" class="headerlink" title="Java11的新特性"></a>Java11的新特性</h2><p>Java 11 是一个较大的 Java 版本，引入了许多新特性、改进和性能优化。以下是 Java 11 中的一些重要新特性：</p>
<ol>
<li><strong>局部变量类型推断的增强</strong>：Java 11 增强了局部变量类型推断，允许 <code>var</code> 关键字用于 Lambda 表达式的参数和在 try-with-resources 语句中。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;(); <span class="comment">// 类型推断用于变量声明</span></span><br><span class="line"><span class="type">var</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, String&gt;();</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>HTTP 客户端（标准化）</strong>：Java 11 引入了 <code>java.net.http</code> 包，提供了一个标准化的 HTTP 客户端 API，用于发起 HTTP 请求和处理响应。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.http.HttpClient;</span><br><span class="line"><span class="keyword">import</span> java.net.http.HttpRequest;</span><br><span class="line"><span class="keyword">import</span> java.net.http.HttpResponse;</span><br><span class="line"></span><br><span class="line"><span class="type">HttpClient</span> <span class="variable">client</span> <span class="operator">=</span> HttpClient.newHttpClient();</span><br><span class="line"><span class="type">HttpRequest</span> <span class="variable">request</span> <span class="operator">=</span> HttpRequest.newBuilder()</span><br><span class="line">    .uri(<span class="keyword">new</span> <span class="title class_">URI</span>(<span class="string">&quot;https://example.com&quot;</span>))</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">HttpResponse&lt;String&gt; response = client.send(request, HttpResponse.BodyHandlers.ofString());</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>新增 String 方法</strong>：Java 11 引入了一些新的 String 方法，包括 <code>isBlank()</code> 用于检查字符串是否为空白，<code>lines()</code> 用于将字符串拆分为行，以及 <code>strip()</code>, <code>stripLeading()</code>, 和 <code>stripTrailing()</code> 用于删除字符串的空白字符。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> <span class="string">&quot;   Hello, World!   &quot;</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">blank</span> <span class="operator">=</span> text.isBlank(); <span class="comment">// true</span></span><br><span class="line"><span class="type">String</span> <span class="variable">stripped</span> <span class="operator">=</span> text.strip(); <span class="comment">// &quot;Hello, World!&quot;</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p><strong>新的垃圾回收器（Epsilon GC）</strong>：Java 11 引入了一种新的实验性垃圾回收器，称为 Epsilon GC，它主要用于性能测试和负载生成，不执行任何实际的垃圾回收操作，有助于评估 JVM 的性能。</p>
</li>
<li><p><strong>ZGC（实验性）</strong>：Java 11 中引入了一种新的垃圾回收器，称为 Z Garbage Collector（ZGC），它旨在提供低停顿时间和高吞吐量的垃圾回收。</p>
</li>
<li><p><strong>低级内存 API（实验性）</strong>：Java 11 引入了低级内存 API，允许直接在 Java 中访问内存，这对于某些高性能应用程序非常有用。</p>
</li>
<li><p><strong>新的命令行工具</strong>：Java 11 引入了一些新的命令行工具，如 <code>jshell</code>（交互式 Java Shell）和 <code>jdeps</code>（用于分析类的依赖关系）。</p>
</li>
<li><p><strong>新的标志</strong>：Java 11 引入了一些新的 JVM 启动参数，如 <code>-XX:+UseEpsilonGC</code>（启用 Epsilon GC）、<code>-XX:+UseZGC</code>（启用 ZGC）等。</p>
</li>
<li><p><strong>其他改进</strong>：Java 11 还包括了性能优化、小的语言改进、新的标准库方法等。它也是一个长期支持（LTS）版本，提供长期维护和支持。</p>
</li>
</ol>
<h2 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h2><ul>
<li>序列化：把对象转换为字节序列的过程称为对象的序列化.</li>
<li>反序列化：把字节序列恢复为对象的过程称为对象的反序列化.</li>
</ul>
<h2 id="什么时候需要用到序列化和反序列化呢"><a href="#什么时候需要用到序列化和反序列化呢" class="headerlink" title="什么时候需要用到序列化和反序列化呢?"></a>什么时候需要用到序列化和反序列化呢?</h2><p>当我们只在本地 JVM 里运行下 Java 实例，这个时候是不需要什么序列化和反序列化的，但当我们需要将内存中的对象持久化到磁盘，数据库中时，当我们需要与浏览器进行交互时，当我们需要实现 RPC 时，这个时候就需要序列化和反序列化了.</p>
<p>前两个需要用到序列化和反序列化的场景，是不是让我们有一个很大的疑问? 我们在与浏览器交互时，还有将内存中的对象持久化到数据库中时，好像都没有去进行序列化和反序列化，因为我们都没有实现 Serializable 接口，但一直正常运行.</p>
<p>下面先给出结论:</p>
<p><strong>只要我们对内存中的对象进行持久化或网络传输，这个时候都需要序列化和反序列化.</strong></p>
<p>理由:</p>
<p>服务器与浏览器交互时真的没有用到 Serializable 接口吗? JSON 格式实际上就是将一个对象转化为字符串，所以服务器与浏览器交互时的数据格式其实是字符串，我们来看来 String 类型的源码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable，Comparable&lt;String&gt;，CharSequence &#123;</span><br><span class="line">    /\*\* The value is used <span class="keyword">for</span> character storage. \*/</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value\[\];</span><br><span class="line"></span><br><span class="line">    /\*\* Cache the hash code <span class="keyword">for</span> the string \*/</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> hash; <span class="comment">// Default to 0</span></span><br><span class="line"></span><br><span class="line">    /\*\* use serialVersionUID from JDK <span class="number">1.0</span><span class="number">.2</span> <span class="keyword">for</span> interoperability \*/</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">6849794470754667710L</span>;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>String 类型实现了 Serializable 接口，并显示指定 serialVersionUID 的值.</p>
<p>然后我们再来看对象持久化到数据库中时的情况，Mybatis 数据库映射文件里的 insert 代码:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;org.tyshawn.bean.User&quot;</span>&gt;</span></span><br><span class="line">    INSERT INTO t\_user(name，age) VALUES (#&#123;name&#125;，#&#123;age&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>实际上我们并不是将整个对象持久化到数据库中，而是将对象中的属性持久化到数据库中，而这些属性（如Date&#x2F;String）都实现了 Serializable 接口。</p>
<h2 id="实现序列化和反序列化为什么要实现-Serializable-接口"><a href="#实现序列化和反序列化为什么要实现-Serializable-接口" class="headerlink" title="实现序列化和反序列化为什么要实现 Serializable 接口?"></a>实现序列化和反序列化为什么要实现 Serializable 接口?</h2><p>在 Java 中实现了 Serializable 接口后， JVM 在类加载的时候就会发现我们实现了这个接口，然后在初始化实例对象的时候就会在底层帮我们实现序列化和反序列化。</p>
<p>如果被写对象类型不是String、数组、Enum，并且没有实现Serializable接口，那么在进行序列化的时候，将抛出NotSerializableException。源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// remaining cases</span></span><br><span class="line"><span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">    writeString((String) obj, unshared);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (cl.isArray()) &#123;</span><br><span class="line">    writeArray(obj, desc, unshared);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Enum) &#123;</span><br><span class="line">    writeEnum((Enum&lt;?&gt;) obj, desc, unshared);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Serializable) &#123;</span><br><span class="line">    writeOrdinaryObject(obj, desc, unshared);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NotSerializableException</span>(</span><br><span class="line">            cl.getName() + <span class="string">&quot;\n&quot;</span> + debugInfoStack.toString());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NotSerializableException</span>(cl.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="实现-Serializable-接口之后，为什么还要显示指定-serialVersionUID-的值"><a href="#实现-Serializable-接口之后，为什么还要显示指定-serialVersionUID-的值" class="headerlink" title="实现 Serializable 接口之后，为什么还要显示指定 serialVersionUID 的值?"></a>实现 Serializable 接口之后，为什么还要显示指定 serialVersionUID 的值?</h2><p>如果不显示指定 serialVersionUID，JVM 在序列化时会根据属性自动生成一个 serialVersionUID，然后与属性一起序列化，再进行持久化或网络传输. 在反序列化时，JVM 会再根据属性自动生成一个新版 serialVersionUID，然后将这个新版 serialVersionUID 与序列化时生成的旧版 serialVersionUID 进行比较，如果相同则反序列化成功，否则报错.</p>
<p>如果显示指定了 serialVersionUID，JVM 在序列化和反序列化时仍然都会生成一个 serialVersionUID，但值为我们显示指定的值，这样在反序列化时新旧版本的 serialVersionUID 就一致了.</p>
<p>如果我们的类写完后不再修改，那么不指定serialVersionUID，不会有问题，但这在实际开发中是不可能的，我们的类会不断迭代，一旦类被修改了，那旧对象反序列化就会报错。 所以在实际开发中，我们都会显示指定一个 serialVersionUID。</p>
<h2 id="static-属性为什么不会被序列化"><a href="#static-属性为什么不会被序列化" class="headerlink" title="static 属性为什么不会被序列化?"></a>static 属性为什么不会被序列化?</h2><p>因为序列化是针对对象而言的，而 static 属性优先于对象存在，随着类的加载而加载，所以不会被序列化.</p>
<p>看到这个结论，是不是有人会问，serialVersionUID 也被 static 修饰，为什么 serialVersionUID 会被序列化? 其实 serialVersionUID 属性并没有被序列化，JVM 在序列化对象时会自动生成一个 serialVersionUID，然后将我们显示指定的 serialVersionUID 属性值赋给自动生成的 serialVersionUID.</p>
<h2 id="transient关键字的作用？"><a href="#transient关键字的作用？" class="headerlink" title="transient关键字的作用？"></a>transient关键字的作用？</h2><p>Java语言的关键字，变量修饰符，如果用transient声明一个实例变量，当对象存储时，它的值不需要维持。</p>
<p>也就是说被transient修饰的成员变量，在序列化的时候其值会被忽略，在被反序列化后， transient 变量的值被设为初始值， 如 int 型的是 0，对象型的是 null。</p>
<h2 id="什么是反射？"><a href="#什么是反射？" class="headerlink" title="什么是反射？"></a>什么是反射？</h2><p>动态获取的信息以及动态调用对象的方法的功能称为Java语言的反射机制。</p>
<p>在运行状态中，对于任意一个类，能够知道这个类的所有属性和方法。对于任意一个对象，能够调用它的任意一个方法和属性。</p>
<h2 id="反射有哪些应用场景呢？"><a href="#反射有哪些应用场景呢？" class="headerlink" title="反射有哪些应用场景呢？"></a>反射有哪些应用场景呢？</h2><ol>
<li>JDBC连接数据库时使用<code>Class.forName()</code>通过反射加载数据库的驱动程序</li>
<li>Eclispe、IDEA等开发工具利用反射动态解析对象的类型与结构，动态提示对象的属性和方法</li>
<li>Web服务器中利用反射调用了Sevlet的<code>service</code>方法</li>
<li>JDK动态代理底层依赖反射实现</li>
</ol>
<h2 id="讲讲什么是泛型？"><a href="#讲讲什么是泛型？" class="headerlink" title="讲讲什么是泛型？"></a>讲讲什么是泛型？</h2><p>Java泛型是JDK 5中引⼊的⼀个新特性， 允许在定义类和接口的时候使⽤类型参数。声明的类型参数在使⽤时⽤具体的类型来替换。</p>
<p>泛型最⼤的好处是可以提⾼代码的复⽤性。以List接口为例，我们可以将String、 Integer等类型放⼊List中， 如不⽤泛型， 存放String类型要写⼀个List接口， 存放Integer要写另外⼀个List接口， 泛型可以很好的解决这个问题。</p>
<h2 id="如何停止一个正在运行的线程？"><a href="#如何停止一个正在运行的线程？" class="headerlink" title="如何停止一个正在运行的线程？"></a>如何停止一个正在运行的线程？</h2><p>有几种方式。</p>
<p>1、<strong>使用线程的stop方法</strong>。</p>
<p>使用stop()方法可以强制终止线程。不过stop是一个被废弃掉的方法，不推荐使用。</p>
<p>使用Stop方法，会一直向上传播ThreadDeath异常，从而使得目标线程解锁所有锁住的监视器，即释放掉所有的对象锁。使得之前被锁住的对象得不到同步的处理，因此可能会造成数据不一致的问题。</p>
<p>2、<strong>使用interrupt方法中断线程</strong>，该方法只是告诉线程要终止，但最终何时终止取决于计算机。调用interrupt方法仅仅是在当前线程中打了一个停止的标记，并不是真的停止线程。</p>
<p>接着调用 Thread.currentThread().isInterrupted()方法，可以用来判断当前线程是否被终止，通过这个判断我们可以做一些业务逻辑处理，通常如果isInterrupted返回true的话，会抛一个中断异常，然后通过try-catch捕获。</p>
<p>3、<strong>设置标志位</strong></p>
<p>设置标志位，当标识位为某个值时，使线程正常退出。设置标志位是用到了共享变量的方式，为了保证共享变量在内存中的可见性，可以使用volatile修饰它，这样的话，变量取值始终会从主存中获取最新值。</p>
<p>但是这种volatile标记共享变量的方式，在线程发生阻塞时是无法完成响应的。比如调用Thread.sleep() 方法之后，线程处于不可运行状态，即便是主线程修改了共享变量的值，该线程此时根本无法检查循环标志，所以也就无法实现线程中断。</p>
<p>因此，interrupt() 加上手动抛异常的方式是目前中断一个正在运行的线程<strong>最为正确</strong>的方式了。</p>
<h2 id="什么是跨域？"><a href="#什么是跨域？" class="headerlink" title="什么是跨域？"></a>什么是跨域？</h2><p>简单来讲，跨域是指从一个域名的网页去请求另一个域名的资源。由于有<strong>同源策略</strong>的关系，一般是不允许这么直接访问的。但是，很多场景经常会有跨域访问的需求，比如，在前后端分离的模式下，前后端的域名是不一致的，此时就会发生跨域问题。</p>
<p><strong>那什么是同源策略呢</strong>？</p>
<p>所谓同源是指”协议+域名+端口”三者相同，即便两个不同的域名指向同一个ip地址，也非同源。</p>
<p>同源策略限制以下几种行为：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">1. Cookie、LocalStorage 和 IndexDB 无法读取</span><br><span class="line">2. DOM 和 Js对象无法获得</span><br><span class="line">3. AJAX 请求不能发送</span><br></pre></td></tr></table></figure>

<p><strong>为什么要有同源策略</strong>？</p>
<p>举个例子，假如你刚刚在网银输入账号密码，查看了自己的余额，然后再去访问其他带颜色的网站，这个网站可以访问刚刚的网银站点，并且获取账号密码，那后果可想而知。因此，从安全的角度来讲，同源策略是有利于保护网站信息的。</p>
<h2 id="跨域问题怎么解决呢？"><a href="#跨域问题怎么解决呢？" class="headerlink" title="跨域问题怎么解决呢？"></a>跨域问题怎么解决呢？</h2><p>嗯，有以下几种方法：</p>
<p><strong>CORS</strong>，跨域资源共享</p>
<p>CORS（Cross-origin resource sharing），跨域资源共享。CORS 其实是浏览器制定的一个规范，浏览器会自动进行 CORS 通信，它的实现主要在服务端，通过一些 HTTP Header 来限制可以访问的域，例如页面 A 需要访问 B 服务器上的数据，如果 B 服务器 上声明了允许 A 的域名访问，那么从 A 到 B 的跨域请求就可以完成。</p>
<p><strong>@CrossOrigin注解</strong></p>
<p>如果项目使用的是Springboot，可以在Controller类上添加一个 @CrossOrigin(origins &#x3D;”*”) 注解就可以实现对当前controller 的跨域访问了，当然这个标签也可以加到方法上，或者直接加到入口类上对所有接口进行跨域处理。注意SpringMVC的版本要在4.2或以上版本才支持@CrossOrigin。</p>
<p><strong>nginx反向代理接口跨域</strong></p>
<p>nginx反向代理跨域原理如下： 首先同源策略是浏览器的安全策略，不是HTTP协议的一部分。服务器端调用HTTP接口只是使用HTTP协议，不会执行JS脚本，不需要同源策略，也就不存在跨越问题。</p>
<p>nginx反向代理接口跨域实现思路如下：通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// proxy服务器</span></span><br><span class="line">server &#123;</span><br><span class="line">    listen       <span class="number">81</span>;</span><br><span class="line">    server_name  www.<span class="property">domain1</span>.<span class="property">com</span>;</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass   <span class="attr">http</span>:<span class="comment">//www.domain2.com:8080;  #反向代理</span></span><br><span class="line">        proxy_cookie_domain www.<span class="property">domain2</span>.<span class="property">com</span> www.<span class="property">domain1</span>.<span class="property">com</span>; #修改cookie里域名</span><br><span class="line">        index  index.<span class="property">html</span> index.<span class="property">htm</span>;</span><br><span class="line">        </span><br><span class="line">        add_header <span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Allow</span>-<span class="title class_">Origin</span> <span class="attr">http</span>:<span class="comment">//www.domain1.com;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样我们的前端代理只要访问 http:<a href="www.domain1.com:81/">www.domain1.com:81/</a>*就可以了。</p>
<p><strong>通过jsonp跨域</strong></p>
<p>通常为了减轻web服务器的负载，我们把js、css，img等静态资源分离到另一台独立域名的服务器上，在html页面中再通过相应的标签从不同域名下加载静态资源，这是浏览器允许的操作，基于此原理，我们可以通过动态创建script，再请求一个带参网址实现跨域通信。</p>
<h2 id="设计接口要注意什么"><a href="#设计接口要注意什么" class="headerlink" title="设计接口要注意什么?"></a>设计接口要注意什么?</h2><ol>
<li><strong>接口参数校验</strong>。接口必须校验参数，比如入参是否允许为空，入参长度是否符合预期。</li>
<li>设计接口时，充分考虑接口的<strong>可扩展性</strong>。思考接口是否可以复用，怎样保持接口的可扩展性。</li>
<li><strong>串行调用考虑改并行调用</strong>。比如设计一个商城首页接口，需要查商品信息、营销信息、用户信息等等。如果是串行一个一个查，那耗时就比较大了。这种场景是可以改为并行调用的，降低接口耗时。</li>
<li>接口是否需要<strong>防重</strong>处理。涉及到数据库修改的，要考虑防重处理，可以使用数据库防重表，以唯一流水号作为唯一索引。</li>
<li><strong>日志打印全面</strong>，入参出参，接口耗时，记录好日志，方便甩锅。</li>
<li>修改旧接口时，注意<strong>兼容性设计</strong>。</li>
<li><strong>异常处理得当</strong>。使用finally关闭流资源、使用log打印而不是e.printStackTrace()、不要吞异常等等</li>
<li>是否需要考虑<strong>限流</strong>。限流为了保护系统，防止流量洪峰超过系统的承载能力。</li>
</ol>
<h2 id="过滤器和拦截器有什么区别？"><a href="#过滤器和拦截器有什么区别？" class="headerlink" title="过滤器和拦截器有什么区别？"></a>过滤器和拦截器有什么区别？</h2><p>1、<strong>实现原理不同</strong>。</p>
<p>过滤器和拦截器底层实现不同。过滤器是基于函数回调的，拦截器是基于Java的反射机制（动态代理）实现的。一般自定义的过滤器中都会实现一个doFilter()方法，这个方法有一个FilterChain参数，而实际上它是一个回调接口。</p>
<p>2、<strong>使用范围不同</strong>。</p>
<p>过滤器实现的是 javax.servlet.Filter 接口，而这个接口是在Servlet规范中定义的，也就是说过滤器Filter的使用要依赖于Tomcat等容器，导致它只能在web程序中使用。而拦截器是一个Spring组件，并由Spring容器管理，并不依赖Tomcat等容器，是可以单独使用的。拦截器不仅能应用在web程序中，也可以用于Application、Swing等程序中。</p>
<p>3、<strong>使用的场景不同</strong>。</p>
<p>因为拦截器更接近业务系统，所以拦截器主要用来实现项目中的业务判断的，比如：日志记录、权限判断等业务。而过滤器通常是用来实现通用功能过滤的，比如：敏感词过滤、响应数据压缩等功能。</p>
<p>4、<strong>触发时机不同</strong>。</p>
<p>过滤器Filter是在请求进入容器后，但在进入servlet之前进行预处理，请求结束是在servlet处理完以后。</p>
<p>拦截器 Interceptor 是在请求进入servlet后，在进入Controller之前进行预处理的，Controller 中渲染了对应的视图之后请求结束。</p>
<p>5、<strong>拦截的请求范围不同</strong>。</p>
<p>请求的执行顺序是：请求进入容器 -&gt; 进入过滤器 -&gt; 进入 Servlet -&gt; 进入拦截器 -&gt; 执行控制器。可以看到过滤器和拦截器的执行时机也是不同的，过滤器会先执行，然后才会执行拦截器，最后才会进入真正的要调用的方法。</p>
<h2 id="对接第三方接口要考虑什么？"><a href="#对接第三方接口要考虑什么？" class="headerlink" title="对接第三方接口要考虑什么？"></a>对接第三方接口要考虑什么？</h2><p>嗯，需要考虑以下几点：</p>
<ol>
<li>确认接口对接的<strong>网络协议</strong>，是https&#x2F;http或者自定义的私有协议等。</li>
<li>约定好<strong>数据传参、响应格式</strong>（如application&#x2F;json），弱类型对接强类型语言时要特别注意</li>
<li><strong>接口安全</strong>方面，要确定身份校验方式，使用token、证书校验等</li>
<li>确认是否需要接口调用失败后的<strong>重试</strong>机制，保证数据传输的最终一致性。</li>
<li><strong>日志记录要全面</strong>。接口出入参数，以及解析之后的参数值，都要用日志记录下来，方便定位问题（甩锅）。</li>
</ol>
<h2 id="后端接口性能优化有哪些方法？"><a href="#后端接口性能优化有哪些方法？" class="headerlink" title="后端接口性能优化有哪些方法？"></a>后端接口性能优化有哪些方法？</h2><p>有以下这些方法：</p>
<p>1、<strong>优化索引</strong>。给where条件的关键字段，或者<code>order by</code>后面的排序字段，加索引。</p>
<p>2、<strong>优化sql语句</strong>。比如避免使用select *、批量操作、避免深分页、提升group by的效率等</p>
<p>3、<strong>避免大事务</strong>。使用@Transactional注解这种声明式事务的方式提供事务功能，容易造成大事务，引发其他的问题。应该避免在事务中一次性处理太多数据，将一些跟事务无关的逻辑放到事务外面执行。</p>
<p>4、<strong>异步处理</strong>。剥离主逻辑和副逻辑，副逻辑可以异步执行，异步写库。比如用户购买的商品发货了，需要发短信通知，短信通知是副流程，可以异步执行，以免影响主流程的执行。</p>
<p>5、<strong>降低锁粒度</strong>。在并发场景下，多个线程同时修改数据，造成数据不一致的情况。这种情况下，一般会加锁解决。但如果锁加得不好，导致锁的粒度太粗，也会非常影响接口性能。</p>
<p>6、<strong>加缓存</strong>。如果表数据量非常大的话，直接从数据库查询数据，性能会非常差。可以使用Redis<code>和</code>memcached提升查询性能，从而提高接口性能。</p>
<p>7、<strong>分库分表</strong>。当系统发展到一定的阶段，用户并发量大，会有大量的数据库请求，需要占用大量的数据库连接，同时会带来磁盘IO的性能瓶颈问题。或者数据库表数据非常大，SQL查询即使走了索引，也很耗时。这时，可以通过分库分表解决。分库用于解决数据库连接资源不足问题，和磁盘IO的性能瓶颈问题。分表用于解决单表数据量太大，sql语句查询数据时，即使走了索引也非常耗时问题。</p>
<p>8、<strong>避免在循环中查询数据库</strong>。循环查询数据库，非常耗时，最好能在一次查询中获取所有需要的数据。</p>
<h2 id="为什么在阿里巴巴Java开发手册中强制要求使用包装类型定义属性呢？"><a href="#为什么在阿里巴巴Java开发手册中强制要求使用包装类型定义属性呢？" class="headerlink" title="为什么在阿里巴巴Java开发手册中强制要求使用包装类型定义属性呢？"></a>为什么在阿里巴巴Java开发手册中强制要求使用包装类型定义属性呢？</h2><p>嗯，以布尔字段为例，当我们没有设置对象的字段的值的时候，Boolean类型的变量会设置默认值为<code>null</code>，而boolean类型的变量会设置默认值为<code>false</code>。</p>
<p>也就是说，包装类型的默认值都是null，而基本数据类型的默认值是一个固定值，如boolean是false，byte、short、int、long是0，float是0.0f等。</p>
<p>举一个例子，比如有一个扣费系统，扣费时需要从外部的定价系统中读取一个费率的值，我们预期该接口的返回值中会包含一个浮点型的费率字段。当我们取到这个值得时候就使用公式：金额*费率&#x3D;费用 进行计算，计算结果进行划扣。</p>
<p>如果由于计费系统异常，他可能会返回个默认值，如果这个字段是Double类型的话，该默认值为null，如果该字段是double类型的话，该默认值为0.0。</p>
<p>如果扣费系统对于该费率返回值没做特殊处理的话，拿到null值进行计算会直接报错，阻断程序。拿到0.0可能就直接进行计算，得出接口为0后进行扣费了。这种异常情况就无法被感知。</p>
<p><strong>那我可以对0.0做特殊判断，如果是0就阻断报错，这样是否可以呢？</strong></p>
<p>不对，这时候就会产生一个问题，如果允许费率是0的场景又怎么处理呢？</p>
<p>使用基本数据类型只会让方案越来越复杂，坑越来越多。</p>
<p>这种使用包装类型定义变量的方式，通过异常来阻断程序，进而可以被识别到这种线上问题。如果使用基本数据类型的话，系统可能不会报错，进而认为无异常。</p>
<p>因此，建议在POJO和RPC的返回值中使用包装类型。</p>
<h2 id="8招让接口性能提升100倍"><a href="#8招让接口性能提升100倍" class="headerlink" title="8招让接口性能提升100倍"></a>8招让接口性能提升100倍</h2><p><strong>池化思想</strong></p>
<p>如果你每次需要用到线程，都去创建，就会有增加一定的耗时，而线程池可以重复利用线程，避免不必要的耗时。</p>
<p>比如<code>TCP</code>三次握手，它为了减少性能损耗，引入了<code>Keep-Alive长连接</code>，避免频繁的创建和销毁连接。</p>
<p><strong>拒绝阻塞等待</strong></p>
<p>如果你调用一个系统<code>B</code>的接口，但是它处理业务逻辑，耗时需要<code>10s</code>甚至更多。然后你是一直<strong>阻塞等待，直到系统B的下游接口返回</strong>，再继续你的下一步操作吗？这样<strong>显然不合理</strong>。</p>
<p>参考<strong>IO多路复用模型</strong>。即我们不用阻塞等待系统<code>B</code>的接口，而是先去做别的操作。等系统<code>B</code>的接口处理完，通过<strong>事件回调</strong>通知，我们接口收到通知再进行对应的业务操作即可。</p>
<p><strong>远程调用由串行改为并行</strong></p>
<p>比如设计一个商城首页接口，需要查商品信息、营销信息、用户信息等等。如果是串行一个一个查，那耗时就比较大了。这种场景是可以改为并行调用的，降低接口耗时。</p>
<p><strong>锁粒度避免过粗</strong></p>
<p>在高并发场景，为了防止<strong>超卖等情况</strong>，我们经常需要<strong>加锁来保护共享资源</strong>。但是，如果加锁的粒度过粗，是很影响接口性能的。</p>
<p>不管你是<code>synchronized</code>加锁还是<code>redis</code>分布式锁，只需要在共享临界资源加锁即可，不涉及共享资源的，就不必要加锁。</p>
<p><strong>耗时操作，考虑放到异步执行</strong></p>
<p>耗时操作，考虑用<strong>异步处理</strong>，这样可以降低接口耗时。比如用户注册成功后，短信邮件通知，是可以异步处理的。</p>
<p><strong>使用缓存</strong></p>
<p>把要查的数据，提前放好到缓存里面，需要时，<strong>直接查缓存，而避免去查数据库或者计算的过程</strong>。</p>
<p><strong>提前初始化到缓存</strong></p>
<p>预取思想很容易理解，就是<strong>提前把要计算查询的数据，初始化到缓存</strong>。如果你在未来某个时间需要用到某个经过复杂计算的数据，<strong>才实时去计算的话，可能耗时比较大</strong>。这时候，我们可以采取预取思想，<strong>提前把将来可能需要的数据计算好，放到缓存中</strong>，等需要的时候，去缓存取就行。这将大幅度提高接口性能。</p>
<p><strong>压缩传输内容</strong></p>
<p>压缩传输内容，传输报文变得更小，因此传输会更快。</p>
<h1 id="JavaAPI面试题"><a href="#JavaAPI面试题" class="headerlink" title="JavaAPI面试题"></a>JavaAPI面试题</h1><h2 id="自动装箱与拆箱"><a href="#自动装箱与拆箱" class="headerlink" title="自动装箱与拆箱"></a>自动装箱与拆箱</h2><p>装箱：<strong>将基本类型用它们对应的引用类型包装起来</strong>；原理：Integer.valueOf() 方法</p>
<p>拆箱：<strong>将包装类型转换为基本数据类型</strong>；原理：Integer.intValue() 方法</p>
<p>Java 为每个原始类型提供了包装类型：</p>
<p>原始类型: boolean，char，byte，short，int，long，float，double</p>
<p>包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double</p>
<h2 id="包装类型的常量池技术"><a href="#包装类型的常量池技术" class="headerlink" title="包装类型的常量池技术"></a>包装类型的常量池技术</h2><p>Java 基本类型的包装类的大部分都实现了常量池技术。</p>
<p>Byte,Short,Integer,Long 这 4 种包装类默认创建了数值 [-128，127] 的相应类型的缓存数据，Character 创建了数值在 [0,127] 范围的缓存数据，Boolean 直接返回 True or False。</p>
<h2 id="Integer-a-127-与-Integer-b-127相等吗"><a href="#Integer-a-127-与-Integer-b-127相等吗" class="headerlink" title="Integer a&#x3D; 127 与 Integer b &#x3D; 127相等吗"></a>Integer a&#x3D; 127 与 Integer b &#x3D; 127相等吗</h2><p>如果整型字面量的值在-128到127之间，那么自动装箱时不会new新的Integer对象，而是直接引用常量池中的Integer对象，超过范围 a1&#x3D;&#x3D;b1的结果是false</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">a1</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">System.out.println(a1 == b1); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">a2</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">b2</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">System.out.println(a2 == b2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>


<h2 id="String的创建机理是什么？什么是字符串常量池？"><a href="#String的创建机理是什么？什么是字符串常量池？" class="headerlink" title="String的创建机理是什么？什么是字符串常量池？"></a>String的创建机理是什么？什么是字符串常量池？</h2><ul>
<li>创建机理：由于String在Java世界中使用过于频繁，为了提高内存的使用率，避免开辟多块空间存储相同的字符串，引入了字符串常量池（字符串常量池位于堆内存中）</li>
<li>运行机制：在创建字符串时 JVM 会首先检查字符串常量池，如果该字符串已经存在池中，则返回它的引用，如果不存在，则实例化一个字符串放到池中，并返回其引用</li>
</ul>
<h2 id="String是最基本的数据类型吗"><a href="#String是最基本的数据类型吗" class="headerlink" title="String是最基本的数据类型吗"></a>String是最基本的数据类型吗</h2><p>不是。<strong>Java 中的基本数据类型只有 8 个</strong>，<strong>除了基本类型，剩下的都是引用类型</strong>基本数据</p>
<p>类型中用来描述文本数据的是 char，但是它只能表示单个字符，如果要描述一段文本，就需要使用 char 类型数组，但是使用数组过于麻烦，所以就有了 String，String 底层就是一个 char 类型的数组，只是使用的时候开发者不需要直接操作底层数组，使用更加简便</p>
<h2 id="String-s-new-String-“abc”-创建了几个字符串对象"><a href="#String-s-new-String-“abc”-创建了几个字符串对象" class="headerlink" title="String s &#x3D; new String(“abc”);创建了几个字符串对象"></a>String s &#x3D; new String(“abc”);创建了几个字符串对象</h2><p>当JVM遇到上述代码时，会<strong>先检索常量池中是否存在</strong>“abc”，<strong>如果不存在</strong>“abc”这个字符串，则会先<strong>在常量池中创建这个字符串</strong>。然后<strong>再执行new操作</strong>，在<strong>堆内存中创建一个String对象，对象的引用赋值给s</strong>。</p>
<p>所以此过程<strong>创建了2个对象</strong>。</p>
<p>当然，如果检索常量池时发现已经存在了对应的字符串，那么只会在堆内创建一个新的String对象，此过程只<strong>创建了1个对象</strong>。</p>
<h2 id="String为什么是不可变的吗？是否可以继承-String-类"><a href="#String为什么是不可变的吗？是否可以继承-String-类" class="headerlink" title="String为什么是不可变的吗？是否可以继承 String 类"></a>String为什么是不可变的吗？是否可以继承 String 类</h2><p><strong>final修饰的String类</strong>，代表了<strong>String类的不可被继承</strong>，<strong>final修饰的char[]<strong>代表了被</strong>存储的数据不可更改被创建，是无法修改的</strong>，即便你在后面拼接一些其他字符，也会把新生成的字符串存到另外一个地址但是，虽然final代表了不可变，但<strong>仅仅是引用地址不可变，并不代表了数组本身不会变。</strong></p>
<h2 id="在使用-HashMap-的时候，用-String-做-key-有什么好处？"><a href="#在使用-HashMap-的时候，用-String-做-key-有什么好处？" class="headerlink" title="在使用 HashMap 的时候，用 String 做 key 有什么好处？"></a>在使用 HashMap 的时候，用 String 做 key 有什么好处？</h2><p>因为字符串是<strong>不可变的</strong>，所以当创建字符串时，它的 <strong>hashcode 被缓存下来</strong>，<strong>不需要再次计算</strong>，所以相比于其他对象更快。</p>
<h2 id="String-str-”i”与-String-str-new-String-“i”-一样吗？"><a href="#String-str-”i”与-String-str-new-String-“i”-一样吗？" class="headerlink" title="String str&#x3D;”i”与 String str&#x3D;new String(“i”)一样吗？"></a>String str&#x3D;”i”与 String str&#x3D;new String(“i”)一样吗？</h2><p>不一样，因为内存的分配方式不一样。String str&#x3D;”i”的方式，java 虚拟机会将其分配到常量池中；而 String str&#x3D;new String(“i”) 则会被分到堆内存中。</p>
<h2 id="String-类的常用方法都有那些？"><a href="#String-类的常用方法都有那些？" class="headerlink" title="String 类的常用方法都有那些？"></a>String 类的常用方法都有那些？</h2><ol>
<li><strong>indexOf()：</strong>返回指定字符的索引。</li>
<li><strong>charAt()：</strong>返回指定索引处的字符。</li>
<li><strong>replace()：</strong>字符串替换。</li>
<li><strong>trim()：</strong>去除字符串两端空白。</li>
<li><strong>split()：</strong>分割字符串，返回一个分割后的字符串数组。</li>
<li><strong>getBytes()：</strong>返回字符串的 byte 类型数组。</li>
<li><strong>length()：</strong>返回字符串长度。</li>
<li><strong>toLowerCase()：</strong>将字符串转成小写字母。</li>
<li><strong>toUpperCase()：</strong>将字符串转成大写字符。</li>
<li><strong>substring()：</strong>截取字符串。</li>
<li><strong>equals()：</strong>字符串比较。</li>
</ol>
<h2 id="String和StringBuffer、StringBuilder的区别是什么？-new"><a href="#String和StringBuffer、StringBuilder的区别是什么？-new" class="headerlink" title="String和StringBuffer、StringBuilder的区别是什么？(new)"></a>String和StringBuffer、StringBuilder的区别是什么？(new)</h2><ul>
<li><strong>可变性：</strong></li>
</ul>
<p>String类中使用字符数组保存字符串，private　final　char　value[]，所以string对象是不可变的。StringBuilder与StringBuffer都继承自AbstractStringBuilder类，在AbstractStringBuilder中也是使用字符数组保存字符串，char[] value，这两种对象都是可变的。</p>
<ul>
<li><strong>线程安全性：</strong></li>
</ul>
<p><strong>String中的对象是不可变的</strong>，也就可以理解为常量，<strong>线程安全</strong>。</p>
<p><strong>StringBuffer对方法加了同步锁或者对调用的方法加了同步锁</strong>，所以是<strong>线程安全</strong>的</p>
<p><strong>StringBuilder并没有对方法进行加同步锁</strong>，所以是<strong>非线程安全</strong>的</p>
<ul>
<li><strong>性能：</strong></li>
</ul>
<p>每次对String 类型进行改变的时候，都会生成一个新的String对象，然后将指针指向新的String 对象</p>
<p>StringBuffer每次都会对StringBuffer对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用StirngBuilder 相比使用StringBuffer 仅能获得10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">StringBuilder &gt; StringBuffer &gt; String</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ol>
<li><p>在<strong>字符串内容不经常发生变化的业务场景</strong>，优先使用String类，例如<strong>常量声明</strong>、<strong>少量的字符串拼接操作</strong>等。</p>
</li>
<li><p>在<strong>单线程环境</strong>下，频繁地进行字符串的操作，建议使用StringBuilder，例如<strong>SQL语句拼装、JSON封装</strong>等</p>
</li>
<li><p>在<strong>多线程环境</strong>下，频繁地进行字符串的操作，建议使用StringBuffer，例如<strong>XML解析、HTTP参数解析与封装</strong></p>
</li>
</ol>
<h2 id="字符型常量和字符串常量的区别？"><a href="#字符型常量和字符串常量的区别？" class="headerlink" title="字符型常量和字符串常量的区别？"></a>字符型常量和字符串常量的区别？</h2><ul>
<li><p><strong>形式 :</strong> 字符常量是单引号引起的一个字符，字符串常量是双引号引起的 0 个或若干个字符</p>
</li>
<li><p><strong>含义 :</strong> 字符常量相当于一个整型值( ASCII 值),可以参加表达式运算; 字符串常量代表一个地址值(该字符串在内存中存放位置)</p>
</li>
<li><p><strong>占内存大小 ：</strong> 字符常量只占 2 个字节; 字符串常量占若干个字节 </p>
<p><strong>(注意： char 在 Java 中占两个字节)</strong></p>
</li>
</ul>
<h2 id="Java中IO流分为几种"><a href="#Java中IO流分为几种" class="headerlink" title="Java中IO流分为几种?"></a>Java中IO流分为几种?</h2><p>按功能来分：<br>    输入流（input）、输出流（output）。<br>按类型来分：<br>    字节流和字符流。</p>
<ul>
<li>字节流<ul>
<li>Intputstream类：输入字节流的基类(抽象类)<ul>
<li>FileIntputStream类：字节输入流</li>
<li>BufferedInputStream类：字节缓冲输入流(高效流)</li>
</ul>
</li>
<li>OutputStream类：输出字节流的基类(抽象类)	<ul>
<li>FileOutputStream类：字节输出流</li>
<li>BufferedOutputStream类：字节缓冲输出流(高效流)</li>
</ul>
</li>
</ul>
</li>
<li>字符流<ul>
<li>Reader类：输入字符流的基类<ul>
<li>FileReader类：读取字符文件的便捷流</li>
<li>BufferedReader类：字符缓冲输入流(高效流)</li>
<li>InputStreamReader类：字节流和字符流之间的桥梁(转换流)</li>
</ul>
</li>
<li>writer类：输出字符流的基类<ul>
<li>FileWriter类：写入字符文件的便捷流</li>
<li>BufferedWriter类：字符缓冲输出流(高效流)</li>
<li>OutputStreamWriter类：字节输出流和字符输出流之间的桥梁(转换流)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="对象序列化流"><a href="#对象序列化流" class="headerlink" title="对象序列化流"></a>对象序列化流</h2><ul>
<li>对象序列化：就是将对象保存到磁盘中，或者在网络中传输对象  </li>
<li>这种机制就是使用一个字节序列表示一个对象，该字节序列包含：对象的类型、对象的数据和对象中存储的属性等信息  </li>
<li>字节序列写到文件之后，相当于文件中持久保存了一个对象的信息  </li>
<li>反之，该字节序列还可以从文件中读取回来，重构对象，对它进行反序列化</li>
</ul>
<h2 id="BIO-NIO-AIO-有什么区别"><a href="#BIO-NIO-AIO-有什么区别" class="headerlink" title="BIO,NIO,AIO 有什么区别?"></a>BIO,NIO,AIO 有什么区别?</h2>]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Java</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring面试总结笔记</title>
    <url>/p/c24b3477/</url>
    <content><![CDATA[<h1 id="Spring学习笔记与面试题"><a href="#Spring学习笔记与面试题" class="headerlink" title="Spring学习笔记与面试题"></a>Spring学习笔记与面试题</h1><h2 id="什么是Spring-Framework，它的作用"><a href="#什么是Spring-Framework，它的作用" class="headerlink" title="什么是Spring Framework，它的作用"></a>什么是Spring Framework，它的作用</h2><p>Spring是一个轻量级的JavaEE框架，它主要解决企业应用中的复杂性问题。Spring框架有三个核心部分：IoC容器、AOP和数据访问&#x2F;集成层。Spring中的IoC容器提供了一种对象创建和对象之间关系管理的机制，以实现松散耦合和可扩展性。AOP提供了一种很好的方式来实现横向关注点的处理，如事务管理，安全检查，缓存等。数据访问&#x2F;集成层则提供了许多针对不同数据持久化技术的实现，比如JDBC，ORM和NoSQL。</p>
<h2 id="如何理解IoC"><a href="#如何理解IoC" class="headerlink" title="如何理解IoC"></a>如何理解IoC</h2><p>IoC是一种设计思想，通过将对象之间的依赖关系交给容器来管理，从而实现松散耦合。在Spring中，IoC容器扮演了一个中心角色，负责创建对象，装配对象之间的依赖关系，并管理它们的整个生命周期。IoC还提供了一些高级功能，如AOP和事件驱动等，可以进一步增强应用程序的可维护性和可扩展性。</p>
<h2 id="什么是AOP"><a href="#什么是AOP" class="headerlink" title="什么是AOP"></a>什么是AOP</h2><p>AOP是一种编程范式，它能够在程序运行期间动态地将代码切入到原有代码的流程中，从而实现横向关注点的处理，如<strong>日志记录</strong>、<strong>事务管理</strong>和<strong>安全检查</strong>等。在Spring中，AOP是通过<strong>代理模式</strong>来实现的，在创建Bean时为Bean生成一个代理对象，代理对象能够拦截指定方法的调用，并在执行前或执行后执行特定操作。</p>
<h2 id="Spring中Bean之间的依赖关系是怎样的"><a href="#Spring中Bean之间的依赖关系是怎样的" class="headerlink" title="Spring中Bean之间的依赖关系是怎样的"></a>Spring中Bean之间的依赖关系是怎样的</h2><p>在Spring中，Bean之间的依赖关系主要通过构造函数注入、Setter方法注入和自动注入来实现。构造函数注入是通过Bean的构造方法注入其他Bean作为参数来实现；Setter方法注入是通过Bean的Setter方法来注入其他Bean；自动注入则是通过IoC容器在Bean创建时自动发现并注入其他Bean，可以通过设置@Autowired或@Resource注解来完成。</p>
<h2 id="Spring框架中的单例模式是怎样实现的"><a href="#Spring框架中的单例模式是怎样实现的" class="headerlink" title="Spring框架中的单例模式是怎样实现的"></a>Spring框架中的单例模式是怎样实现的</h2><p>在Spring中，默认情况下，所有的Bean都是单例的。当IoC容器创建一个Bean时，它会缓存该Bean的实例，并在后续请求中返回相同的实例。这种机制可以提高应用程序的性能并减少内存消耗，但也需要注意线程安全和状态管理等问题。</p>
<h2 id="Spring中的事务管理是如何实现的"><a href="#Spring中的事务管理是如何实现的" class="headerlink" title="Spring中的事务管理是如何实现的"></a>Spring中的事务管理是如何实现的</h2><p>Spring通过AOP在运行时动态地将事务相关的逻辑切入到指定的方法中，从而实现事务管理。通常情况下，Spring使用声明式事务管理来管理事务。开发者可以通过@Transactional注解或XML配置文件来定义事务范围、传播属性以及回滚规则等。</p>
<h2 id="Spring的优势是什么"><a href="#Spring的优势是什么" class="headerlink" title="Spring的优势是什么"></a>Spring的优势是什么</h2><p>Spring的主要优势有：</p>
<ol>
<li>提高了应用程序的可扩展性和可维护性。</li>
<li>提供了一种松散耦合的方式来管理对象之间的依赖关系。</li>
<li>提供了完整的数据访问&#x2F;集成层，支持多种持久化技术。</li>
<li>提供了AOP支持，可以很方便地实现横向关注点的处理。</li>
<li>提供了很好的集成支持，可以与其他框架无缝协作。</li>
</ol>
<h2 id="解释一下Spring中的BeanFactory和ApplicationContext有什么区别"><a href="#解释一下Spring中的BeanFactory和ApplicationContext有什么区别" class="headerlink" title="解释一下Spring中的BeanFactory和ApplicationContext有什么区别"></a>解释一下Spring中的BeanFactory和ApplicationContext有什么区别</h2><p>BeanFactory是Spring IoC容器的最基本形式，提供了基本的IoC功能。它是延迟初始化的，即当一个Bean被实际使用时才被创建。ApplicationContext是BeanFactory的子接口，提供了更多的企业级功能，如AOP，事件驱动，国际化等。ApplicationContext也是预初始化的，即在容器启动时就已经创建了所有的Bean。</p>
<h2 id="Spring中的注解有哪些"><a href="#Spring中的注解有哪些" class="headerlink" title="Spring中的注解有哪些"></a>Spring中的注解有哪些</h2><ol>
<li>@Component、@Service、@Repository、@Controller：<strong>用于标识Bean的角色</strong>。</li>
<li>@Autowired、@Resource：<strong>用于自动装配Bean</strong>。</li>
<li>@PostConstruct、@PreDestroy：<strong>用于指定初始化和销毁方法</strong>。</li>
<li>@Transactional：<strong>用于声明式事务管理</strong>。</li>
<li>@Scope：<strong>用于指定Bean作用域</strong>。</li>
</ol>
<h2 id="Spring-MVC框架的流程是怎样的"><a href="#Spring-MVC框架的流程是怎样的" class="headerlink" title="Spring MVC框架的流程是怎样的"></a>Spring MVC框架的流程是怎样的</h2><p>Spring MVC的处理流程如下：</p>
<ol>
<li>客户端向服务器发起请求。</li>
<li>DispatcherServlet接收到请求并将请求发送给处理器映射器进行处理器的映射查找。</li>
<li>处理器映射器将请求的URL映射到相应的控制器(Controller)上，并返回处理器及其拦截器(如果有)。</li>
<li>DispatcherServlet调用处理器适配器(Adapter)执行映射的处理器(Controller)。</li>
<li>处理器(Controller)执行后返回ModelAndView对象。</li>
<li>DispatcherServlet将ModelAndView对象交给视图解析器(ViewResolver)进行解析。</li>
<li>视图解析器(ViewResolver)解析出对应的视图(View)。</li>
<li>DispatcherServlet将Model数据和View视图进行渲染后返回给客户端。</li>
</ol>
<h2 id="Spring-Boot是什么？与传统的Spring框架有什么区别？"><a href="#Spring-Boot是什么？与传统的Spring框架有什么区别？" class="headerlink" title="Spring Boot是什么？与传统的Spring框架有什么区别？"></a>Spring Boot是什么？与传统的Spring框架有什么区别？</h2><p>Spring Boot是一种基于Spring的快速应用开发框架，它能够让开发者更加快速地搭建基于Spring的应用程序，并提供了自动化配置、快速启动等便利功能。相比传统的Spring框架，Spring Boot具有更简洁的配置方式和更快的启动速度，同时还提供了更多的功能和特性支持。</p>
<h2 id="解释一下Spring的生命周期"><a href="#解释一下Spring的生命周期" class="headerlink" title="解释一下Spring的生命周期"></a>解释一下Spring的生命周期</h2><p>在Spring中，Bean的生命周期包括以下几个阶段：</p>
<ol>
<li>实例化：当IoC容器读取到Bean的定义后，创建一个新的Bean实例。</li>
<li>属性注入：IoC容器将Bean中声明的依赖关系和配置信息注入到Bean中。</li>
<li>BeanPostProcessor前置处理：如果Bean中定义了BeanPostProcessor接口的实现类，它们将在Bean初始化之前被调用。</li>
<li>初始化：如果Bean实现了InitializingBean接口，则在所有属性都被设置完毕后调用afterPropertiesSet()方法。同时，也可以通过@Bean(initMethod &#x3D; “init”)来指定Bean的初始化方法。</li>
<li>BeanPostProcessor后置处理：如果Bean中定义了BeanPostProcessor接口的实现类，它们将在Bean初始化之后被调用。</li>
<li>销毁：如果Bean实现了DisposableBean接口，则在容器关闭或者该Bean被从容器中移除时调用destroy()方法。同时，也可以通过@Bean(destroyMethod &#x3D; “destroy”)来指定Bean的销毁方法。</li>
</ol>
<h2 id="Spring中的IoC如何管理对象"><a href="#Spring中的IoC如何管理对象" class="headerlink" title="Spring中的IoC如何管理对象"></a>Spring中的IoC如何管理对象</h2><p>在Spring中，IOC通过Bean工厂来管理对象，Bean工厂是提供了一种对象创建和对象之间关系管理的机制。它在读取配置文件时会自动创建和装配对象，并缓存这些对象以便后续使用。开发者可以通过构造器注入、Setter方法注入和自动注入等方式来管理对象之间的依赖关系。</p>
<h2 id="Spring中的AOP的具体实现方式有哪些"><a href="#Spring中的AOP的具体实现方式有哪些" class="headerlink" title="Spring中的AOP的具体实现方式有哪些"></a>Spring中的AOP的具体实现方式有哪些</h2><p>Spring中实现AOP的主要方式有两种：JDK动态代理和CGLIB代理。JDK动态代理又叫接口代理，它是基于Java反射机制实现的，要求目标对象必须实现至少一个接口；CGLIB代理则是基于字节码操作实现的，当目标对象没有实现接口时，它就会使用CGLIB代理。通常情况下，Spring默认使用JDK动态代理来实现AOP，但如果目标对象没有实现任何接口，则会自动切换到使用CGLIB代理。</p>
<h2 id="Spring中的JdbcTemplate是什么？使用JdbcTemplate需要做哪些配置"><a href="#Spring中的JdbcTemplate是什么？使用JdbcTemplate需要做哪些配置" class="headerlink" title="Spring中的JdbcTemplate是什么？使用JdbcTemplate需要做哪些配置"></a>Spring中的JdbcTemplate是什么？使用JdbcTemplate需要做哪些配置</h2><p>JdbcTemplate是Spring提供的一个对JDBC访问的封装，它简化了JDBC操作的繁琐和冗长，能够提高开发效率。使用JdbcTemplate需要在Spring的配置文件中配置基本数据源信息、配置JdbcTemplate Bean以及为JdbcTemplate Bean配置数据源。</p>
<h2 id="解释一下Spring中的循环依赖问题"><a href="#解释一下Spring中的循环依赖问题" class="headerlink" title="解释一下Spring中的循环依赖问题"></a>解释一下Spring中的循环依赖问题</h2><p>循环依赖指两个或多个Bean之间相互引用，形成了一个无限循环调用的情况。在Spring容器中，如果存在循环依赖，但是都是单例模式的Bean，则可以通过Spring容器提前暴露正在创建的Bean，从而避免循环依赖问题。如果存在循环依赖且其中一方是原型模式的Bean，则Spring无法处理这种情况。</p>
<h2 id="Spring中的事件驱动机制是怎样的？有哪些默认事件"><a href="#Spring中的事件驱动机制是怎样的？有哪些默认事件" class="headerlink" title="Spring中的事件驱动机制是怎样的？有哪些默认事件"></a>Spring中的事件驱动机制是怎样的？有哪些默认事件</h2><p>Spring中的事件驱动机制基于观察者模式实现。当一个Bean发生事件时，它会创建一个事件对象并将其发布到Spring容器上。容器中所有对该事件对象感兴趣的Bean都会收到事件通知并进行相应的处理。Spring中默认的事件有：ContextRefreshedEvent、ContextStartedEvent、ContextStoppedEvent和ContextClosedEvent。</p>
<h2 id="Spring的MVC框架中，HandlerAdapter的作用是什么"><a href="#Spring的MVC框架中，HandlerAdapter的作用是什么" class="headerlink" title="Spring的MVC框架中，HandlerAdapter的作用是什么"></a>Spring的MVC框架中，HandlerAdapter的作用是什么</h2><p>HandlerAdapter是Spring MVC框架中的一个重要组件，它的作用是将请求交给相应的处理器(Controller)进行处理，并负责调用处理器的方法来生成ModelAndView对象。</p>
<h2 id="Autowired和-Resource注解用来干嘛的"><a href="#Autowired和-Resource注解用来干嘛的" class="headerlink" title="@Autowired和@Resource注解用来干嘛的"></a>@Autowired和@Resource注解用来干嘛的</h2><p>@Autowired和@Resource注解是用于自动装配Bean的。@Autowired是Spring提供的注解，可以在Setter方法上、构造函数上、类属性上进行标注，用于自动注入匹配类型的Bean。@Resource是JavaEE提供的注解，可以在Setter方法上或类属性上进行标注，用于自动注入指定名称和类型匹配的Bean。</p>
<h2 id="Spring中的事务传播属性有哪些"><a href="#Spring中的事务传播属性有哪些" class="headerlink" title="Spring中的事务传播属性有哪些"></a>Spring中的事务传播属性有哪些</h2><p>1）PROPAGATION_REQUIRED：如果当前存在事务，则加入该事务；如果不存在事务，则创建一个新的事务。</p>
<p>2）PROPAGATION_SUPPORTS：如果当前存在事务，则加入该事务；如果不存在事务，则不开启事务。</p>
<p>3）PROPAGATION_MANDATORY：如果当前存在事务，则加入该事务；如果不存在事务，则抛出异常。</p>
<p>4）PROPAGATION_REQUIRES_NEW：无论是否存在事务，都创建一个新的事务并进行执行。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>面试题</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Tim-Course-App毕业设计项目详情</title>
    <url>/p/47241/</url>
    <content><![CDATA[<h1 id="Tim-Course-Admin"><a href="#Tim-Course-Admin" class="headerlink" title="Tim-Course-Admin"></a>Tim-Course-Admin</h1><p>一个基于Spring Boot开发的 课程达成度分析系统</p>
<p>（请注意：一下内容仅为本人论文初稿的思考过程，不具有任何实际应用和参考价值，请谨慎观看！）</p>
<h2 id="核心技术组成"><a href="#核心技术组成" class="headerlink" title="核心技术组成"></a>核心技术组成</h2><h3 id="Spring-Boot框架"><a href="#Spring-Boot框架" class="headerlink" title="Spring Boot框架"></a>Spring Boot框架</h3><p>1、简介<br><code>Spring Boot</code>是一款开箱即用框架，提供各种默认配置来简化项目配置。让<code>Spring</code>应用变的更轻量化、更快的入门，在主程序执行<code>main</code>函数就可以运行。你也可以打包你的应用为<code>jar</code>并通过使用<code>java -jar</code>来运行你的Web应用。它遵循”约定优先于配置”的原则， 使用<code>SpringBoot</code>只需很少的配置，大部分的时候直接使用默认的配置即可。同时可以与<code>Spring Cloud</code>微服务结合，开发更加复杂多样的应用。</p>
<p>2、优点</p>
<ul>
<li>使编码变得简单： Spring Boot支持使用注解开发和配置项目，极大的提高效率。</li>
<li>使配置变得简单： 自动配置、快速集成新技术能力，无冗余代码生成和复制的XML配置。</li>
<li>使部署变得简单： 内嵌Tomcat、Jetty、Undertow等Web容器，无需以war包形式部署</li>
<li>使监控变得简单： 内置Actuator提供运行时的应用监控。</li>
<li>使集成变得简单： 对市面上主流的开发框架无配置集成。</li>
</ul>
<h3 id="Vue框架"><a href="#Vue框架" class="headerlink" title="Vue框架"></a>Vue框架</h3><p>1、简介</p>
<p><code>Vue</code>是一款用于构建用户界面的 JavaScript 框架。它基于标准 HTML、CSS 和 JavaScript 构建，并提供了一套声明式的、组件化的编程模型，帮助你高效地开发用户界面。无论是简单还是复杂的界面，Vue 都可以胜任。</p>
<p>2、优点</p>
<ul>
<li>易学易用：基于标准 HTML、CSS 和 JavaScript 构建，提供容易上手的 API 和一流的文档。</li>
<li>性能出色：经过编译器优化、完全响应式的渲染系统，几乎不需要手动优化。</li>
<li>灵活多变：丰富的、可渐进式集成的生态系统，可以根据应用规模在库和框架间切换自如。</li>
</ul>
<h2 id="系统主要模块"><a href="#系统主要模块" class="headerlink" title="系统主要模块"></a>系统主要模块</h2><p><img src="https://s2.loli.net/2024/10/14/hF9KBarCLUYWZ3T.png"></p>
<h3 id="模块一：用户注册登录模块"><a href="#模块一：用户注册登录模块" class="headerlink" title="模块一：用户注册登录模块"></a>模块一：用户注册登录模块</h3><p>(1) 用户可以通过提供用户名、密码、电子邮件地址等信息来创建新账户。系统应进行输入验证，确保用户名的唯一性和密码的安全性。注册成功后，用户应收到确认邮件，通过点击邮件中的链接来激活账户。</p>
<p>(2) 用户通过输入用户名和密码来访问系统。系统应提供密码错误时的重试限制，并在多次失败后锁定账户或要求额外的身份验证。应支持“记住密码”功能，允许用户在同一设备上自动登录。</p>
<p>(3) 如果用户忘记密码，应提供通过电子邮件重置密码的功能。用户输入注册的电子邮件地址后，系统发送包含密码重置链接的邮件。</p>
<p>(4) 用户登录后，可以更改个人信息，如电子邮件地址、密码和联系信息。用户应能够查看和编辑自己的个人资料。</p>
<p>(5) 所有用户信息都应通过加密技术安全存储。登录尝试应记录在系统日志中，以便监控和分析潜在的安全威胁。</p>
<h3 id="模块二：成绩表管理模块"><a href="#模块二：成绩表管理模块" class="headerlink" title="模块二：成绩表管理模块"></a>模块二：成绩表管理模块</h3><p>(1) 用户可以上传成绩表文件，系统应支持CSV、Excel等数据。提供文件大小和格式的验证，确保上传的文件符合系统要求。</p>
<p>(2) 系统将解析上传的文件，提取成绩数据，并将其转换为系统内部格式。应处理各种数据异常，如空白字段、不规则数据等，并提供错误报告。</p>
<p>(3) 用户可以将文件中的数据列映射到系统中的成绩模型，包括学生信息、课程代码、小题分、成绩等。提供一个用户友好的界面，让用户可以轻松地完成映射过程。</p>
<p>(4) 在导入数据到系统之前，进行数据验证，确保所有数据都是准确和完整的。如果发现错误或缺失的数据，系统应提示用户进行修正。</p>
<p>(5) 系统应记录所有的导入操作，包括文件名、导入时间、用户信息以及任何导入错误。用户可以查看导入历史和状态，以便跟踪数据的变更。</p>
<p>(6) 确保所有上传的数据都通过安全的通道传输，并在服务器上安全存储。设置权限控制，确保只有授权用户才能访问学生信息。对于敏感数据，如学生的个人信息和成绩，应实施额外的保护措施。</p>
<h3 id="模块三：学生信息管理模块"><a href="#模块三：学生信息管理模块" class="headerlink" title="模块三：学生信息管理模块"></a>模块三：学生信息管理模块</h3><p>(1) 允许管理员或教师录入新学生的个人资料，包括姓名、学号、班级、联系方式等。提供一个表单来输入学生信息，并允许用户在之后更新信息。</p>
<p>(2) 允许用户根据不同的条件（如学号、姓名、班级）查询学生信息。提供搜索功能，以及一个清晰的列表视图来展示搜索结果。</p>
<p>(3) 提供对学生信息的管理操作，包括编辑、删除和查看详细信息。在学生列表中，每条记录旁提供操作按钮，以便进行管理操作。</p>
<p>(4) 记录和管理学生的学习成绩和课程参与情况。与成绩表导入模块协同工作，自动更新学生的学习记录。</p>
<p>(5) 确保学生信息的安全和隐私。采用加密技术存储敏感信息，并设置权限控制，确保只有授权用户才能访问学生信息。</p>
<h3 id="模块四：知识点管理模块"><a href="#模块四：知识点管理模块" class="headerlink" title="模块四：知识点管理模块"></a>模块四：知识点管理模块</h3><p>(1) 允许教师定义课程的知识点，并描述其与课程目标的关系。提供一个界面，教师可以在其中输入知识点的名称、描述以及与之相关的课程目标。</p>
<p>(2) 允许教师编辑已定义的知识点信息。在知识点列表中，为每个知识点提供编辑选项，使教师可以更新知识点的信息。</p>
<p>(3) 允许教师删除不再相关或过时的知识点。在知识点列表中，为每个知识点提供删除选项，并在删除前要求用户确认。</p>
<p>(4) 建立和管理知识点与课程目标之间的关联。提供一个界面，教师可以选择知识点并将其与特定的课程目标关联起来。</p>
<p>(5) 跟踪学生对每个知识点的掌握情况。与成绩分析模块协同工作，根据学生的成绩数据，提供关于知识点掌握情况的反馈。</p>
<p>(6) 确保知识点信息的安全和隐私。采用加密技术存储敏感信息，并实施权限控制，确保只有授权用户才能访问知识点信息。</p>
<h3 id="模块五：成绩分析模块"><a href="#模块五：成绩分析模块" class="headerlink" title="模块五：成绩分析模块"></a>模块五：成绩分析模块</h3><p>(1) 对导入的成绩数据进行解析，以便进行进一步的分析。系统将自动识别和处理各种成绩数据格式，确保数据准确性。</p>
<p>(2) 提供基本的成绩统计分析，如平均分、最高分、最低分等。使用统计学方法计算各项指标，并以表格或图形的形式展示。</p>
<p>(3) 分析学生对各个知识点的掌握程度。与知识点管理模块协同，评估学生对每个知识点的理解和应用。</p>
<p>(4) 识别学生的弱项知识点，为教师提供针对性教学建议。通过数据挖掘技术，找出学生成绩低于预期的知识点。</p>
<p>(5) 分析整体成绩分布情况，如正态分布、偏态分布等。应用统计学原理，展示成绩分布图，如直方图、箱线图等。</p>
<p>(6) 生成详细的成绩分析报告，供教师和学生参考。提供一键生成报告的功能，包括所有分析结果和图表。</p>
<p>(7) 确保成绩数据的安全和隐私。采用加密技术存储敏感信息，并实施权限控制，确保只有授权用户才能访问成绩分析结果。</p>
<h3 id="模块六：教学改进计划模块"><a href="#模块六：教学改进计划模块" class="headerlink" title="模块六：教学改进计划模块"></a>模块六：教学改进计划模块</h3><p>(1) 允许教师根据成绩分析结果制定教学改进计划。提供一个界面，教师可以输入改进计划的详细信息，包括目标、策略、预期结果和实施时间表。</p>
<p>(2) 跟踪教学改进措施的实施情况和效果。系统记录改进措施的实施细节，并提供定期更新的功能，以便教师可以记录和查看进展。</p>
<p>(3) 收集学生和其他教师对教学改进计划的反馈。提供在线调查或反馈表单，使教师可以了解改进计划的接受度和效果。</p>
<p>(4) 评估教学改进计划的实际效果。通过对比实施前后的成绩分析数据，系统帮助教师评估改进计划的成效。</p>
<p>(5) 生成教学改进计划及其实施效果的详细报告。提供一键生成报告的功能，包括改进计划的所有相关信息和评估结果。</p>
<p>(6) 确保教学改进计划中的信息安全和隐私。采用加密技术存储敏感信息，并实施权限控制，确保只有授权用户才能访问和管理改进计划。</p>
<h2 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h2><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><ul>
<li>使用MySQL存储项目基本数据，使用Redis存储JWT、操作者IP地址、验证码等信息</li>
<li>目前分为以下几个表：用户信息表（tim_accounts）、成绩表（tim_scores）、课程表（tim_course）、小题分表（tim_questions）、学生基本信息表（tim_students）、知识点表（tim_points）、成绩分析表（tim_analysis）、计划生成表（tim-plans）</li>
</ul>
<h4 id="数据库详情内容："><a href="#数据库详情内容：" class="headerlink" title="数据库详情内容："></a>数据库详情内容：</h4><p>用户信息表（tims_accounts）：用户ID（主键自增）、用户名、密码（加密存储）、电子邮件、角色（教师&#x2F;学生&#x2F;管理员）、注册日期、是否启用。</p>
<p>课程表（tims_courses）：课程ID（主键自增）、课程名称、课程授课教师、课程学分。</p>
<p>学生基本信息表（tims_students）：学生ID（主键自增）、序列号、学号、学生姓名、性别、年级、专业、班次、联系方式。</p>
<p>总成绩表（tims_grades）：成绩ID（主键自增）、学生ID（与学生表关联）、课程ID（与课程表关联）、总分、平时分、最终成绩、评价。</p>
<p>小题得分表（tims_scores）：小题得分ID（主键自增）、学生ID（与学生表关联）、题目ID（与小题表关联）、得分。</p>
<p>小题表（tims_questions）：题目ID（主键自增）、题目类型（比如选择题、填空题等）、题目名、小题分分值、课程目标ID（与课程目标表关联）、要点ID（与知识要点关联）。</p>
<p>课程目标表（tims_targets）：课程目标ID（主键自增）、目标描述、课程ID（与课程表关联）、权重。</p>
<p>知识要点表（tims_essentials）：要点ID（主键自增）、要点名、要点描述。</p>
<p>课程目标达成度表（tims_attains）：达成度ID（主键自增）、学生ID（与学生表关联）、课程目标ID（与课程目标表关联）、达成度。</p>
<p>成绩分析表（tims_analysis）：报告ID（主键自增）、课程ID（与课程表关联）、分析结果、生成日期。</p>
<p>教学改善计划生成表（tims_plans）：计划ID（主键自增）、课程ID（与课程表关联）、描述、开始日期、结束日期、完成状态。</p>
<h4 id="数据库字段名：-与上文对应"><a href="#数据库字段名：-与上文对应" class="headerlink" title="数据库字段名：(与上文对应)"></a>数据库字段名：(与上文对应)</h4><p><strong>tims_accounts：</strong>account_id、account_name、password、email、role、register_time、status；</p>
<p><strong>tims_courses：</strong>course_id、course_name、course_teacher、credits；</p>
<p><strong>tims_students：</strong>student_id、serial_number、student_number、student_name、sex、year、major、shift、phone；</p>
<p><strong>tims_grades：</strong>grade_id、student_id、course_id、total_num、usual_num、final_num、evaluation；</p>
<p><strong>tims_scores：</strong>score_id、student_id、question_id、points；</p>
<p><strong>tims_questions：</strong>question_id、question_type、question_name、question_total、target_id、essential_id；</p>
<p><strong>tims_targets：</strong>target_id、target_desc、course_id、weight；</p>
<p><strong>tims_essentials：</strong>essential_id、essential_name、essential_desc；</p>
<p><strong>tims_attains：</strong>attain_id、student_id、target_id、attainment；</p>
<p><strong>tims_analysis：</strong>analysis_id、course_id、analysis_desc、generation_time；</p>
<p><strong>tims_plans：</strong>plan_id、course_id、plan_desc、start_time、end_time、achievement；</p>
<p>暂时停用：</p>
<p><strong>tim_usuals：</strong>usual_id、student_id、course_id、usual_score。</p>
<h4 id="建表SQL语句："><a href="#建表SQL语句：" class="headerlink" title="建表SQL语句："></a>建表SQL语句：</h4><p>以下语句为数据库导出字段，与实际内容可能存在出入</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">-- Table structure for tim_accounts</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `tim_accounts`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `tim_accounts`  (</span><br><span class="line">  `account_id` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;用户ID&#x27;</span>,</span><br><span class="line">  `account_name` <span class="type">varchar</span>(<span class="number">255</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_0900_ai_ci <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户名&#x27;</span>,</span><br><span class="line">  `password` <span class="type">varchar</span>(<span class="number">255</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_0900_ai_ci <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户密码(加密存储)&#x27;</span>,</span><br><span class="line">  `email` <span class="type">varchar</span>(<span class="number">255</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_0900_ai_ci <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户电子邮件&#x27;</span>,</span><br><span class="line">  `role` <span class="type">varchar</span>(<span class="number">255</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_0900_ai_ci <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户角色(访客/教师/管理员)&#x27;</span>,</span><br><span class="line">  `register_time` datetime <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;注册时间&#x27;</span>,</span><br><span class="line">  `status` <span class="type">char</span>(<span class="number">1</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_0900_ai_ci <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;状态，0代表启用，1代表停用&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`account_id`) <span class="keyword">USING</span> BTREE,</span><br><span class="line">  <span class="keyword">UNIQUE</span> INDEX `unique_email`(`email` <span class="keyword">ASC</span>) <span class="keyword">USING</span> BTREE,</span><br><span class="line">  <span class="keyword">UNIQUE</span> INDEX `unique_username`(`account_name` <span class="keyword">ASC</span>) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB AUTO_INCREMENT <span class="operator">=</span> <span class="number">2</span> <span class="type">CHARACTER</span> <span class="keyword">SET</span> <span class="operator">=</span> utf8mb4 <span class="keyword">COLLATE</span> <span class="operator">=</span> utf8mb4_0900_ai_ci ROW_FORMAT <span class="operator">=</span> <span class="keyword">Dynamic</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">-- Table structure for tim_analysis</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `tim_analysis`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `tim_analysis`  (</span><br><span class="line">  `analysis_id` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;报告ID&#x27;</span>,</span><br><span class="line">  `score_id` <span class="type">int</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;成绩ID&#x27;</span>,</span><br><span class="line">  `analysis_desc` <span class="type">varchar</span>(<span class="number">255</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_0900_ai_ci <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;分析结果&#x27;</span>,</span><br><span class="line">  `generation_time` datetime <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;生成时间&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`analysis_id`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB AUTO_INCREMENT <span class="operator">=</span> <span class="number">1</span> <span class="type">CHARACTER</span> <span class="keyword">SET</span> <span class="operator">=</span> utf8mb4 <span class="keyword">COLLATE</span> <span class="operator">=</span> utf8mb4_0900_ai_ci ROW_FORMAT <span class="operator">=</span> <span class="keyword">Dynamic</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">-- Table structure for tim_courses</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `tim_courses`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `tim_courses`  (</span><br><span class="line">  `course_id` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;课程ID&#x27;</span>,</span><br><span class="line">  `course_name` <span class="type">varchar</span>(<span class="number">255</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_0900_ai_ci <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;课程名&#x27;</span>,</span><br><span class="line">  `course_teacher` <span class="type">varchar</span>(<span class="number">255</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_0900_ai_ci <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;课程授课教师&#x27;</span>,</span><br><span class="line">  `credits` <span class="type">int</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;课程学分&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`course_id`) <span class="keyword">USING</span> BTREE,</span><br><span class="line">  <span class="keyword">UNIQUE</span> INDEX `unique_course_name`(`course_name` <span class="keyword">ASC</span>) <span class="keyword">USING</span> BTREE COMMENT <span class="string">&#x27;课程名不能重复&#x27;</span></span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB AUTO_INCREMENT <span class="operator">=</span> <span class="number">5</span> <span class="type">CHARACTER</span> <span class="keyword">SET</span> <span class="operator">=</span> utf8mb4 <span class="keyword">COLLATE</span> <span class="operator">=</span> utf8mb4_0900_ai_ci ROW_FORMAT <span class="operator">=</span> <span class="keyword">Dynamic</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">-- Table structure for tim_plans</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `tim_plans`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `tim_plans`  (</span><br><span class="line">  `plan_id` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;计划ID&#x27;</span>,</span><br><span class="line">  `course_id` <span class="type">int</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;课程ID&#x27;</span>,</span><br><span class="line">  `plan_desc` <span class="type">varchar</span>(<span class="number">255</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_0900_ai_ci <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;计划内容&#x27;</span>,</span><br><span class="line">  `start_time` datetime <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;开始时间&#x27;</span>,</span><br><span class="line">  `end_time` datetime <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;结束时间&#x27;</span>,</span><br><span class="line">  `achievement` <span class="type">varchar</span>(<span class="number">255</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_0900_ai_ci <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;完成状态&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`plan_id`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB AUTO_INCREMENT <span class="operator">=</span> <span class="number">1</span> <span class="type">CHARACTER</span> <span class="keyword">SET</span> <span class="operator">=</span> utf8mb4 <span class="keyword">COLLATE</span> <span class="operator">=</span> utf8mb4_0900_ai_ci ROW_FORMAT <span class="operator">=</span> <span class="keyword">Dynamic</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">-- Table structure for tim_points</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `tim_points`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `tim_points`  (</span><br><span class="line">  `point_id` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;知识点ID&#x27;</span>,</span><br><span class="line">  `point_name` <span class="type">varchar</span>(<span class="number">255</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_0900_ai_ci <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;知识点名称&#x27;</span>,</span><br><span class="line">  `point_desc` <span class="type">varchar</span>(<span class="number">255</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_0900_ai_ci <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;知识点描述&#x27;</span>,</span><br><span class="line">  `course_id` <span class="type">int</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;课程ID&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`point_id`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB AUTO_INCREMENT <span class="operator">=</span> <span class="number">1</span> <span class="type">CHARACTER</span> <span class="keyword">SET</span> <span class="operator">=</span> utf8mb4 <span class="keyword">COLLATE</span> <span class="operator">=</span> utf8mb4_0900_ai_ci ROW_FORMAT <span class="operator">=</span> <span class="keyword">Dynamic</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">-- Table structure for tim_questions</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `tim_questions`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `tim_questions`  (</span><br><span class="line">  `question_id` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;题目ID&#x27;</span>,</span><br><span class="line">  `student_id` <span class="type">int</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;学生ID&#x27;</span>,</span><br><span class="line">  `question_name` <span class="type">varchar</span>(<span class="number">255</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_0900_ai_ci <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;小题分名&#x27;</span>,</span><br><span class="line">  `question_total` <span class="type">int</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;题目分值&#x27;</span>,</span><br><span class="line">  `course_id` <span class="type">int</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;课程ID&#x27;</span>,</span><br><span class="line">  `question_score` <span class="type">int</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;得分&#x27;</span>,</span><br><span class="line">  `point_id` <span class="type">int</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;知识点ID&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`question_id`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB AUTO_INCREMENT <span class="operator">=</span> <span class="number">1</span> <span class="type">CHARACTER</span> <span class="keyword">SET</span> <span class="operator">=</span> utf8mb4 <span class="keyword">COLLATE</span> <span class="operator">=</span> utf8mb4_0900_ai_ci ROW_FORMAT <span class="operator">=</span> <span class="keyword">Dynamic</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">-- Table structure for tim_scores</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `tim_scores`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `tim_scores`  (</span><br><span class="line">  `score_id` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;成绩ID&#x27;</span>,</span><br><span class="line">  `student_id` <span class="type">int</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;学生ID&#x27;</span>,</span><br><span class="line">  `course_id` <span class="type">int</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;课程ID&#x27;</span>,</span><br><span class="line">  `total_num` <span class="type">int</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;总分&#x27;</span>,</span><br><span class="line">  `evaluation` <span class="type">varchar</span>(<span class="number">255</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_0900_ai_ci <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;评价&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`score_id`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB AUTO_INCREMENT <span class="operator">=</span> <span class="number">1</span> <span class="type">CHARACTER</span> <span class="keyword">SET</span> <span class="operator">=</span> utf8mb4 <span class="keyword">COLLATE</span> <span class="operator">=</span> utf8mb4_0900_ai_ci ROW_FORMAT <span class="operator">=</span> <span class="keyword">Dynamic</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">-- Table structure for tim_students</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `tim_students`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `tim_students`  (</span><br><span class="line">  `student_id` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;学生ID&#x27;</span>,</span><br><span class="line">  `student_number` <span class="type">varchar</span>(<span class="number">255</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_0900_ai_ci <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;学号&#x27;</span>,</span><br><span class="line">  `student_name` <span class="type">varchar</span>(<span class="number">255</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_0900_ai_ci <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;学生姓名&#x27;</span>,</span><br><span class="line">  `sex` <span class="type">char</span>(<span class="number">1</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_0900_ai_ci <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;学生性别，0为未知，1为男，2为女&#x27;</span>,</span><br><span class="line">  `grade` <span class="type">varchar</span>(<span class="number">255</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_0900_ai_ci <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;年级班级&#x27;</span>,</span><br><span class="line">  `phone` <span class="type">varchar</span>(<span class="number">255</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_0900_ai_ci <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;电话号码&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`student_id`) <span class="keyword">USING</span> BTREE,</span><br><span class="line">  <span class="keyword">UNIQUE</span> INDEX `unique_number`(`student_number` <span class="keyword">ASC</span>) <span class="keyword">USING</span> BTREE COMMENT <span class="string">&#x27;学号为唯一&#x27;</span></span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB AUTO_INCREMENT <span class="operator">=</span> <span class="number">2</span> <span class="type">CHARACTER</span> <span class="keyword">SET</span> <span class="operator">=</span> utf8mb4 <span class="keyword">COLLATE</span> <span class="operator">=</span> utf8mb4_0900_ai_ci ROW_FORMAT <span class="operator">=</span> <span class="keyword">Dynamic</span>;</span><br></pre></td></tr></table></figure>



<h4 id="多表联查描述："><a href="#多表联查描述：" class="headerlink" title="多表联查描述："></a>多表联查描述：</h4><p>查询成绩表需要查询出每一个学生（学生姓名、学号）对应的每一个课程（课程名）的总分和评价信息</p>
<p>查询小题分需要查询出每一个学生（学生姓名、学号）每一个小题（题目名、分值、得分）每一个课程（课程名）每一个知识点（知识点名称）</p>
<p>查询知识点需要查询出每一个知识点（名称、描述）每一个课程（课程名称、课程授课教师）</p>
<p>查询成绩分析表需要查询出所有学生的平均分，最高分，最低分，将分析结果组合后传入“分析结果”字段内，并生成时间</p>
<p>查询计划需要查询每一个课程（课程名称、课程授课教师）、描述、开始时间、结束时间、完成状态</p>
<h2 id="业务流程"><a href="#业务流程" class="headerlink" title="业务流程"></a>业务流程</h2><h3 id="用户注册登录模块"><a href="#用户注册登录模块" class="headerlink" title="用户注册登录模块"></a>用户注册登录模块</h3><ul>
<li><p>用户注册时，需要使用邮箱（email）进行注册，邮箱和用户名（account_name）已经被注册就不通过。满足所有条件后点击注册发送验证码给邮箱，输入的验证码验证码正确后将注册的邮箱、用户名、密码（password）存入数据库，赋予user权限（role），并将新用户信息插入到<strong>用户表</strong>（tim_accounts），生成注册时间（register_time）。</p>
</li>
<li><p>用户登录时，登录需要从用户表里取出用户名和密码进行登录验证，密码错误或用户名不存在都不能进入。</p>
</li>
<li><p>管理员权限账户，即权限为admin的账户无法直接创建，需要已经存在的管理员登录系统后，手动创建管理员账户。如果数据库不存在管理员则需要手动在数据库所在服务器内创建管理员账户。</p>
</li>
<li><p>用户以管理员登录时，可以进入“用户管理”界面，进入界面显示当前系统已经存在的所有用户，以账户名（account_name）、邮箱、权限、注册时间、是否可用（status）展示，按照id进行排序</p>
</li>
</ul>
<h3 id="成绩表管理模块"><a href="#成绩表管理模块" class="headerlink" title="成绩表管理模块"></a>成绩表管理模块</h3><ul>
<li>进入模块前，先展示当前所有成绩表信息，以姓名（student_name）、学号（student_number）、课程（course_name）、总分（total_num）、评价进行展示，按照学号由小到大排列，如果总分为空值，则计算对当前学生所有小题分（question_score）求和得到总分，如下图：</li>
</ul>
<table>
<thead>
<tr>
<th>姓名</th>
<th>学号</th>
<th>课程</th>
<th>总分</th>
<th>评价</th>
</tr>
</thead>
<tbody><tr>
<td>张三</td>
<td>100001</td>
<td>C语言程序设计</td>
<td>84</td>
<td>null</td>
</tr>
<tr>
<td>张三</td>
<td>100001</td>
<td>Python程序设计</td>
<td>78</td>
<td>null</td>
</tr>
<tr>
<td>李四</td>
<td>100002</td>
<td>C语言程序设计</td>
<td>60</td>
<td>null</td>
</tr>
<tr>
<td>李四</td>
<td>100002</td>
<td>Python程序设计</td>
<td>58</td>
<td>null</td>
</tr>
<tr>
<td>王五</td>
<td>100003</td>
<td>C语言程序设计</td>
<td>90</td>
<td>null</td>
</tr>
<tr>
<td>王五</td>
<td>100003</td>
<td>Python程序设计</td>
<td>72</td>
<td>null</td>
</tr>
</tbody></table>
<ul>
<li><p>导入方式分为手动导入和自动导入，手动导入需要按照姓名（student_name）、学号（student_number）、课程（course_name）、总分（total_num）进行插入。</p>
</li>
<li><p>自动导入成绩表前，需要先处理成绩表，将第一行的信息处理为姓名（student_name）、学号（student_number）、总分（total_num）、课程（course_name）后，转化为csv或excel文件导入，比如：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>姓名</th>
<th>学号</th>
<th>总分</th>
<th>课程</th>
</tr>
</thead>
<tbody><tr>
<td>张三</td>
<td>100001</td>
<td>84</td>
<td>C语言程序设计</td>
</tr>
<tr>
<td>李四</td>
<td>100002</td>
<td>60</td>
<td>C语言程序设计</td>
</tr>
<tr>
<td>王五</td>
<td>100003</td>
<td>90</td>
<td>C语言程序设计</td>
</tr>
</tbody></table>
<ul>
<li>如果提供的是小题分表，则需要关联小题分表，按照姓名、学号、小题名字（比如选择题第1题、选择题第2题等）、小题分值、得分情况、小题对应的课程、小题对应的知识点排列，比如：</li>
</ul>
<table>
<thead>
<tr>
<th>姓名</th>
<th>学号</th>
<th>小题目名</th>
<th>小题分值</th>
<th>得分情况</th>
<th>小题对应的课程</th>
<th>小题对应的知识点</th>
</tr>
</thead>
<tbody><tr>
<td>张三</td>
<td>100001</td>
<td>选择题第1题</td>
<td>2</td>
<td>0</td>
<td>C语言程序设计</td>
<td>指针</td>
</tr>
<tr>
<td>张三</td>
<td>100001</td>
<td>选择题第2题</td>
<td>2</td>
<td>2</td>
<td>C语言程序设计</td>
<td>宏</td>
</tr>
<tr>
<td>李四</td>
<td>100002</td>
<td>选择题第1题</td>
<td>2</td>
<td>2</td>
<td>C语言程序设计</td>
<td>指针</td>
</tr>
<tr>
<td>李四</td>
<td>100002</td>
<td>选择题第2题</td>
<td>2</td>
<td>2</td>
<td>C语言程序设计</td>
<td>宏</td>
</tr>
<tr>
<td>王五</td>
<td>100003</td>
<td>选择题第1题</td>
<td>2</td>
<td>0</td>
<td>C语言程序设计</td>
<td>指针</td>
</tr>
<tr>
<td>王五</td>
<td>100003</td>
<td>选择题第2题</td>
<td>2</td>
<td>0</td>
<td>C语言程序设计</td>
<td>宏</td>
</tr>
</tbody></table>
<h3 id="学生信息管理模块"><a href="#学生信息管理模块" class="headerlink" title="学生信息管理模块"></a>学生信息管理模块</h3><ul>
<li>模块首页需要分页展示所有学生的信息，以学号、姓名、性别、班级、联系方式，排序方式根据学号由小到大进行排序，比如：</li>
</ul>
<table>
<thead>
<tr>
<th>学号</th>
<th>姓名</th>
<th>性别</th>
<th>班级</th>
<th>联系方式（可以为空）</th>
</tr>
</thead>
<tbody><tr>
<td>100001</td>
<td>张三</td>
<td>男</td>
<td>20级计算机本科1班</td>
<td>131xxxxxxxx</td>
</tr>
<tr>
<td>100002</td>
<td>李四</td>
<td>男</td>
<td>20级计算机本科1班</td>
<td>189xxxxxxxx</td>
</tr>
<tr>
<td>100003</td>
<td>王五</td>
<td>男</td>
<td>20级计算机本科1班</td>
<td>156xxxxxxxx</td>
</tr>
</tbody></table>
<ul>
<li>导入学生信息分为手动导入和自动导入，手动导入需要按照学号、姓名、性别、班级、联系方式进行插入。</li>
<li>自动导入学生信息前，需求先处理成绩表，将第一行信息处理为学号、姓名、性别、班级、联系方式后，转化为csv或excel文件导入。</li>
</ul>
<h3 id="知识点管理模块"><a href="#知识点管理模块" class="headerlink" title="知识点管理模块"></a>知识点管理模块</h3><ul>
<li>进入模块，需要分页展示所有的知识点内容，以知识点名称、知识点描述、知识点对应课程顺序展示，不用关心排序</li>
</ul>
<table>
<thead>
<tr>
<th>知识点名称</th>
<th>知识点描述</th>
<th>知识点对应课程</th>
</tr>
</thead>
<tbody><tr>
<td>指针</td>
<td>xxxxxx</td>
<td>C语言程序设计</td>
</tr>
<tr>
<td>面向对象编程</td>
<td>xxxxxx</td>
<td>Java语言程序设计</td>
</tr>
<tr>
<td>SQL语句编写</td>
<td>xxxxxx</td>
<td>数据库设计基础</td>
</tr>
</tbody></table>
<ul>
<li>知识点需要手动进行定义，以知识点名称、知识点描述、知识点对应课程进行插入</li>
<li>如果小题分中有未被关联的知识点，需要进行关联。</li>
</ul>
<h3 id="成绩分析模块"><a href="#成绩分析模块" class="headerlink" title="成绩分析模块"></a>成绩分析模块</h3><ul>
<li>进入模块，第一个子模块成绩表分析，该模块将显示按照ID排列所有课程总分的平均分，最高分，最低分。平均分、最高分和最低分由成绩表得出，需要区分不同的科目对应的成绩分析结果</li>
<li>第二个子模块小题分表分析，该模块将以学生姓名、学号、所有的小题得分、同类题型小计（比如：“一、选择题(小计)”，“一、判断题(小计)”）、总分进行展示，按照学生学号由上到下排序，例如：</li>
</ul>
<table>
<thead>
<tr>
<th align="center">姓名</th>
<th align="center">学号</th>
<th align="center">一、选择题(1)</th>
<th align="center">一、选择题(2)</th>
<th align="center">一、选择题(3)</th>
<th align="center">一、选择题(4)</th>
<th align="center">一、选择题(5)</th>
<th align="center">一、选择题(6)</th>
<th align="center">一、选择题(7)</th>
<th align="center">一、选择题(8)</th>
<th align="center">一、选择题(9)</th>
<th align="center">一、选择题(10)</th>
<th>一、选择题(小计)</th>
<th align="center">二、判断题(1)</th>
<th align="center">二、判断题(2)</th>
<th align="center">二、判断题(3)</th>
<th align="center">二、判断题(4)</th>
<th align="center">二、判断题(5)</th>
<th align="center">二、判断题(6)</th>
<th align="center">二、判断题(7)</th>
<th align="center">二、判断题(8)</th>
<th align="center">二、判断题(9)</th>
<th align="center">二、判断题(10)</th>
<th align="center">二、判断题(小计)</th>
<th align="center">三、简答题(1)</th>
<th align="center">三、简答题(2)</th>
<th align="center">三、简答题(3)</th>
<th align="center">三、简答题(小计)</th>
<th align="center">四、综合题(1)</th>
<th align="center">四、综合题(2)</th>
<th align="center">四、综合题(3)</th>
<th align="center">四、综合题(4)</th>
<th align="center">四、综合题(小计)</th>
<th align="center">总分</th>
</tr>
</thead>
<tbody><tr>
<td align="center">张三</td>
<td align="center">100001</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">2</td>
<td>20</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">4</td>
<td align="center">8</td>
<td align="center">8</td>
<td align="center">8</td>
<td align="center">24</td>
<td align="center">12</td>
<td align="center">5</td>
<td align="center">3</td>
<td align="center">9</td>
<td align="center">29</td>
<td align="center">77</td>
</tr>
<tr>
<td align="center">李四</td>
<td align="center">100002</td>
<td align="center">2</td>
<td align="center">0</td>
<td align="center">2</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">2</td>
<td align="center">0</td>
<td align="center">2</td>
<td align="center">2</td>
<td>10</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">9</td>
<td align="center">8</td>
<td align="center">8</td>
<td align="center">5</td>
<td align="center">21</td>
<td align="center">12</td>
<td align="center">5</td>
<td align="center">0</td>
<td align="center">3</td>
<td align="center">20</td>
<td align="center">60</td>
</tr>
<tr>
<td align="center">王五</td>
<td align="center">100003</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">2</td>
<td>20</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">6</td>
<td align="center">8</td>
<td align="center">6</td>
<td align="center">8</td>
<td align="center">22</td>
<td align="center">12</td>
<td align="center">4</td>
<td align="center">6</td>
<td align="center">9</td>
<td align="center">31</td>
<td align="center">79</td>
</tr>
<tr>
<td align="center">赵六</td>
<td align="center">100004</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">2</td>
<td>20</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">8</td>
<td align="center">8</td>
<td align="center">2</td>
<td align="center">8</td>
<td align="center">18</td>
<td align="center">0</td>
<td align="center">5</td>
<td align="center">6</td>
<td align="center">9</td>
<td align="center">20</td>
<td align="center">66</td>
</tr>
</tbody></table>
<ul>
<li>根据已经排列出来的小题分表分析结果，统计小题对应课程和知识点，记录每小题平均分，着重展示平均分最低的小题分和最高的小题分，点击生成分析按钮后，生成分析结果和分析时间</li>
</ul>
<h3 id="教学改进计划模块"><a href="#教学改进计划模块" class="headerlink" title="教学改进计划模块"></a>教学改进计划模块</h3><ul>
<li><p>进入模块，选择一门课程，展示包含的知识点、知识点平均分、分析时间，按照由小到大排列</p>
</li>
<li><p>选择一个生成的成绩分析报告，点击指定改进计划，手动输入计划的内容描述、计划预计开始时间、计划预计结束时间，自动生成计划制定时间。</p>
</li>
</ul>
<p>Docker配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">minio:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">minio/minio</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">Minio</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="comment"># api 端口</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;9000:9000&quot;</span></span><br><span class="line">      <span class="comment"># 控制台端口</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;9001:9001&quot;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="comment"># 时区上海</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">      <span class="comment"># 管理后台用户名</span></span><br><span class="line">      <span class="attr">MINIO_ROOT_USER:</span> <span class="string">Tim_Brown</span></span><br><span class="line">      <span class="comment"># 管理后台密码，最小8个字符</span></span><br><span class="line">      <span class="attr">MINIO_ROOT_PASSWORD:</span> <span class="string">tim2002</span></span><br><span class="line">      <span class="comment"># https需要指定域名</span></span><br><span class="line">      <span class="comment">#MINIO_SERVER_URL: &quot;https://xxx.com:9000&quot;</span></span><br><span class="line">      <span class="comment">#MINIO_BROWSER_REDIRECT_URL: &quot;https://xxx.com:9001&quot;</span></span><br><span class="line">      <span class="comment"># 开启压缩 on 开启 off 关闭</span></span><br><span class="line">      <span class="attr">MINIO_COMPRESS:</span> <span class="string">&quot;off&quot;</span></span><br><span class="line">      <span class="comment"># 扩展名 .pdf,.doc 为空 所有类型均压缩</span></span><br><span class="line">      <span class="attr">MINIO_COMPRESS_EXTENSIONS:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">      <span class="comment"># mime 类型 application/pdf 为空 所有类型均压缩</span></span><br><span class="line">      <span class="attr">MINIO_COMPRESS_MIME_TYPES:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="comment"># 映射当前目录下的data目录至容器内/data目录</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/docker/minio/data:/data</span></span><br><span class="line">      <span class="comment"># 映射配置目录</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/docker/minio/config:/root/.minio/</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">server</span> <span class="string">--address</span> <span class="string">&#x27;:9000&#x27;</span> <span class="string">--console-address</span> <span class="string">&#x27;:9001&#x27;</span> <span class="string">/data</span>  <span class="comment"># 指定容器中的目录 /data</span></span><br><span class="line">    <span class="attr">privileged:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">&quot;host&quot;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>设计</category>
        <category>毕业设计</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringBoot</tag>
        <tag>Vue</tag>
        <tag>MySQL</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>VMware Workstation Pro个人免费使用的方法</title>
    <url>/p/33b4809e/</url>
    <content><![CDATA[<p>内容正在迁移，在未来的某个时间将完成！</p>
]]></content>
  </entry>
  <entry>
    <title>VMware虚拟机安装Ubuntu 24.04(解决卡顿问题)</title>
    <url>/p/f0cf13c8/</url>
    <content><![CDATA[<p>内容正在迁移，在未来的某个时间将完成！</p>
]]></content>
  </entry>
  <entry>
    <title>VMware虚拟机安装Windows 11 24H2(无微软账号版)</title>
    <url>/p/5bbf2125/</url>
    <content><![CDATA[<p>内容正在迁移，在未来的某个时间将完成！</p>
]]></content>
  </entry>
  <entry>
    <title>Windows 11 24H2新版本禁用基于虚拟化的安全性(VBS)</title>
    <url>/p/e68459bb/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Windows 11已经更新到24H2版本，更新内容详见<a href="https://learn.microsoft.com/zh-cn/windows/whats-new/whats-new-windows-11-version-24h2">此处</a></p>
<p>目前已经可以在Windows 11下载界面中获取对应iso文件</p>
<p>没有收到更新推送也可以通过 <a href="https://www.microsoft.com/zh-cn/software-download/windows11">“Windows 安装助手”</a> 获取</p>
<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>除了已知的一些问题（部分可能得到了解决，详情见<a href="https://learn.microsoft.com/zh-cn/windows/release-health/status-windows-11-24h2">此链接</a>）以外</p>
<p>此次更新使得“<a href="https://learn.microsoft.com/zh-cn/windows-hardware/design/device-experiences/oem-vbs">基于虚拟化的安全性</a>”(VBS)以及“内存完整性”被强制开启</p>
<p>众所周知，此功能的开启对游戏性能的影响比较大，而且会造成部分第三方虚拟机以及模拟器软件无法运行</p>
<p>甚至遇到电脑在正常运行过程中卡顿的情况，非常影响工作学习效率和游戏体验</p>
<h2 id="如何确定开启了此功能"><a href="#如何确定开启了此功能" class="headerlink" title="如何确定开启了此功能"></a>如何确定开启了此功能</h2><p>按下Windows徽标按键+R字母 组合按键，弹出如下窗口：</p>
<p><img src="https://s2.loli.net/2024/10/15/98KI1aiLhWGvFNO.png" alt="运行窗口"></p>
<p>如果不知道怎么操作可以使用搜索框搜索，并找到这个，左键点击也会弹出跟上面一样的窗口：</p>
<p><img src="https://s2.loli.net/2024/10/15/CdMIwOaqbcLh68m.png" alt="Windows搜索栏搜索运行"></p>
<p>然后在运行窗口的栏目中输入<code>msinfo32</code> 后，点击确定</p>
<p><img src="https://s2.loli.net/2024/10/15/JDoLWy3eOEUKc4a.png" alt="运行窗口输入内容"></p>
<p>然后会弹出一个这样的窗口：</p>
<p><img src="https://s2.loli.net/2024/10/15/zW5MGquUyovJX6t.png" alt="系统信息窗口"></p>
<p>直接往下翻，找到一个名为 <code>基于虚拟化的安全性</code> 这个选项，可以看到其显示为“正在运行”状态：</p>
<p><img src="https://s2.loli.net/2024/10/15/7k1cNYW3uSomLts.png" alt="系统信息窗口显示"></p>
<p>如果你跟我显示为已关闭，但依然遇到与“基于虚拟化的安全性”相关问题，请你继续阅读本教程</p>
<h2 id="如何关闭"><a href="#如何关闭" class="headerlink" title="如何关闭"></a>如何关闭</h2><p><strong>警告！</strong>此功能将会关闭Windows 11自带虚拟机 <code>Hyper-V</code>，如果你有使用到此虚拟机或者使用了Windows下的安卓子系统，请备份相关数据防止丢失</p>
<p>如果没有可以无视此警告</p>
<h3 id="方法一、使用cmd命令行"><a href="#方法一、使用cmd命令行" class="headerlink" title="方法一、使用cmd命令行"></a>方法一、使用cmd命令行</h3><p><strong>警告！</strong>在你执行此操作前，请保存你的工作，防止数据丢失</p>
<p>右键Windows开始菜单，选择“终端管理员”</p>
<p><img src="https://s2.loli.net/2024/10/15/l48SZaKAVDIkhNQ.png" alt="Windows开始菜单"></p>
<p>PS：如果你开始菜单没有此选项，请使用搜索框搜索cmd，直到弹出如下内容</p>
<p><img src="https://s2.loli.net/2024/10/15/fcpoEhPus5OU86z.png" alt="搜索框搜索cmd"></p>
<p>请你再右边选择“以管理员身份运行”</p>
<p><img src="https://s2.loli.net/2024/10/15/fv3CuzeLHiaIxEm.png" alt="以管理员身份运行cmd"></p>
<p>无论你使用那个方法，此时应该都会弹出一个窗口“你要允许此应用对你的设备进行更改吗”，选择“是”</p>
<p>如果没有弹出“你要允许此应用对你的设备进行更改吗”这个窗口，请确定是否选择“终端管理员”或“以管理员身份运行”。依旧没有弹出请继续往下看。</p>
<p>此时会弹出一个黑色命令行一样的窗口：<img src="https://s2.loli.net/2024/10/15/ry2VRY7iZJcbHga.png" alt="Windows终端"></p>
<p>也可能是这样的窗口：</p>
<p><img src="https://s2.loli.net/2024/10/15/oiP1DaHgKJEFWAb.png" alt="cmd窗口"></p>
<p>这些都无关紧要，请确保你左上角的窗口标题显示了“管理员”三个字就行</p>
<p>复制以下命令，粘贴在终端中，并按回车，直到执行完成：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">dism /Online /Disable-Feature:microsoft-hyper-v-all /NoRestart</span><br><span class="line">dism /Online /Disable-Feature:IsolatedUserMode /NoRestart</span><br><span class="line">dism /Online /Disable-Feature:Microsoft-Hyper-V-Hypervisor /NoRestart</span><br><span class="line">dism /Online /Disable-Feature:Microsoft-Hyper-V-Online /NoRestart</span><br><span class="line">dism /Online /Disable-Feature:HypervisorPlatform /NoRestart</span><br><span class="line"></span><br><span class="line">mountvol X: /s</span><br><span class="line"><span class="built_in">copy</span> <span class="variable">%WINDIR%</span>\System32\SecConfig.efi X:\EFI\Microsoft\Boot\SecConfig.efi /Y</span><br><span class="line">bcdedit /create &#123;<span class="number">0</span>cb3b571-<span class="number">2</span>f2e-<span class="number">4343</span>-a879-d86a476d7215&#125; /d &quot;DebugTool&quot; /application osloader</span><br><span class="line">bcdedit /<span class="built_in">set</span> &#123;<span class="number">0</span>cb3b571-<span class="number">2</span>f2e-<span class="number">4343</span>-a879-d86a476d7215&#125; <span class="built_in">path</span> &quot;\EFI\Microsoft\Boot\SecConfig.efi&quot;</span><br><span class="line">bcdedit /<span class="built_in">set</span> &#123;bootmgr&#125; bootsequence &#123;<span class="number">0</span>cb3b571-<span class="number">2</span>f2e-<span class="number">4343</span>-a879-d86a476d7215&#125;</span><br><span class="line">bcdedit /<span class="built_in">set</span> &#123;<span class="number">0</span>cb3b571-<span class="number">2</span>f2e-<span class="number">4343</span>-a879-d86a476d7215&#125; loadoptions DISABLE-LSA-ISO,DISABLE-VBS</span><br><span class="line">bcdedit /<span class="built_in">set</span> &#123;<span class="number">0</span>cb3b571-<span class="number">2</span>f2e-<span class="number">4343</span>-a879-d86a476d7215&#125; device partition=X:</span><br><span class="line">mountvol X: /d</span><br><span class="line">bcdedit /<span class="built_in">set</span> hypervisorlaunchtype off</span><br></pre></td></tr></table></figure>

<p>执行完成后，先不要关机，继续阅读本文章</p>
<p>后面会详细告诉你如何操作，请你跳过方法二阅读 “重启电脑” 这一小结</p>
<h3 id="方法二、使用现成的bat文件"><a href="#方法二、使用现成的bat文件" class="headerlink" title="方法二、使用现成的bat文件"></a>方法二、使用现成的bat文件</h3><p>如果不会进行操作，或者担心自己搞砸，那么你可以使用我提供好的bat文件执行对应操作</p>
<p><a href="/resource/Disable_VBS.bat">点击此处就可以进行下载</a></p>
<p>下载完成后会得到这样一个文件：<img src="https://s2.loli.net/2024/10/15/McLYU1N6wRIAhpl.png" alt="bat文件">大小为1.13KB，注意检查一下</p>
<p>请将这个文件放在一个没有中文路径的文件夹下，右键此文件，点击“以管理员身份运行”：</p>
<p><img src="https://s2.loli.net/2024/10/15/uhKYx5z6iPdpL7f.png" alt="右键点击文件后"></p>
<p>此时应该都会弹出一个窗口“你要允许此应用对你的设备进行更改吗”，选择“是”</p>
<p>此时也会弹出一个黑色的命令行窗口，先不用操作，等他弹出“当前操作已完成，接下来请关闭此窗口并重启电脑，然后根据屏幕提示完成剩下操作”时，确保你保存了工作文件后，重启电脑。</p>
<p>如果没有弹出“你要允许此应用对你的设备进行更改吗”这个窗口，而是直接出现黑色的终端文件，请确定是否选择“终端管理员”或“以管理员身份运行”。依旧没有弹出，但依旧显示了一个黑色的命令行窗口，请你等待一段时间</p>
<h3 id="重启电脑"><a href="#重启电脑" class="headerlink" title="重启电脑"></a>重启电脑</h3><p>完成以上操作后，重启电脑，当刚刚显示电脑的品牌徽标或者是主板厂商的徽标时候，会弹出一个全英文的界面：</p>
<p><img src="https://s2.loli.net/2024/10/15/7r9MQnPXzlfo8V4.png" alt="全英文界面"></p>
<p>这个界面是询问你是否要关闭。此时，你需要按键盘顶上的 <code>F3</code> 按键进行确认，需要按 <code>F3</code> 按键确认四次，直到电脑完全黑屏，然后电脑会自动重启。</p>
<h2 id="确认是否关闭"><a href="#确认是否关闭" class="headerlink" title="确认是否关闭"></a>确认是否关闭</h2><p>还是用同样的方法，按下Windows徽标按键+R字母 组合按键或使用搜索框搜索 “运行” ，弹出运行窗口</p>
<p>输入<code>msinfo32</code> 后点击确定，找到 <code>基于虚拟化的安全性</code> 这个选项，其显示为“未启用”状态即代表已经关闭</p>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><p><strong>无法下载bat文件或者bat文件报毒怎么办？</strong></p>
<p>bat文件无毒，请放心。如果出现杀毒软件报毒请确保bat文件的大小是否正常。</p>
<p>实在不行可以用命令行输入命令执行</p>
<p><strong>Window 10可以使用这个方法关闭VBS吗</strong></p>
<p>可以，但没必要</p>
<p><strong>如果我反悔了，想要重新启动此功能怎么办？</strong></p>
<p>使用以下命令恢复：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">dism /Online /Enable-Feature:microsoft-hyper-v-all /NoRestart</span><br><span class="line">dism /Online /Enable-Feature:IsolatedUserMode /NoRestart</span><br><span class="line">dism /Online /Enable-Feature:Microsoft-Hyper-V-Hypervisor /NoRestart</span><br><span class="line">dism /Online /Enable-Feature:Microsoft-Hyper-V-Online /NoRestart</span><br><span class="line">dism /Online /Enable-Feature:HypervisorPlatform /NoRestart</span><br><span class="line">bcdedit /delete &#123;<span class="number">0</span>cb3b571-<span class="number">2</span>f2e-<span class="number">4343</span>-a879-d86a476d7215&#125;</span><br><span class="line">bcdedit /<span class="built_in">set</span> hypervisorlaunchtype auto</span><br></pre></td></tr></table></figure>



<p><strong>用了一段时间自己自动打开了怎么办？</strong></p>
<p>一般情况下不会自动打开，除非你重新安装了Windows 11或者是通过官方的升级工具进行了升级，这种情况你就再跟着教程走一遍</p>
<p><strong>关闭了之后，电脑密码不见了怎么办</strong></p>
<p>如果你的电脑有注册并登录了微软账号（打开设置，找到左上角头像，显示了你的邮箱信息代表使用了微软账号登录），并且设置了PIN码，经过以上设置之后可能会让PIN码失效，此时你按照系统设置的提示重新登录微软账号，然后重新设置PIN码</p>
<p><strong>关闭了之后，Windows安全中心冒感叹号提示”内存完整性已关闭，xxxxxx“怎么办？</strong></p>
<p>不用管，直接忽略</p>
<p>如有其他问题，请直接加入我的QQ群：</p>
<p><img src="https://s2.loli.net/2024/10/15/46pms9HXrRvJNfh.png" alt="qrcode_1728935364123"></p>
]]></content>
      <categories>
        <category>Windows</category>
        <category>优化</category>
      </categories>
      <tags>
        <tag>Windows 11</tag>
        <tag>新版更新</tag>
        <tag>cmd</tag>
      </tags>
  </entry>
  <entry>
    <title>关于此博客</title>
    <url>/p/22860/</url>
    <content><![CDATA[<h2 id="重要变更"><a href="#重要变更" class="headerlink" title="重要变更"></a>重要变更</h2><p>本博客已换源并重新构建，曾有的所有博文已归档</p>
<p>如果需要查看历史博文请前往博客所对应的Github项目中其他分支中寻找</p>
<p>任何问题可提交Issues或通过主页的联系方式</p>
<p>新的博文将会继续增加，并一直保存</p>
<p>博客已就绪！</p>
<p><img src="https://s2.loli.net/2024/10/14/Q4GUXvmt7Nu1onl.jpg"></p>
<h2 id="一切的开始"><a href="#一切的开始" class="headerlink" title="一切的开始"></a>一切的开始</h2><p>第一次构建和使用属于自己的博客，花费了一天的时间，从创建博客库，到拉取博客页面模板，到编写博客基本配置文件，再到赋予域名解析，以及最后的写下此文档</p>
<p>真是难以掩盖的激动</p>
<p>如果没有任何意外情况，此博客将会一直存在，并且任何人都可以访问</p>
<p>博客的半永久地址为: </p>
<p><strong>blog.timbrown.top</strong>（2023-8-26，已切换至Gitee Page；2024-10-1 重新切换为Github Page并重构项目；2024-10-14完成项目的所有基础构建）</p>
<p><strong>albus-tim-brown.github.io</strong> (如遇域名解析故障可通过此链接访问)</p>
<p><strong><del>albus-tim-brown.gitee.io</del></strong> (由于Gitee关闭了Gitee Page服务，暂且没有恢复的可能性，所有基于Gitee Page的博客废弃，文章核心内容同步在新博客内)</p>
<p><del><strong>backend.timbrown.top</strong></del> (博客后台管理系统，目前已停止在公网部署)</p>
<p>如果域名到期，将会提前使用和说明</p>
]]></content>
      <categories>
        <category>Introduction</category>
      </categories>
      <tags>
        <tag>Introduction</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-Study</title>
    <url>/p/963c44af/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>学习本文的前提：熟悉掌握JavaSE</p>
<p>设计模式：要求很好的可扩展性、可维护性、可重用性。高内聚低耦合。</p>
<p>概念  设计模式的七种设计原则  创建型模式（单例模式、工厂模式、原型模式等）  结构型模式（适配器模式、装饰模式、组合模式、外观模式等）   行为型模式（观察者模式、解释器模式、迭代器模式、命令模式等）共 23 种设计模式。</p>
<p>本文最初修改时间：2022年10月27日 星期四 </p>
<p>由课堂总结完成</p>
<p>内容篇幅较长同时需要阅读更多前置内容</p>
 <span id="more"></span>

<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="一、设计模式的重要性："><a href="#一、设计模式的重要性：" class="headerlink" title="一、设计模式的重要性："></a>一、设计模式的重要性：</h2><p>在软件开发中，设计模式是对软件设计中普遍存在（反复出现）的各种问题所提出的解决方案。</p>
<p>在项目开发过程中，客户会提出新增功能或修改功能的要求。</p>
<p>开发项目的员工离职，需要另一个员工维护该员工的项目。（可读性、规范性）</p>
<h2 id="二、学习设计模式的目的："><a href="#二、学习设计模式的目的：" class="headerlink" title="二、学习设计模式的目的："></a>二、学习设计模式的目的：</h2><p>1、可扩展性。新增功能很方便。</p>
<p>2、可维护性。阅读代码、修改代码很方便。</p>
<p>3、可重用性。相同的代码尽可能保持一份。</p>
<p>4、代码呈现高内聚，低耦合的特性。</p>
<h2 id="三、UML图：（重点）"><a href="#三、UML图：（重点）" class="headerlink" title="三、UML图：（重点）"></a>三、UML图：（重点）</h2><p>UML：Unified  Modeling  Language   统一建模语言。</p>
<p>UML图描述类和接口的结构，以及类与类、类与接口、接口与接口之间的关系。</p>
<p>例子：</p>
<img src="C:\Users\wangchao\AppData\Roaming\Typora\typora-user-images\image-20220829174745299.png" alt="image-20220829174745299" style="zoom:50%;" />

<p>class  Person{</p>
<p>​	public int id；</p>
<p>​	protected String name；</p>
<p>​	private char sex;</p>
<p>​	float score;</p>
<p>​	public void add(int a, int b){}</p>
<p>}</p>
<img src="C:\Users\wangchao\AppData\Roaming\Typora\typora-user-images\image-20220829180131280.png" alt="image-20220829180131280" style="zoom:50%;" />

<p>interface  USB{</p>
<p>​	int WIDTH &#x3D; 10;</p>
<p>​	int HEIGHT &#x3D; 10;</p>
<p>​	void sendData();</p>
<p>​	void recieveData();</p>
<p>}</p>
<p>作业：绘制类和接口的UML图，根据UML图编写对应的java程序。</p>
<p>UML图描述类与类之间的关系：</p>
<p>​														<strong>代码													uml</strong></p>
<p><strong>依赖关系：					类中方法参数是类类型			   虚线箭头，箭头指向形参类型</strong></p>
<p><strong>继承关系（泛化关系）：子类   extends  父类				实线空心箭头，箭头指向父类</strong></p>
<p><strong>继承关系是 “是”的关系</strong></p>
<p><strong>实现关系：					类  implements  接口				 虚线空心箭头，箭头指向接口</strong></p>
<p><strong>实现关系是 “能”的关系</strong></p>
<p><strong>聚合关系：				 类中的成员变量是类类型，		实线空心菱形，菱形指向拥有该类的类</strong></p>
<p>​									<strong>可以使用另一个对象初始化</strong></p>
<p><strong>组合关系：				 类中的成员变量是类类型，		实线实心菱形，菱形指向拥有该类的类</strong></p>
<p>​									<strong>通过new对象进行初始化</strong></p>
<p><strong>聚合关系 和 组合关系 是 “有”的关系</strong></p>
<p>作业：</p>
<p>1、抄写类与类之间的关系。</p>
<p>2、画出氧气、动物、鸟、翅膀、大雁、飞翔、雁群之间的关系。</p>
<h2 id="四、设计模式的七种设计原则：（重点）"><a href="#四、设计模式的七种设计原则：（重点）" class="headerlink" title="四、设计模式的七种设计原则：（重点）"></a>四、设计模式的七种设计原则：（重点）</h2><p>提出实际需求—-传统思路解决问题—-存在问题—-引出设计模式—-原理分析—–UML图—-使用某种设计模式解决问题</p>
<h3 id="1、七种设计原则："><a href="#1、七种设计原则：" class="headerlink" title="1、七种设计原则："></a>1、七种设计原则：</h3><p>1.1、单一职责原则</p>
<p>1.2、依赖倒置原则</p>
<p>1.3、接口隔离原则：</p>
<p>1.4、里氏替换原则：</p>
<p>1.5、开闭原则：</p>
<p>1.6、迪米特法则：</p>
<p>1.7、合成复用原则：</p>
<h3 id="2、单一职责原则："><a href="#2、单一职责原则：" class="headerlink" title="2、单一职责原则："></a>2、单一职责原则：</h3><p>一个类只负责一个职责。降低类的复杂度。</p>
<p>例子：</p>
<p>定义类实现空中、陆地、水中交通工具的移动功能。</p>
<p>扩展功能：增加太空交通工具移动功能；</p>
<p>修改功能：修改水中交通工具的移动功能。</p>
<p>解决方案：定义空中交通工具类、陆地交通工具类、水中交通工具类。</p>
<h3 id="3、依赖倒置原则："><a href="#3、依赖倒置原则：" class="headerlink" title="3、依赖倒置原则："></a>3、依赖倒置原则：</h3><p>依赖倒置的中心思想是面向接口编程。</p>
<p>使用接口或抽象类的目的是指定好功能和规范，而不设计任何具体的操作，把展现细节的任务交给他们的实现类去完成。</p>
<p>例子：</p>
<p>微信：发送数据的功能。</p>
<p>人：接收数据的功能。接收微信对象发送的数据，并打印数据。</p>
<p>扩展功能：增加QQ、电话</p>
<p>解决方法：定义发送数据接口，微信、QQ、电话实现该接口，人的接收数据方法的参数为接口类型。</p>
<h3 id="4、接口隔离原则："><a href="#4、接口隔离原则：" class="headerlink" title="4、接口隔离原则："></a>4、接口隔离原则：</h3><p>将一个接口拆分成多个接口，不同的类与他们所需要的接口建立依赖关系。</p>
<p>例子：</p>
<p>出租车公司–work()、游艇公司–work()、航空公司–work()、白宫–work() 、一个接口</p>
<p>传统：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface Power&#123;</span><br><span class="line">    public void car();</span><br><span class="line">    public void ship();</span><br><span class="line">    public void plane();</span><br><span class="line">&#125;</span><br><span class="line">//创建人</span><br><span class="line">class CarPerson implements Power&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void car() &#123;</span><br><span class="line">        System.out.println(&quot;我会开车&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void ship() &#123;&#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void plane() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ShipPerson implements Power&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void car() &#123;&#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void ship() &#123;</span><br><span class="line">        System.out.println(&quot;我会开船&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void plane() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class PlanePerson implements Power&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void car() &#123;&#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void ship() &#123;&#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void plane() &#123;</span><br><span class="line">        System.out.println(&quot;我会开飞机&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class BaobiaoPerson implements Power&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void car() &#123;</span><br><span class="line">        System.out.println(&quot;我会开车&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void ship() &#123;</span><br><span class="line">        System.out.println(&quot;我会开船&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void plane() &#123;</span><br><span class="line">        System.out.println(&quot;我会开飞机&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//创建公司</span><br><span class="line">class CarCompant&#123;</span><br><span class="line">    public void work(Power power)&#123;</span><br><span class="line">        power.car();</span><br><span class="line">        System.out.println(&quot;这个人会开车，出租车公司正常运营&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ShipCompant&#123;</span><br><span class="line">    public void work(Power power)&#123;</span><br><span class="line">        power.ship();</span><br><span class="line">        System.out.println(&quot;这个人会开船，船务公司公司正常运营&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class PlaneCompant&#123;</span><br><span class="line">    public void work(Power power)&#123;</span><br><span class="line">        power.plane();</span><br><span class="line">        System.out.println(&quot;这个人会开飞机，航空公司正常运营&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class BaobiaorCompant&#123;</span><br><span class="line">    public void work(Power power)&#123;</span><br><span class="line">        power.car();</span><br><span class="line">        power.ship();</span><br><span class="line">        power.plane();</span><br><span class="line">        System.out.println(&quot;这个人会开车、快船、开飞机，保镖公司公司正常运营&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class MyTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //创建公司</span><br><span class="line">        CarCompant carCompant = new CarCompant();</span><br><span class="line">        ShipCompant shipCompant = new ShipCompant();</span><br><span class="line">        PlaneCompant planeCompant = new PlaneCompant();</span><br><span class="line">        BaobiaorCompant baobiaorCompant = new BaobiaorCompant();</span><br><span class="line"></span><br><span class="line">        //创建人</span><br><span class="line">        CarPerson carPerson = new CarPerson();</span><br><span class="line">        ShipPerson shipPerson = new ShipPerson();</span><br><span class="line">        PlanePerson planePerson = new PlanePerson();</span><br><span class="line">        BaobiaoPerson baobiaoPerson = new BaobiaoPerson();</span><br><span class="line"></span><br><span class="line">        //公司运转</span><br><span class="line">        carCompant.work(carPerson);</span><br><span class="line">        shipCompant.work(shipPerson);</span><br><span class="line">        planeCompant.work(planePerson);</span><br><span class="line">        baobiaorCompant.work(baobiaoPerson);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口隔离原则：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//创建接口</span><br><span class="line">interface CarPower&#123;</span><br><span class="line">    public void car();</span><br><span class="line">&#125;</span><br><span class="line">interface ShipPower&#123;</span><br><span class="line">    public void ship();</span><br><span class="line">&#125;</span><br><span class="line">interface PlanePower&#123;</span><br><span class="line">    public void plane();</span><br><span class="line">&#125;</span><br><span class="line">interface AllPower extends CarPower, ShipPower, PlanePower&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//创建人</span><br><span class="line">class CarPerson implements CarPower &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void car() &#123;</span><br><span class="line">        System.out.println(&quot;我会开车&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ShipPerson implements ShipPower&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void ship() &#123;</span><br><span class="line">        System.out.println(&quot;我会开船&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class PlanePerson implements PlanePower&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void plane() &#123;</span><br><span class="line">        System.out.println(&quot;我会开飞机&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class BaobiaoPerson implements AllPower&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void car() &#123;</span><br><span class="line">        System.out.println(&quot;我会开车&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void ship() &#123;</span><br><span class="line">        System.out.println(&quot;我会开船&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void plane() &#123;</span><br><span class="line">        System.out.println(&quot;我会开飞机&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//创建公司</span><br><span class="line">class CarCompant&#123;</span><br><span class="line">    public void work(CarPower power)&#123;</span><br><span class="line">        power.car();</span><br><span class="line">        System.out.println(&quot;这个人会开车，出租车公司正常运营&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ShipCompant&#123;</span><br><span class="line">    public void work(ShipPower power)&#123;</span><br><span class="line">        power.ship();</span><br><span class="line">        System.out.println(&quot;这个人会开船，船务公司公司正常运营&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class PlaneCompant&#123;</span><br><span class="line">    public void work(PlanePower power)&#123;</span><br><span class="line">        power.plane();</span><br><span class="line">        System.out.println(&quot;这个人会开飞机，航空公司正常运营&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class BaobiaorCompant&#123;</span><br><span class="line">    public void work(AllPower power)&#123;</span><br><span class="line">        power.car();</span><br><span class="line">        power.ship();</span><br><span class="line">        power.plane();</span><br><span class="line">        System.out.println(&quot;这个人会开车、快船、开飞机，保镖公司公司正常运营&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MyTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //创建公司</span><br><span class="line">        CarCompant carCompant = new CarCompant();</span><br><span class="line">        ShipCompant shipCompant = new ShipCompant();</span><br><span class="line">        PlaneCompant planeCompant = new PlaneCompant();</span><br><span class="line">        BaobiaorCompant baobiaorCompant = new BaobiaorCompant();</span><br><span class="line"></span><br><span class="line">        //创建人</span><br><span class="line">        CarPerson carPerson = new CarPerson();</span><br><span class="line">        ShipPerson shipPerson = new ShipPerson();</span><br><span class="line">        PlanePerson planePerson = new PlanePerson();</span><br><span class="line">        BaobiaoPerson baobiaoPerson = new BaobiaoPerson();</span><br><span class="line"></span><br><span class="line">        //公司运转</span><br><span class="line">        carCompant.work(carPerson);</span><br><span class="line">        shipCompant.work(shipPerson);</span><br><span class="line">        planeCompant.work(planePerson);</span><br><span class="line">        baobiaorCompant.work(baobiaoPerson);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="5、里氏替换原则："><a href="#5、里氏替换原则：" class="headerlink" title="5、里氏替换原则："></a>5、里氏替换原则：</h3><p>在使用继承的时候，在子类中尽量不要重写父类中的方法。</p>
<p>以便做的 所有引用父类的地方必须能够透明的使用其子类对象。</p>
<p>在适当的情况下，通过提取接口或抽象类、聚合、组合的方法解决问题。</p>
<p>例子：</p>
<p>一个A类，计算加法，计算乘法；另一个B类继承A类，对A中计算加法的方法重写。</p>
<p>传统：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">    public int count(int a, int b)&#123;</span><br><span class="line">        return a + b;</span><br><span class="line">    &#125;</span><br><span class="line">    public int factor(int a)&#123;</span><br><span class="line">        int total = 1;</span><br><span class="line">        for (int i=2; i&lt;=a; i++)&#123;</span><br><span class="line">            total *= i;</span><br><span class="line">        &#125;</span><br><span class="line">        return total;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class B extends A&#123;</span><br><span class="line">    public int count(int a, int b)&#123;</span><br><span class="line">        return a - b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class MyTest &#123;</span><br><span class="line">    static void f(A oa)&#123;</span><br><span class="line">        int i = oa.count(3, 4);</span><br><span class="line">        System.out.println(&quot;3+4=&quot; + i);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        A oa = new A();</span><br><span class="line">        B ob = new B();</span><br><span class="line">        f(oa);</span><br><span class="line">        f(ob);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>里氏替换：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface Count&#123;</span><br><span class="line">    public int count(int a, int b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class A implements Count&#123;</span><br><span class="line">    public int count(int a, int b)&#123;</span><br><span class="line">        return a + b;</span><br><span class="line">    &#125;</span><br><span class="line">    public int factor(int a)&#123;</span><br><span class="line">        int total = 1;</span><br><span class="line">        for (int i=2; i&lt;=a; i++)&#123;</span><br><span class="line">            total *= i;</span><br><span class="line">        &#125;</span><br><span class="line">        return total;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B implements Count&#123;</span><br><span class="line">    public int count(int a, int b)&#123;</span><br><span class="line">        return a - b;</span><br><span class="line">    &#125;</span><br><span class="line">    A oa = new A();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MyTest &#123;</span><br><span class="line">    static void f(A oa)&#123;</span><br><span class="line">        int i = oa.count(3, 4);</span><br><span class="line">        System.out.println(&quot;3+4=&quot; + i);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        A oa = new A();</span><br><span class="line">        B ob = new B();</span><br><span class="line"></span><br><span class="line">        f(oa);</span><br><span class="line">        //f(ob)</span><br><span class="line"></span><br><span class="line">        int a = ob.oa.factor(5);</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="6、开闭原则："><a href="#6、开闭原则：" class="headerlink" title="6、开闭原则："></a>6、开闭原则：</h3><p>模块和函数应该对扩展开发，对修改关闭，用抽象构建框架，用实现扩展细节。</p>
<p>当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。</p>
<p>编程中遵循其他原则，以及使用设计模式的目的就是遵循开闭原则。</p>
<p>问题：打印形状。打印圆形、方形、矩形。扩展：打印三角形。</p>
<p>传统：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class ShapeOper&#123;</span><br><span class="line">    public void printShape(int sort)&#123;</span><br><span class="line">        switch (sort)&#123;</span><br><span class="line">            case 1:</span><br><span class="line">                System.out.println(&quot;打印圆形&quot;);</span><br><span class="line">                break;</span><br><span class="line">            case 2:</span><br><span class="line">                System.out.println(&quot;打印方形&quot;);</span><br><span class="line">                break;</span><br><span class="line">            case 3:</span><br><span class="line">                System.out.println(&quot;打印矩形&quot;);</span><br><span class="line">                break;</span><br><span class="line">            case 4:</span><br><span class="line">                System.out.println(&quot;打印三角形&quot;);</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class MyTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ShapeOper shapeOper = new ShapeOper();</span><br><span class="line">        shapeOper.printShape(1);</span><br><span class="line">        shapeOper.printShape(2);</span><br><span class="line">        shapeOper.printShape(3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>开闭原则：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface PrintShape &#123;</span><br><span class="line">    public void draw();</span><br><span class="line">&#125;</span><br><span class="line">class 圆形 implements PrintShape&#123;</span><br><span class="line">    public void draw() &#123;</span><br><span class="line">        System.out.println(&quot;画了一个圆形&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class 矩形 implements PrintShape&#123;</span><br><span class="line">    public void draw() &#123;</span><br><span class="line">        System.out.println(&quot;画了一个矩形&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class 方形 implements PrintShape&#123;</span><br><span class="line">    public void draw() &#123;</span><br><span class="line">        System.out.println(&quot;画了一个方形&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class ShapeOper&#123;</span><br><span class="line">    public void print(PrintShape printShape)&#123;</span><br><span class="line">        printShape.draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class 三角形 implements PrintShape&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void draw() &#123;</span><br><span class="line">        System.out.println(&quot;打印三角形&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MyTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ShapeOper shapeOper = new ShapeOper();</span><br><span class="line">        圆形 yuan = new 圆形();</span><br><span class="line">        方形 fang = new 方形();</span><br><span class="line">        矩形 ju = new 矩形();</span><br><span class="line">        三角形 san = new 三角形();</span><br><span class="line">        shapeOper.print(yuan);</span><br><span class="line">        shapeOper.print(fang);</span><br><span class="line">        shapeOper.print(ju);</span><br><span class="line">        shapeOper.print(san);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="7、迪米特法则："><a href="#7、迪米特法则：" class="headerlink" title="7、迪米特法则："></a>7、迪米特法则：</h3><p>又称为最少知道原则，即一个类对自己依赖的类知道的越少越好。</p>
<p>对于被依赖的类不管多么复杂，都尽量将逻辑处理封装在类的内部，对外提供public方法，不对外泄露任何信息。</p>
<p>直接朋友：类中出现在成员变量、方法参数、方法返回类型中的类是直接朋友。</p>
<p>如：class A{</p>
<p>​	D od;</p>
<p>​	B f(C oc){}</p>
<p>}</p>
<p>陌生朋友：类中的方法中的局部变量的类是陌生朋友。</p>
<p>如：class A{</p>
<p>​	void f(){</p>
<p>​		B ob &#x3D; new B();		</p>
<p>​	}</p>
<p>}</p>
<p>问题：</p>
<p>学生类     班级类     聚合关系</p>
<p>打印类   打印班级信息，以及班级中的学生信息。</p>
<p>传统：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Student&#123;</span><br><span class="line">    private int id;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    public Student(int id, String name, int age) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setId(int id) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Grade&#123;</span><br><span class="line">    private int id;</span><br><span class="line">    private String name;</span><br><span class="line">    List&lt;Student&gt; list;</span><br><span class="line"></span><br><span class="line">    public Grade(int id, String name, List&lt;Student&gt; list) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.list = list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setId(int id) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public List&lt;Student&gt; getList() &#123;</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setList(List&lt;Student&gt; list) &#123;</span><br><span class="line">        this.list = list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class PrintOper&#123;</span><br><span class="line">    public void printGrade(List&lt;Grade&gt; list)&#123;</span><br><span class="line">        for (Grade g: list)&#123;</span><br><span class="line">            int id = g.getId();</span><br><span class="line">            String name = g.getName();</span><br><span class="line">            System.out.println(&quot;班级信息：班号：&quot;+id+&quot;    名字：&quot;+name);</span><br><span class="line"></span><br><span class="line">            List&lt;Student&gt; list1 = g.getList();</span><br><span class="line">            for (Student s: list1)&#123;</span><br><span class="line">                System.out.println(&quot;\t&quot;+s.getId()+&quot;\t&quot;+s.getName()+&quot;\t&quot;+s.getAge());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class MyTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;Grade&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        PrintOper printOper = new PrintOper();</span><br><span class="line"></span><br><span class="line">        List&lt;Student&gt; list1;</span><br><span class="line">        list1 = new ArrayList&lt;&gt;();</span><br><span class="line">        list1.add(new Student(101, &quot;aa&quot;, 11));</span><br><span class="line">        list1.add(new Student(102, &quot;aa&quot;, 12));</span><br><span class="line">        list1.add(new Student(103, &quot;aa&quot;, 13));</span><br><span class="line">        list1.add(new Student(104, &quot;aa&quot;, 14));</span><br><span class="line">        list.add(new Grade(1, &quot;一一班&quot;, list1));</span><br><span class="line">        list1 = new ArrayList&lt;&gt;();</span><br><span class="line">        list1.add(new Student(201, &quot;aa&quot;, 21));</span><br><span class="line">        list1.add(new Student(202, &quot;aa&quot;, 22));</span><br><span class="line">        list1.add(new Student(203, &quot;aa&quot;, 23));</span><br><span class="line">        list1.add(new Student(204, &quot;aa&quot;, 24));</span><br><span class="line">        list.add(new Grade(2, &quot;一二班&quot;, list1));</span><br><span class="line">        list1 = new ArrayList&lt;&gt;();</span><br><span class="line">        list1.add(new Student(301, &quot;aa&quot;, 31));</span><br><span class="line">        list1.add(new Student(302, &quot;aa&quot;, 32));</span><br><span class="line">        list1.add(new Student(303, &quot;aa&quot;, 33));</span><br><span class="line">        list1.add(new Student(304, &quot;aa&quot;, 34));</span><br><span class="line">        list.add(new Grade(3, &quot;一三班&quot;, list1));</span><br><span class="line"></span><br><span class="line">        printOper.printGrade(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>迪米特：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Student&#123;</span><br><span class="line">    private int id;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    public Student(int id, String name, int age) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setId(int id) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Grade&#123;</span><br><span class="line">    private int id;</span><br><span class="line">    private String name;</span><br><span class="line">    List&lt;Student&gt; list;</span><br><span class="line"></span><br><span class="line">    public Grade(int id, String name, List&lt;Student&gt; list) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.list = list;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void printStudent()&#123;</span><br><span class="line">        for (Student s: list)&#123;</span><br><span class="line">            System.out.println(&quot;\t&quot;+s.getId()+&quot;\t&quot;+s.getName()+&quot;\t&quot;+s.getAge());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setId(int id) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public List&lt;Student&gt; getList() &#123;</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setList(List&lt;Student&gt; list) &#123;</span><br><span class="line">        this.list = list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class PrintOper&#123;</span><br><span class="line">    public void printGrade(List&lt;Grade&gt; list)&#123;</span><br><span class="line">        for (Grade g: list)&#123;</span><br><span class="line">            int id = g.getId();</span><br><span class="line">            String name = g.getName();</span><br><span class="line">            System.out.println(&quot;班级信息：班号：&quot;+id+&quot;    名字：&quot;+name);</span><br><span class="line"></span><br><span class="line">            g.printStudent();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MyTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;Grade&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        PrintOper printOper = new PrintOper();</span><br><span class="line"></span><br><span class="line">        List&lt;Student&gt; list1;</span><br><span class="line">        list1 = new ArrayList&lt;&gt;();</span><br><span class="line">        list1.add(new Student(101, &quot;aa&quot;, 11));</span><br><span class="line">        list1.add(new Student(102, &quot;aa&quot;, 12));</span><br><span class="line">        list1.add(new Student(103, &quot;aa&quot;, 13));</span><br><span class="line">        list1.add(new Student(104, &quot;aa&quot;, 14));</span><br><span class="line">        list.add(new Grade(1, &quot;一一班&quot;, list1));</span><br><span class="line">        list1 = new ArrayList&lt;&gt;();</span><br><span class="line">        list1.add(new Student(201, &quot;aa&quot;, 21));</span><br><span class="line">        list1.add(new Student(202, &quot;aa&quot;, 22));</span><br><span class="line">        list1.add(new Student(203, &quot;aa&quot;, 23));</span><br><span class="line">        list1.add(new Student(204, &quot;aa&quot;, 24));</span><br><span class="line">        list.add(new Grade(2, &quot;一二班&quot;, list1));</span><br><span class="line">        list1 = new ArrayList&lt;&gt;();</span><br><span class="line">        list1.add(new Student(301, &quot;aa&quot;, 31));</span><br><span class="line">        list1.add(new Student(302, &quot;aa&quot;, 32));</span><br><span class="line">        list1.add(new Student(303, &quot;aa&quot;, 33));</span><br><span class="line">        list1.add(new Student(304, &quot;aa&quot;, 34));</span><br><span class="line">        list.add(new Grade(3, &quot;一三班&quot;, list1));</span><br><span class="line"></span><br><span class="line">        printOper.printGrade(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="8、合成复用原则"><a href="#8、合成复用原则" class="headerlink" title="8、合成复用原则"></a>8、合成复用原则</h3><p>原则上尽量使用组合或聚合方式，而不使用继承方法。</p>
<p>如：汽车类   轮胎类</p>
<p>有的关系：组合、聚合</p>
<p>是的关系：继承</p>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="一、概念："><a href="#一、概念：" class="headerlink" title="一、概念："></a>一、概念：</h2><h2 id="1、什么是设计模式："><a href="#1、什么是设计模式：" class="headerlink" title="1、什么是设计模式："></a>1、什么是设计模式：</h2><p>设计模式 ：程序员在面对同类软件工程设计问题所总结出来的有用经验，设计模式不是代码，是某类问题通用的解决方案。</p>
<h2 id="2、设计模式的类型："><a href="#2、设计模式的类型：" class="headerlink" title="2、设计模式的类型："></a>2、设计模式的类型：</h2><h3 id="2-1、创建型模式："><a href="#2-1、创建型模式：" class="headerlink" title="2.1、创建型模式："></a>2.1、创建型模式：</h3><p>单例模式、抽象工厂模式、原型模式、建造者模式、工厂模式</p>
<h3 id="2-2、结构型模式："><a href="#2-2、结构型模式：" class="headerlink" title="2.2、结构型模式："></a>2.2、结构型模式：</h3><p>适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式</p>
<h3 id="2-3、行为型模式："><a href="#2-3、行为型模式：" class="headerlink" title="2.3、行为型模式："></a>2.3、行为型模式：</h3><p>模板方法模式、命令模式、访问者模式、迭代器模式、观察者模式、中介模式、备忘录模式、解释器模式、状态模式、策略模式、职责链模式</p>
<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>通过单例模式实现一个类只能创建一个对象。</p>
<p>单例模式：就是采用一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个获取该类对象的方法。</p>
<h2 id="一、饿汉式："><a href="#一、饿汉式：" class="headerlink" title="一、饿汉式："></a>一、饿汉式：</h2><h3 id="1、static关键字："><a href="#1、static关键字：" class="headerlink" title="1、static关键字："></a>1、static关键字：</h3><p>成员变量：属于类的；只有一份空间；类加载到内存时分配空间；类名.成员变量名或对象.成员变量名</p>
<p>成员方法：属于类；没有this参数；只能访问静态成员；类名.成员方法或对象.成员方法；不能被重写</p>
<p>内部类：属于外部类；</p>
<p>代码块：类加载到内存时执行一次；</p>
<h3 id="2、final关键字："><a href="#2、final关键字：" class="headerlink" title="2、final关键字："></a>2、final关键字：</h3><p>成员变量：必须初始化；值不能被改变；</p>
<p>局部变量：只能赋一次值；值不能被改变；</p>
<p>成员方法：不能被重写；</p>
<p>类：不能被继承；</p>
<h3 id="3、实现单例："><a href="#3、实现单例：" class="headerlink" title="3、实现单例："></a>3、实现单例：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Singleton&#123;</span><br><span class="line">	//private final关键字是为了避免该变量被修改。</span><br><span class="line">	//在静态方法中要使用该变量，所以要加static关键字</span><br><span class="line">    private final static Singleton instance = new Singleton();</span><br><span class="line">    //private关键字是为了避免在该类的外部任意的new对象。</span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line">    //static是为了在该类外部能通过类名访问。</span><br><span class="line">    public static Singleton getInstance()&#123;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、优缺点："><a href="#4、优缺点：" class="headerlink" title="4、优缺点："></a>4、优缺点：</h3><p>优点：代码简单；效率高；避免了线程同步问题；</p>
<p>缺点：没有实现懒加载，造成内存的浪费；</p>
<h3 id="5、代码："><a href="#5、代码：" class="headerlink" title="5、代码："></a>5、代码：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Singleton&#123;</span><br><span class="line">    private final static Singleton instance = new Singleton();</span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line">    public static Singleton getInstance()&#123;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="二、懒汉式："><a href="#二、懒汉式：" class="headerlink" title="二、懒汉式："></a>二、懒汉式：</h2><h3 id="1、线程概念："><a href="#1、线程概念：" class="headerlink" title="1、线程概念："></a>1、线程概念：</h3><p>一段代码的执行过程；是程序执行的最小单位；并发执行；</p>
<h3 id="2、创建线程："><a href="#2、创建线程：" class="headerlink" title="2、创建线程："></a>2、创建线程：</h3><p>创建线程类，继承Thread类，重写run方法。</p>
<p>创建线程类对象，调用start方法，线程开始执行。</p>
<h3 id="3、线程互斥操作："><a href="#3、线程互斥操作：" class="headerlink" title="3、线程互斥操作："></a>3、线程互斥操作：</h3><p>synchronized（对象）{</p>
<p>​	对临界资源操作的代码</p>
<p>}</p>
<p>两个线程执行过程中，括号中的对象要求是同一个对象。</p>
<h3 id="4、反射"><a href="#4、反射" class="headerlink" title="4、反射"></a>4、反射</h3><p>Class     Constructor    Method    Field</p>
<p>Class是JDK定义的类。</p>
<p>Class类对象中保存一个类的信息。如：类名、构造方法、成员方法、成员变量等信息。</p>
<p>当一个类加载到内存时，java虚拟机会创建该类对应的Class对象。一个类对应的Class对象只有一个。</p>
<p>获取一个类对应的Class对象：类名.class</p>
<h3 id="5、懒汉式实现单例模式："><a href="#5、懒汉式实现单例模式：" class="headerlink" title="5、懒汉式实现单例模式："></a>5、懒汉式实现单例模式：</h3><p>私有的构造方法；</p>
<p>成员变量保存创建的类对象；</p>
<p>提供一个方法返回创建的类对象；</p>
<h3 id="6、优缺点："><a href="#6、优缺点：" class="headerlink" title="6、优缺点："></a>6、优缺点：</h3><p>优点：实现懒加载；线程安全；</p>
<p>缺点：执行效率低；</p>
<h3 id="7、代码："><a href="#7、代码：" class="headerlink" title="7、代码："></a>7、代码：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Singleton&#123;</span><br><span class="line">    //私有构造方法，保证其他类中不能创建该类对象；</span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line">    //private：保证其他类中不能修改instance成员变量的值。</span><br><span class="line">    //不能有final：为了实现懒加载，需要在方法中创建该类对象。</span><br><span class="line">    //static：在静态方法getInstance中使用。</span><br><span class="line">    private static Singleton instance = null;</span><br><span class="line">    //static：保证在其他类中使用类名调用该方法。</span><br><span class="line">    public static Singleton getInstance()&#123;</span><br><span class="line">        //if语句：提高程序执行效率</span><br><span class="line">        if (instance == null) &#123;</span><br><span class="line">            //synchronized：解决线程不同步问题。</span><br><span class="line">            //不能时instance，因为初始值为null，没有指向某个对象。</span><br><span class="line">            //类名.class对应的对象只有一个。</span><br><span class="line">            synchronized (Singleton.class) &#123;</span><br><span class="line">                //if语句：保证只创建一个对象。</span><br><span class="line">                if (instance == null) &#123;</span><br><span class="line">                    instance = new Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="三、静态内部类："><a href="#三、静态内部类：" class="headerlink" title="三、静态内部类："></a>三、静态内部类：</h2><h3 id="1、内部类："><a href="#1、内部类：" class="headerlink" title="1、内部类："></a>1、内部类：</h3><h4 id="1-1、基本使用："><a href="#1-1、基本使用：" class="headerlink" title="1.1、基本使用："></a>1.1、基本使用：</h4><p>使用的修饰符：public   protected   private    static</p>
<p>非静态内部类：</p>
<p>​	外部类名.内部类名  变量名；</p>
<p>​	创建外部类对象;  外部类对象.new  内部类名();</p>
<p>静态内部类：</p>
<p>​	外部类名.内部类名  变量名；</p>
<p>​	new  外部类名.内部类名()；</p>
<h4 id="1-2、特点："><a href="#1-2、特点：" class="headerlink" title="1.2、特点："></a>1.2、特点：</h4><p>在外部类中可以访问内部类的private成员；在内部类中可以访问外部类中的private成员；</p>
<p>在外部类中可以实例化内部类对象；在内部类中可以实例化外部类对象；</p>
<p>外部类加载到内存时，内部类 不会 随之加载到内存；</p>
<p>非静态内部类中不能有静态成员；</p>
<h3 id="2、静态内部类实现单例模式："><a href="#2、静态内部类实现单例模式：" class="headerlink" title="2、静态内部类实现单例模式："></a>2、静态内部类实现单例模式：</h3><p>与饿汉式类似。</p>
<p>区别：private static final Singleton instance &#x3D; new Singleton(); 语句放置在静态内部类中。</p>
<h3 id="3、代码："><a href="#3、代码：" class="headerlink" title="3、代码："></a>3、代码：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Singleton&#123;</span><br><span class="line">    //保证其他类中不能实例化该类对象</span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    //private：保证外部类不能使用该内部类。</span><br><span class="line">    private static class Inner&#123;</span><br><span class="line">        //private final：在其他类中不能被修改</span><br><span class="line">        //static：在静态方法中使用</span><br><span class="line">        //放置在内部类中：不会随着外部类的加载而创建对象，实现懒加载</span><br><span class="line">        private static final Singleton instance = new Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //static：保证在其他类中使用类名调用该方法。</span><br><span class="line">    public static Singleton getInstance()&#123;</span><br><span class="line">        return Inner.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4、优缺点：-1"><a href="#4、优缺点：-1" class="headerlink" title="4、优缺点："></a>4、优缺点：</h3><p>优点：实现懒加载，线程安全，效率高。</p>
<p>缺点：代码不容易理解。</p>
<p>推荐使用静态内部类方式实现单例模式。</p>
<h1 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h1><h2 id="一、概念：-1"><a href="#一、概念：-1" class="headerlink" title="一、概念："></a>一、概念：</h2><p>1、工厂模式是创建型模式。</p>
<p>2、工厂模式提供了一种创建对象的最佳方式。</p>
<p>3、创建复杂对象时，适合使用工厂模式；如果创建简单对象，则只需new就可以。</p>
<p>4、在工厂模式中，在创建对象时不会对客户端暴漏创建逻辑，并且使用一个统一的接口来指向新创建的对象。</p>
<h2 id="二、范例："><a href="#二、范例：" class="headerlink" title="二、范例："></a>二、范例：</h2><p>创建图形，根据指定的名字创建 三角形、圆形、矩形对象。</p>
<p>传统方式：</p>
<p>一个方法无法返回多种类型。</p>
<p>工厂模式：</p>
<p><img src="C:\Users\wangchao\AppData\Roaming\Typora\typora-user-images\image-20220920165309827.png" alt="image-20220920165309827"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//接口</span><br><span class="line">interface Shape&#123;</span><br><span class="line">    public void draw();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//三个实现了Shape接口的实现类</span><br><span class="line">class Circle implements Shape&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void draw() &#123;</span><br><span class="line">        System.out.println(&quot;我是圆形对象，可以画圆形&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Square implements Shape&#123;</span><br><span class="line">    public void draw() &#123;</span><br><span class="line">        System.out.println(&quot;我是方形对象，可以画方形&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Rectangle implements Shape&#123;</span><br><span class="line">    public void draw() &#123;</span><br><span class="line">        System.out.println(&quot;我是三角形形对象，可以画三角形形&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//工厂类，创建实现了Shape接口的类对象</span><br><span class="line">class ShapeFactory&#123;</span><br><span class="line">    public Shape getShape(String name)&#123;</span><br><span class="line">        //必须先判断name是否为null，否则，执行name.equals(&quot;circle&quot;)，会出现空指针异常</span><br><span class="line">        if (name == null)</span><br><span class="line">            return null;</span><br><span class="line">        switch (name)&#123;</span><br><span class="line">            case &quot;circle&quot;:</span><br><span class="line">                return new Circle();</span><br><span class="line">            case &quot;square&quot;:</span><br><span class="line">                return new Square();</span><br><span class="line">            case &quot;rectangle&quot;:</span><br><span class="line">                return new Rectangle();</span><br><span class="line">            default:</span><br><span class="line">                return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//测试类</span><br><span class="line">public class FactoryPattenDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ShapeFactory factory = new ShapeFactory();</span><br><span class="line">        Shape shape;</span><br><span class="line">        shape = factory.getShape(&quot;circle&quot;);</span><br><span class="line">        shape.draw();</span><br><span class="line">        shape = factory.getShape(&quot;square&quot;);</span><br><span class="line">        shape.draw();</span><br><span class="line">        shape = factory.getShape(&quot;rectangle&quot;);</span><br><span class="line">        shape.draw();</span><br><span class="line">        shape = factory.getShape(null);</span><br><span class="line">        if (shape == null)</span><br><span class="line">            System.out.println(&quot;没有创建图形对象&quot;);</span><br><span class="line">        shape = factory.getShape(&quot;aaa&quot;);</span><br><span class="line">        if (shape == null)</span><br><span class="line">            System.out.println(&quot;没有创建图形对象&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>作业：</p>
<p>使用工厂模式创建 上衣、裤子、帽子对象。</p>
<h1 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h1><h2 id="一、概念：-2"><a href="#一、概念：-2" class="headerlink" title="一、概念："></a>一、概念：</h2><p>抽象工厂模式属于创建型模式。</p>
<p>适用：系统的产品多于一个产品族，而系统只会使用其中一个产品族。如：形状（三角形、圆形、方形）、颜色（红色、绿色、蓝色）、休闲服装（休闲上衣、休闲裤子、休闲帽子）、运动服装（运动上衣、运动裤子、运动帽子）</p>
<p>抽象工厂模式是围绕一个超级工厂创建其他工厂，该超级工厂又其他工厂的工厂。</p>
<p>应用：如QQ换皮肤</p>
<h2 id="二、范例：-1"><a href="#二、范例：-1" class="headerlink" title="二、范例："></a>二、范例：</h2><p>功能：定义对象，创建形状（三角形、圆形、方形）、颜色（红色、绿色、蓝色）。</p>
<p><img src="C:\Users\wangchao\AppData\Roaming\Typora\typora-user-images\image-20220922154043925.png" alt="image-20220922154043925"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//定义图形类</span><br><span class="line">interface Shape&#123;</span><br><span class="line">    public void draw();</span><br><span class="line">&#125;</span><br><span class="line">class Circle implements Shape&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void draw() &#123;</span><br><span class="line">        System.out.println(&quot;我是圆形，我会画圆形&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Square implements Shape&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void draw() &#123;</span><br><span class="line">        System.out.println(&quot;我是方形，我会画方形&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Rectangle implements Shape&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void draw() &#123;</span><br><span class="line">        System.out.println(&quot;我是三角形，我会画三角形&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//定义颜色类</span><br><span class="line">interface Color&#123;</span><br><span class="line">    public void fill();</span><br><span class="line">&#125;</span><br><span class="line">class Red implements Color&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void fill() &#123;</span><br><span class="line">        System.out.println(&quot;我是红色，我会填充红色&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Green implements Color&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void fill() &#123;</span><br><span class="line">        System.out.println(&quot;我是绿色，我会填充绿色&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Blue implements Color&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void fill() &#123;</span><br><span class="line">        System.out.println(&quot;我是蓝色，我会填充蓝色&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//定义抽象工厂类</span><br><span class="line">abstract class AbstractFactory&#123;</span><br><span class="line">    public Shape getShape(String name) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    public Color getColor(String name) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//定义图形工厂类</span><br><span class="line">class ShapeFactory extends AbstractFactory&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Shape getShape(String name) &#123;</span><br><span class="line">        if (name == null)</span><br><span class="line">            return null;</span><br><span class="line">        switch (name)&#123;</span><br><span class="line">            case &quot;circle&quot;:</span><br><span class="line">                return new Circle();</span><br><span class="line">            case &quot;square&quot;:</span><br><span class="line">                return new Square();</span><br><span class="line">            case &quot;rectangle&quot;:</span><br><span class="line">                return new Rectangle();</span><br><span class="line">            default:</span><br><span class="line">                return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//定义颜色工厂类</span><br><span class="line">class ColorFactory extends AbstractFactory&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Color getColor(String name) &#123;</span><br><span class="line">        if (name == null)</span><br><span class="line">            return null;</span><br><span class="line">        switch (name)&#123;</span><br><span class="line">            case &quot;red&quot;:</span><br><span class="line">                return new Red();</span><br><span class="line">            case &quot;green&quot;:</span><br><span class="line">                return new Green();</span><br><span class="line">            case &quot;blue&quot;:</span><br><span class="line">                return new Blue();</span><br><span class="line">            default:</span><br><span class="line">                return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//定义超级工厂类</span><br><span class="line">class FactoryProducer&#123;</span><br><span class="line">    public AbstractFactory getFactory(String name)&#123;</span><br><span class="line">        if (name == null)</span><br><span class="line">            return null;</span><br><span class="line">        switch (name)&#123;</span><br><span class="line">            case &quot;shape&quot;:</span><br><span class="line">                return new ShapeFactory();</span><br><span class="line">            case &quot;color&quot;:</span><br><span class="line">                return new ColorFactory();</span><br><span class="line">            default:</span><br><span class="line">                return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class AbstractFactoryPatternDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        FactoryProducer factoryProducer = new FactoryProducer();</span><br><span class="line">        AbstractFactory shapeFactory = factoryProducer.getFactory(&quot;shape&quot;);</span><br><span class="line">        Shape circle = shapeFactory.getShape(&quot;circle&quot;);</span><br><span class="line">        circle.draw();</span><br><span class="line">        Shape square = shapeFactory.getShape(&quot;square&quot;);</span><br><span class="line">        square.draw();</span><br><span class="line">        Shape rectangle = shapeFactory.getShape(&quot;rectangle&quot;);</span><br><span class="line">        rectangle.draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>作业：使用抽象工厂模式创建 休闲服装（休闲上衣、休闲裤子、休闲帽子）、运动服装（运动上衣、运动裤子、运动帽子）</p>
<h1 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h1><h2 id="一、概念：-3"><a href="#一、概念：-3" class="headerlink" title="一、概念："></a>一、概念：</h2><p>原型模式是创建型模式。</p>
<p><strong>适用：对一个存在的对象进行克隆时，适用该模式。</strong></p>
<h2 id="二、范例：-2"><a href="#二、范例：-2" class="headerlink" title="二、范例："></a>二、范例：</h2><p>​								同一个类			 同一个包      		不同包有继承关系			不同包无继承关系</p>
<p>public 						ok						ok								ok									ok</p>
<p>protected				  ok						ok								ok									no</p>
<p>默认							ok						ok								no									no</p>
<p>private						ok						no								no									no</p>
<p>​	</p>
<p> protected  Object  clone();</p>
<p>创建并返回此对象的副本。</p>
<p>使用clone：</p>
<p>1、因为访问权限的原因，需要对clone方法重写。</p>
<p>2、因为语法要求，需要实现Cloneable接口。</p>
<p>子类中对父类中的方法进行重写时，访问权限要大于等于父类方法的访问权限。</p>
<p>一个类实现<code>Cloneable</code>接口，以指示<a href="../../java/lang/Object.html#clone--"><code>Object.clone()</code></a>方法，该方法对于该类的实例进行现场复制是合法的。</p>
<p>在不实现<code>Cloneable</code>接口的实例上调用对象的克隆方法导致抛出异常<code>CloneNotSupportedException</code>  。 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Student implements Cloneable&#123;</span><br><span class="line">    private int id;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    private float score;</span><br><span class="line"></span><br><span class="line">    public Student()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    public Student(int id, String name, int age, float score) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">        this.score = score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Student&#123;&quot; +</span><br><span class="line">                &quot;id=&quot; + id +</span><br><span class="line">                &quot;, name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, age=&quot; + age +</span><br><span class="line">                &quot;, score=&quot; + score +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object clone() throws CloneNotSupportedException &#123;</span><br><span class="line">        return super.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setId(int id) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public float getScore() &#123;</span><br><span class="line">        return score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setScore(float score) &#123;</span><br><span class="line">        this.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Student s1 = new Student(1001, &quot;zhangsan&quot;, 23, 99);</span><br><span class="line">Student s2;</span><br><span class="line"></span><br><span class="line">s2 = (Student) s1.clone();</span><br><span class="line"></span><br><span class="line">System.out.println(s1);</span><br><span class="line">System.out.println(s2);</span><br></pre></td></tr></table></figure>



<h2 id="三、深复制和浅复制"><a href="#三、深复制和浅复制" class="headerlink" title="三、深复制和浅复制"></a>三、深复制和浅复制</h2><p>浅复制：只复制成员变量中的值。</p>
<p>深复制：除了复制成员变量的值，还要复制成员变量所引用的对象。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class MyDate&#123;</span><br><span class="line">    int year;</span><br><span class="line">    int month;</span><br><span class="line">    int day;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;MyDate&#123;&quot; +</span><br><span class="line">                &quot;year=&quot; + year +</span><br><span class="line">                &quot;, month=&quot; + month +</span><br><span class="line">                &quot;, day=&quot; + day +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Student&#123;</span><br><span class="line">    int id;</span><br><span class="line">    float score;</span><br><span class="line">    String name;</span><br><span class="line">    MyDate birth;</span><br><span class="line"></span><br><span class="line">    public Student()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    public Student(int id, float score, String name, MyDate birth) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">        this.score = score;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.birth = birth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Student&#123;&quot; +</span><br><span class="line">                &quot;id=&quot; + id +</span><br><span class="line">                &quot;, score=&quot; + score +</span><br><span class="line">                &quot;, name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, birth=&quot; + birth +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="四、通过clone方法实现深复制"><a href="#四、通过clone方法实现深复制" class="headerlink" title="四、通过clone方法实现深复制"></a>四、通过clone方法实现深复制</h2><p>1、对类类型的成员变量对应的类重写clone方法，实现cloneable接口。</p>
<p>2、在该类的clone方法中完成以下操作：克隆该类中类型成员变量引用的对象；克隆该类对象；该类对象的类类型变量引用新克隆的对象。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class MyDate implements Cloneable&#123;</span><br><span class="line">    int year;</span><br><span class="line">    int month;</span><br><span class="line">    int day;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object clone() throws CloneNotSupportedException &#123;</span><br><span class="line">        return super.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;MyDate&#123;&quot; +</span><br><span class="line">                &quot;year=&quot; + year +</span><br><span class="line">                &quot;, month=&quot; + month +</span><br><span class="line">                &quot;, day=&quot; + day +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Student implements Cloneable&#123;</span><br><span class="line">    int id;</span><br><span class="line">    float score;</span><br><span class="line">    String name;</span><br><span class="line">    MyDate birth;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object clone() throws CloneNotSupportedException &#123;</span><br><span class="line">        MyDate b = (MyDate) birth.clone();</span><br><span class="line">        Student s = (Student) super.clone();</span><br><span class="line">        s.birth = b;</span><br><span class="line">        return s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Student()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    public Student(int id, float score, String name, MyDate birth) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">        this.score = score;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.birth = birth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Student&#123;&quot; +</span><br><span class="line">                &quot;id=&quot; + id +</span><br><span class="line">                &quot;, score=&quot; + score +</span><br><span class="line">                &quot;, name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, birth=&quot; + birth +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyTest &#123;</span><br><span class="line">    public static void main(String[] args) throws CloneNotSupportedException &#123;</span><br><span class="line">        MyDate date = new MyDate();</span><br><span class="line">        date.year = 1988;</span><br><span class="line">        date.month = 11;</span><br><span class="line">        date.day = 22;</span><br><span class="line">        Student s1 = new Student(1001, 99, &quot;zhangsan&quot;, date);</span><br><span class="line"></span><br><span class="line">        Student s2 = (Student) s1.clone();</span><br><span class="line"></span><br><span class="line">        //测试深复制</span><br><span class="line">        s2.birth.year = 2000;</span><br><span class="line"></span><br><span class="line">        System.out.println(s1);</span><br><span class="line">        System.out.println(s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="五、通过IO流实现深复制"><a href="#五、通过IO流实现深复制" class="headerlink" title="五、通过IO流实现深复制"></a>五、通过IO流实现深复制</h2><h3 id="1、回顾："><a href="#1、回顾：" class="headerlink" title="1、回顾："></a>1、回顾：</h3><p>内存中的数据和文件中的数据进行传输：（节点流）</p>
<p>FileIInputStream</p>
<p>FileOutputStream</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class FileStreamTest &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        FileOutputStream out = new FileOutputStream(&quot;a.txt&quot;);</span><br><span class="line">        out.write(&quot;你好&quot;.getBytes());</span><br><span class="line">        out.close();</span><br><span class="line"></span><br><span class="line">        FileInputStream in = new FileInputStream(&quot;a.txt&quot;);</span><br><span class="line">        byte[] b = new byte[1024];</span><br><span class="line">        int len;</span><br><span class="line">        len = in.read(b);</span><br><span class="line">        String s = new String(b, 0, len);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>内存中的数据和缓冲区的数据进行传输：（节点流）</p>
<p>ByteArrayInputStream</p>
<p>ByteArrayOutputStream</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ArrayStreamTest &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        //创建该对象时自动创建缓冲区</span><br><span class="line">        ByteArrayOutputStream out = new ByteArrayOutputStream();</span><br><span class="line">        out.write(&quot;星期四&quot;.getBytes());</span><br><span class="line">        //获取流对象对应的缓冲区</span><br><span class="line">        byte[] b = out.toByteArray();</span><br><span class="line">        String s = new String(b);</span><br><span class="line">        System.out.println(s);</span><br><span class="line"></span><br><span class="line">        //定义了一个缓冲区</span><br><span class="line">        byte[] b1;</span><br><span class="line">        b1 = &quot;十一假期来临了&quot;.getBytes();</span><br><span class="line">        ByteArrayInputStream in = new ByteArrayInputStream(b1);</span><br><span class="line">        //定义了内存空间</span><br><span class="line">        byte[] data = new byte[1024];</span><br><span class="line">        int len ;</span><br><span class="line">        len = in.read(data);</span><br><span class="line">        s = new String(data, 0, len);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对象和字节之间的转换：（处理流）</p>
<p>注意：对象要实现Serializable接口。</p>
<p>ObjectInputStream</p>
<p>ObjectOutputStream</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Student implements Serializable &#123;</span><br><span class="line">    int id;</span><br><span class="line">    String name;</span><br><span class="line">    float score;</span><br><span class="line"></span><br><span class="line">    public Student(int id, String name, float score) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.score = score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Student&#123;&quot; +</span><br><span class="line">                &quot;id=&quot; + id +</span><br><span class="line">                &quot;, name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, score=&quot; + score +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class ObjectStreamTeest &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException, ClassNotFoundException &#123;</span><br><span class="line">        Student s1 = new Student(1001, &quot;aaa&quot;, 99);</span><br><span class="line">        FileOutputStream fout = new FileOutputStream(&quot;a.txt&quot;);</span><br><span class="line">        ObjectOutputStream oout = new ObjectOutputStream(fout);</span><br><span class="line">        oout.writeObject(s1);</span><br><span class="line">        oout.close();</span><br><span class="line">        fout.close();</span><br><span class="line"></span><br><span class="line">        FileInputStream fin = new FileInputStream(&quot;a.txt&quot;);</span><br><span class="line">        ObjectInputStream oin = new ObjectInputStream(fin);</span><br><span class="line">        Student s2;</span><br><span class="line">        s2 = (Student) oin.readObject();</span><br><span class="line"></span><br><span class="line">        System.out.println(s1);</span><br><span class="line">        System.out.println(s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、使用IO流实现深复制："><a href="#2、使用IO流实现深复制：" class="headerlink" title="2、使用IO流实现深复制："></a>2、使用IO流实现深复制：</h3><p>通过文件作为中转：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class DeepCopy01 &#123;</span><br><span class="line">    public static Object deepCopy(Object obj) throws IOException, ClassNotFoundException &#123;</span><br><span class="line">        //将学生对象写入到文件中</span><br><span class="line">        FileOutputStream fout = new FileOutputStream(&quot;a.txt&quot;);</span><br><span class="line">        ObjectOutputStream oout = new ObjectOutputStream(fout);</span><br><span class="line">        oout.writeObject(obj);</span><br><span class="line"></span><br><span class="line">        //从文件中读取学生对象</span><br><span class="line">        FileInputStream fin = new FileInputStream(&quot;a.txt&quot;);</span><br><span class="line">        ObjectInputStream oin = new ObjectInputStream(fin);</span><br><span class="line">        Object s2 = oin.readObject();</span><br><span class="line"></span><br><span class="line">        return s2;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) throws IOException, ClassNotFoundException &#123;</span><br><span class="line">        //创建学生对象</span><br><span class="line">        MyDate date = new MyDate(1988, 11, 22);</span><br><span class="line">        Student s1 = new Student(1001, &quot;张三&quot;, 88.5f, date);</span><br><span class="line">        //将学生对象写入到文件中</span><br><span class="line">        FileOutputStream fout = new FileOutputStream(&quot;a.txt&quot;);</span><br><span class="line">        ObjectOutputStream oout = new ObjectOutputStream(fout);</span><br><span class="line">        oout.writeObject(s1);</span><br><span class="line">        //从文件中读取学生对象</span><br><span class="line">        FileInputStream fin = new FileInputStream(&quot;a.txt&quot;);</span><br><span class="line">        ObjectInputStream oin = new ObjectInputStream(fin);</span><br><span class="line">        Student s2 = (Student)oin.readObject();</span><br><span class="line"></span><br><span class="line">        //测试深复制</span><br><span class="line">        s2.birthday.year = 2000;</span><br><span class="line"></span><br><span class="line">        System.out.println(s1);</span><br><span class="line">        System.out.println(s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>通过缓冲区作为中转：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class DeepCopy02 &#123;</span><br><span class="line">    public static &lt;T extends Serializable&gt; T deepCopy(T obj) throws IOException, ClassNotFoundException &#123;</span><br><span class="line">        //将对象写入到缓冲区</span><br><span class="line">        ByteArrayOutputStream bout = new ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream oout = new ObjectOutputStream(bout);</span><br><span class="line">        oout.writeObject(obj);</span><br><span class="line"></span><br><span class="line">        //从缓冲区中读取对象</span><br><span class="line">        //获取bout中的缓冲区</span><br><span class="line">        byte[] bytes = bout.toByteArray();</span><br><span class="line">        //使用bout中的缓冲区初始化bin</span><br><span class="line">        ByteArrayInputStream bin = new ByteArrayInputStream(bytes);</span><br><span class="line">        ObjectInputStream oin = new ObjectInputStream(bin);</span><br><span class="line">        T o = (T)oin.readObject();</span><br><span class="line"></span><br><span class="line">        return o;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) throws IOException, ClassNotFoundException &#123;</span><br><span class="line">        //创建学生对象</span><br><span class="line">        MyDate date = new MyDate(1988, 11, 22);</span><br><span class="line">        Student s1 = new Student(1001, &quot;张三&quot;, 88.5f, date);</span><br><span class="line">        //调用deepCopy方法</span><br><span class="line">        Student s2 = (Student) deepCopy(s1);</span><br><span class="line"></span><br><span class="line">        //测试深复制</span><br><span class="line">        s2.birthday.year = 2000;</span><br><span class="line"></span><br><span class="line">        System.out.println(s1);</span><br><span class="line">        System.out.println(s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h1><h2 id="一、概念：-4"><a href="#一、概念：-4" class="headerlink" title="一、概念："></a>一、概念：</h2><p>建造者模式属于创建型模式。<strong>使用多个简单对象，一步一步构建成一个复杂的对象。</strong></p>
<p>这个复杂对象的各个部分会经常出现剧烈的变化，但将他们组合在一起的算法相对稳定。</p>
<p>将变与不变分离。</p>
<p>与工厂模式的区别：建造者模式更加关注于零件装配的顺序。</p>
<h2 id="二、范例：-3"><a href="#二、范例：-3" class="headerlink" title="二、范例："></a>二、范例：</h2><img src="C:\Users\wangchao\Desktop\建造模式.png" alt="建造模式" style="zoom: 50%;" />

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//创建条目接口Item</span><br><span class="line">interface Item&#123;</span><br><span class="line">    public String name();</span><br><span class="line">    public float price();</span><br><span class="line">    public String pack();</span><br><span class="line">&#125;</span><br><span class="line">//创建抽象汉堡类Burger</span><br><span class="line">abstract class Burger implements Item&#123;</span><br><span class="line">    public String pack()&#123;</span><br><span class="line">        return &quot;纸盒子&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//创建抽象冷饮类ColdDrink</span><br><span class="line">abstract class ColdDrink implements Item&#123;</span><br><span class="line">    public String pack()&#123;</span><br><span class="line">        return &quot;瓶子&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//创建蔬菜汉堡类VegBurger</span><br><span class="line">class VegBurger extends Burger&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String name() &#123;</span><br><span class="line">        return &quot;蔬菜汉堡&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public float price() &#123;</span><br><span class="line">        return 5;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//创建鸡肉汉堡类ChickenBurger</span><br><span class="line">class ChickenBurger extends Burger&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String name() &#123;</span><br><span class="line">        return &quot;鸡肉汉堡&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public float price() &#123;</span><br><span class="line">        return 10;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//创建百事可乐类Pegis</span><br><span class="line">class Pegis extends ColdDrink&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String name() &#123;</span><br><span class="line">        return &quot;百事可乐&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public float price() &#123;</span><br><span class="line">        return 3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//创建可口可乐类Coke</span><br><span class="line">class Coke extends ColdDrink&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String name() &#123;</span><br><span class="line">        return &quot;可口可乐&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public float price() &#123;</span><br><span class="line">        return 4;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//创建套餐类Meal</span><br><span class="line">class Meal&#123;</span><br><span class="line">    private List&lt;Item&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">    //给套餐中添加条目</span><br><span class="line">    public void addItem(Item item)&#123;</span><br><span class="line">        list.add(item);</span><br><span class="line">    &#125;</span><br><span class="line">    //显示套餐条目的名称</span><br><span class="line">    public void showName()&#123;</span><br><span class="line">        System.out.println(&quot;套餐商品名：&quot;);</span><br><span class="line">        for (Item item: list)&#123;</span><br><span class="line">            String name = item.name();</span><br><span class="line">            System.out.println(&quot;\t&quot; + name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //显示套餐的总价格</span><br><span class="line">    public void showPrice()&#123;</span><br><span class="line">        System.out.print(&quot;套餐价格：&quot;);</span><br><span class="line">        float total = 0;</span><br><span class="line">        for (Item item: list)&#123;</span><br><span class="line">            float price = item.price();</span><br><span class="line">            total += price;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(total);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//创建生产套餐类MealBuilder</span><br><span class="line">class MealBuilder&#123;</span><br><span class="line">    //生产套餐一</span><br><span class="line">    public Meal builderMeal01()&#123;</span><br><span class="line">        Meal meal = new Meal();</span><br><span class="line">        meal.addItem(new ChickenBurger());</span><br><span class="line">        meal.addItem(new Coke());</span><br><span class="line">        return  meal;</span><br><span class="line">    &#125;</span><br><span class="line">    //生产套餐二</span><br><span class="line">    public Meal builderMeal02()&#123;</span><br><span class="line">        Meal meal = new Meal();</span><br><span class="line">        meal.addItem(new VegBurger());</span><br><span class="line">        meal.addItem(new Coke());</span><br><span class="line">        meal.addItem(new Pegis());</span><br><span class="line">        return meal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class BuilerPatternDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MealBuilder builder = new MealBuilder();</span><br><span class="line">        Meal meal;</span><br><span class="line"></span><br><span class="line">        meal = builder.builderMeal01();</span><br><span class="line">        meal.showName();</span><br><span class="line">        meal.showPrice();</span><br><span class="line"></span><br><span class="line">        meal = builder.builderMeal02();</span><br><span class="line">        meal.showName();</span><br><span class="line">        meal.showPrice();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h1><h2 id="一、概念：-5"><a href="#一、概念：-5" class="headerlink" title="一、概念："></a>一、概念：</h2><p>桥接模式：<strong>将抽象部分和它的实现部分分离开来，使他们都可以独立变化。</strong></p>
<p>抽象化：将复杂物体的一个或几个特性抽取出来的过程。</p>
<p>实现化：针对抽象化给出的具体实现。实现化使对抽象化事务的进一步具体化。</p>
<p><strong>桥接模式将继承关系转化为关联关系，这样可以降低类与类之间的耦合性，从而减少系统中类的数量。</strong></p>
<p>优点：分离抽象接口及其实现部分，提高了比继承更好的解决方案；提高了系统的可扩展性；</p>
<p>缺点：桥接模式的引入会增加系统的理解和设计难度。</p>
<h2 id="二、范例：-4"><a href="#二、范例：-4" class="headerlink" title="二、范例："></a>二、范例：</h2><p>功能：定义对象，调用方法，输出使用什么颜色填充什么形状。（红、绿、蓝）（圆、方、矩）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//定义形状抽象类</span><br><span class="line">abstract class Shape&#123;</span><br><span class="line">    protected Color color;</span><br><span class="line">    abstract public void draw();</span><br><span class="line">    public void setColor(Color color)&#123;</span><br><span class="line">        this.color = color;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//定义圆形</span><br><span class="line">class Circle extends Shape&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void draw() &#123;</span><br><span class="line">        color.fill(&quot;圆形&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//定义方形</span><br><span class="line">class Square extends Shape&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void draw() &#123;</span><br><span class="line">        color.fill(&quot;方形&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//定义矩形</span><br><span class="line">class Rectangle extends Shape&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void draw() &#123;</span><br><span class="line">        color.fill(&quot;矩形&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//定义颜色接口</span><br><span class="line">interface Color&#123;</span><br><span class="line">    public void fill(String shape);</span><br><span class="line">&#125;</span><br><span class="line">//定义红颜色</span><br><span class="line">class Red implements Color&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void fill(String shape) &#123;</span><br><span class="line">        System.out.println(&quot;用红色画&quot; + shape);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//定义绿颜色</span><br><span class="line">class Green implements Color&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void fill(String shape) &#123;</span><br><span class="line">        System.out.println(&quot;用绿色画&quot; + shape);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//定义蓝颜色</span><br><span class="line">class Blue implements Color&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void fill(String shape) &#123;</span><br><span class="line">        System.out.println(&quot;用蓝色画&quot; + shape);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//定义黄色</span><br><span class="line">class Yellow implements Color&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void fill(String shape) &#123;</span><br><span class="line">        System.out.println(&quot;用黄色画&quot; + shape);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Example &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Circle c = new Circle();</span><br><span class="line">        Square s = new Square();</span><br><span class="line">        Rectangle r = new Rectangle();</span><br><span class="line"></span><br><span class="line">        Green green = new Green();</span><br><span class="line">        Red red = new Red();</span><br><span class="line">        Blue blue = new Blue();</span><br><span class="line">        Yellow yellow = new Yellow();</span><br><span class="line"></span><br><span class="line">        c.setColor(blue);</span><br><span class="line">        c.draw();</span><br><span class="line">        r.setColor(green);</span><br><span class="line">        r.draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h1><h2 id="一、概念：-6"><a href="#一、概念：-6" class="headerlink" title="一、概念："></a>一、概念：</h2><p>组合模式是结构型模式。又称为部分整体模式。</p>
<p><strong>组合模式依据 树形结构 来组织对象，用来表示部分和整体的层次关系。</strong></p>
<p>组合模式使得用户对单个对象和组合对象的使用具有一致性。</p>
<p>组合模式模糊了简单元素和复杂元素的概念，客户程序可以像处理简单元素一样来处理复杂元素。</p>
<p><strong>树枝和树叶实现统一的接口，树枝和树叶内部组合该接口。</strong></p>
<h2 id="二、范例：-5"><a href="#二、范例：-5" class="headerlink" title="二、范例："></a>二、范例：</h2><p>功能：打印大学部门的信息（名称、地址）。</p>
<p>榆林学院—-艺术学院—音乐系</p>
<p>​										美术系</p>
<p>​					生命学院—-生物系</p>
<p>​										基因系</p>
<p>​					化工学院—-煤炭系</p>
<p>​										石油系</p>
<p>​					计算机学院–网路系</p>
<p>​										软工系</p>
<p>​										数据库系</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Component&#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private String address;</span><br><span class="line">    List&lt;Component&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public Component(String name, String address) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void show()&#123;</span><br><span class="line">        System.out.println(name + &quot; &quot; + address);</span><br><span class="line">        for (Component c: list)&#123;</span><br><span class="line">            c.show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void add(Component c)&#123;</span><br><span class="line">        list.add(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ExmapleTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Component yulin = new Component(&quot;榆林学院&quot;, &quot;榆林&quot;);</span><br><span class="line"></span><br><span class="line">        Component yishu = new Component(&quot;艺术学院&quot;, &quot;一号楼&quot;);</span><br><span class="line">        Component yinyue = new Component(&quot;音乐系&quot;, &quot;一号楼一层&quot;);</span><br><span class="line">        Component meishu = new Component(&quot;美术系&quot;, &quot;一号楼二层&quot;);</span><br><span class="line">        yishu.add(yinyue);</span><br><span class="line">        yishu.add(meishu);</span><br><span class="line"></span><br><span class="line">        Component shengming = new Component(&quot;生命学院&quot;, &quot;二号楼&quot;);</span><br><span class="line">        Component shengwu = new Component(&quot;生物系&quot;, &quot;二号楼一层&quot;);</span><br><span class="line">        Component jiyin = new Component(&quot;基因系&quot;, &quot;二号楼二层&quot;);</span><br><span class="line">        shengming.add(shengwu);</span><br><span class="line">        shengming.add(jiyin);</span><br><span class="line"></span><br><span class="line">        Component huagong = new Component(&quot;化工学院&quot;, &quot;三号楼&quot;);</span><br><span class="line">        Component meitan = new Component(&quot;煤炭系&quot;, &quot;三号楼一层&quot;);</span><br><span class="line">        Component shiyou = new Component(&quot;石油系&quot;, &quot;三号楼二层&quot;);</span><br><span class="line">        huagong.add(meitan);</span><br><span class="line">        huagong.add(shiyou);</span><br><span class="line"></span><br><span class="line">        Component jisuanji = new Component(&quot;计算机学院&quot;, &quot;四号楼&quot;);</span><br><span class="line">        Component wangluo = new Component(&quot;网络系&quot;, &quot;四号楼一楼&quot;);</span><br><span class="line">        Component ruangong = new Component(&quot;软工系&quot;, &quot;四号楼二楼&quot;);</span><br><span class="line">        Component shujuku = new Component(&quot;数据库系&quot;, &quot;四号楼三楼&quot;);</span><br><span class="line">        jisuanji.add(wangluo);</span><br><span class="line">        jisuanji.add(ruangong);</span><br><span class="line">        jisuanji.add(shujuku);</span><br><span class="line"></span><br><span class="line">        yulin.add(yishu);</span><br><span class="line">        //yulin.add(shengming);</span><br><span class="line">        huagong.add(shengming);</span><br><span class="line">        yulin.add(huagong);</span><br><span class="line">        yulin.add(jisuanji);</span><br><span class="line"></span><br><span class="line">        yulin.show();</span><br><span class="line">        System.out.println(&quot;===========&quot;);</span><br><span class="line">        jisuanji.show();</span><br><span class="line">        System.out.println(&quot;============&quot;);</span><br><span class="line">        shiyou.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>作业：</p>
<p>一层：榆林学院（名称、地址）</p>
<p>二层：艺术学院等（名称、人数）</p>
<p>三层：音乐系等（名称、系主任名字）</p>
<p>接口：show()</p>
<h1 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h1><h2 id="一、概念：-7"><a href="#一、概念：-7" class="headerlink" title="一、概念："></a>一、概念：</h2><p>适配器模式属于结构型模式。</p>
<p><strong>适配器模式是作为两个不兼容接口之间的桥梁。负责加入独立的不兼容的接口功能。</strong></p>
<p><strong>将一个类的接口转换成为客户需要的另一个接口。</strong></p>
<p>主要解决在软件系统中，常常要将一些现有对象放到新的环境中，而新环境要求的接口是现有对象不能满足的</p>
<p>通过继承或依赖实现。推荐使用依赖方式实现。</p>
<p><strong>适配器模式继承或依赖已有的对象，实现想要的目标接口</strong>。</p>
<p><strong>适配器类要实现目标接口。</strong></p>
<h2 id="二、范例：-6"><a href="#二、范例：-6" class="headerlink" title="二、范例："></a>二、范例：</h2><p>功能：V5接口，提供5V电压；</p>
<p>V220V接口，提供220V电压；</p>
<p>一个插座实现V220接口，提供220V电压；</p>
<p>手机，充电功能，需要提供5V电压；</p>
<h3 id="1、继承："><a href="#1、继承：" class="headerlink" title="1、继承："></a>1、继承：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface V5&#123;</span><br><span class="line">    public void outputV5();</span><br><span class="line">&#125;</span><br><span class="line">interface V220&#123;</span><br><span class="line">    public void outputV220();</span><br><span class="line">&#125;</span><br><span class="line">class Chazuo implements V220&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void outputV220() &#123;</span><br><span class="line">        System.out.println(&quot;插座可以提供220V电压&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Phone&#123;</span><br><span class="line">    public void power(V5 v5)&#123;</span><br><span class="line">        v5.outputV5();</span><br><span class="line">        System.out.println(&quot;有了5v电压，开始充电&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Adapter extends Chazuo implements V5&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void outputV5() &#123;</span><br><span class="line">        outputV220();</span><br><span class="line">        System.out.println(&quot;获取了220v电压&quot;);</span><br><span class="line">        System.out.println(&quot;经过一系列的处理，将220v电压转换成了5v电压&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class AdapterTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Phone phone = new Phone();</span><br><span class="line">        Adapter adapter = new Adapter();</span><br><span class="line">        phone.power(adapter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、依赖："><a href="#2、依赖：" class="headerlink" title="2、依赖："></a>2、依赖：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface V5&#123;</span><br><span class="line">    public void outputV5();</span><br><span class="line">&#125;</span><br><span class="line">interface V220&#123;</span><br><span class="line">    public void outputV220();</span><br><span class="line">&#125;</span><br><span class="line">class Chazuo implements V220 &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void outputV220() &#123;</span><br><span class="line">        System.out.println(&quot;插座可以提供220V电压&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Phone&#123;</span><br><span class="line">    public void power(V5 v5)&#123;</span><br><span class="line">        v5.outputV5();</span><br><span class="line">        System.out.println(&quot;有了5v电压，开始充电&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Adapter implements V5&#123;</span><br><span class="line">    Chazuo chazuo;</span><br><span class="line">    public Adapter(Chazuo chazuo)&#123;</span><br><span class="line">        this.chazuo = chazuo;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void outputV5() &#123;</span><br><span class="line">        chazuo.outputV220();</span><br><span class="line">        System.out.println(&quot;通过插座获取了220v电压&quot;);</span><br><span class="line">        System.out.println(&quot;经过一系列的处理，将220v电压转换成了5v电压&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class AdapterTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Chazuo chazuo = new Chazuo();</span><br><span class="line">        Adapter adapter = new Adapter(chazuo);</span><br><span class="line">        Phone phone = new Phone();</span><br><span class="line">        phone.power(adapter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、接口适配器模式："><a href="#3、接口适配器模式：" class="headerlink" title="3、接口适配器模式："></a>3、接口适配器模式：</h3><p>当不需要全部实现接口提供的方法时，可先设计一个抽象类实现该接口，并对接口中的方法重写，方法体是空的方法体。那么该抽象类的子类可以选择性的覆盖父类的某些方法。如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">button.addMouseListener(new MouseAdapter() &#123;</span><br><span class="line">&#125;);</span><br><span class="line">MouseListener是接口，MouseAdapter是实现该接口的抽象类。</span><br></pre></td></tr></table></figure>



<h1 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h1><h2 id="一、-概念："><a href="#一、-概念：" class="headerlink" title="一、 概念："></a>一、 概念：</h2><p>装饰器模式是结构型模式。</p>
<p>装饰器模式是<strong>向一个现有类</strong> <strong>添加新的功能</strong>。<strong>它是作为现有类的一个包装。在保持原有类方法完整的前提下，提供新的功能。</strong></p>
<p>动态的给一个类增加一些新的功能，就增加功能来说，装饰器模式比生成子类更为灵活。</p>
<h2 id="二、-范例："><a href="#二、-范例：" class="headerlink" title="二、 范例："></a>二、 范例：</h2><p>功能：图像接口，派生出画圆形、画方形类。增加画红边的功能。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//图形接口</span><br><span class="line">interface Shape&#123;</span><br><span class="line">    public void draw();</span><br><span class="line">&#125;</span><br><span class="line">//圆形</span><br><span class="line">class Circle implements Shape&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void draw() &#123;</span><br><span class="line">        System.out.println(&quot;画圆形&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//矩形</span><br><span class="line">class Rectangle implements Shape&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void draw() &#123;</span><br><span class="line">        System.out.println(&quot;画矩形&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//图形装饰器类</span><br><span class="line">abstract class ShapeDecorator implements Shape&#123;</span><br><span class="line">    protected Shape shape;</span><br><span class="line">    public ShapeDecorator(Shape shape)&#123;</span><br><span class="line">        this.shape = shape;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//增加红色边框的图形装饰器类</span><br><span class="line">class RedShapeDecorator extends ShapeDecorator&#123;</span><br><span class="line">    public RedShapeDecorator(Shape shape)&#123;</span><br><span class="line">        super(shape);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void draw() &#123;</span><br><span class="line">        shape.draw();</span><br><span class="line">        drawRedBorder();</span><br><span class="line">    &#125;</span><br><span class="line">    private void drawRedBorder()&#123;</span><br><span class="line">        System.out.println(&quot;画红色的边框&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//增加玻璃相框的图形装饰器类</span><br><span class="line">class GlassShapeDecorator extends ShapeDecorator&#123;</span><br><span class="line">    public GlassShapeDecorator(Shape shape)&#123;</span><br><span class="line">        super(shape);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void draw() &#123;</span><br><span class="line">        shape.draw();</span><br><span class="line">        addGlass();</span><br><span class="line">    &#125;</span><br><span class="line">    private void addGlass()&#123;</span><br><span class="line">        System.out.println(&quot;增加玻璃相框&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class DecoratorTest &#123;</span><br><span class="line">    public static void show(ShapeDecorator shape)&#123;</span><br><span class="line">        shape.draw();</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Shape shape;</span><br><span class="line">        shape = new Circle();</span><br><span class="line">        shape.draw();</span><br><span class="line">        shape = new Rectangle();</span><br><span class="line">        shape.draw();</span><br><span class="line"></span><br><span class="line">        shape = new RedShapeDecorator(new Circle());</span><br><span class="line">        shape.draw();</span><br><span class="line">        shape = new RedShapeDecorator(new Rectangle());</span><br><span class="line">        shape.draw();</span><br><span class="line"></span><br><span class="line">        shape = new GlassShapeDecorator(new Circle());</span><br><span class="line">        shape.draw();</span><br><span class="line">        shape = new GlassShapeDecorator(new Rectangle());</span><br><span class="line">        shape.draw();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;============&quot;);</span><br><span class="line">        show(new RedShapeDecorator(new Circle()));</span><br><span class="line">        show(new GlassShapeDecorator(new Rectangle()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><h2 id="一、概念：-8"><a href="#一、概念：-8" class="headerlink" title="一、概念："></a>一、概念：</h2><p>代理模式是结构型模式。</p>
<p>一个代理类代表另一个类的功能。</p>
<p><em><strong>代理模式为其他对象提供一种代理，以 控制 对这个对象的访问</strong></em>。</p>
<p>如：window系统种的快捷方式；火车票代售点；</p>
<p>通常会对远程对象、创建开销大的对象、需要安全控制的对象进行代理。</p>
<p>代理模式分为：静态代理、动态代理、Cglib代理。</p>
<p><strong>代理模式和适配器模式的区别：适配器模式是改变所考虑对象的接口，而代理类不改变被代理类的接口。</strong></p>
<p><strong>代理模式和装饰器模式 的区别：装饰器模式是为了增加功能，而代理模式是为了加以控制。</strong></p>
<h2 id="二、范例：-7"><a href="#二、范例：-7" class="headerlink" title="二、范例："></a>二、范例：</h2><p>功能：一个类提供对数组进行二分法查找。在调用该类的查找方法前要判断数组种的数据是否有序存储。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface Search&#123;</span><br><span class="line">    public int search(int[] arr, int data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class BinaraySearch implements Search&#123;</span><br><span class="line">    @Override</span><br><span class="line">    //数组中的数据从小到大有序排列</span><br><span class="line">    public int search(int[] arr, int data) &#123;</span><br><span class="line">        int begin, end, mid;</span><br><span class="line">        begin = 0;</span><br><span class="line">        end = arr.length - 1;</span><br><span class="line">        while (end &gt;= begin)&#123;</span><br><span class="line">            mid = (begin + end) / 2;</span><br><span class="line">            if (arr[mid] == data)</span><br><span class="line">                return mid;</span><br><span class="line">            else if (arr[mid] &gt; data)</span><br><span class="line">                end = mid - 1;</span><br><span class="line">            else</span><br><span class="line">                begin = mid + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class SearchProxy implements Search&#123;</span><br><span class="line">    private BinaraySearch binaraySearch;</span><br><span class="line">    public SearchProxy(BinaraySearch binaraySearch)&#123;</span><br><span class="line">        this.binaraySearch = binaraySearch;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public int search(int[] arr, int data) &#123;</span><br><span class="line">        boolean b = judgeSmallToBig(arr);</span><br><span class="line">        if (b) &#123;</span><br><span class="line">            int pos = binaraySearch.search(arr, data);</span><br><span class="line">            return pos;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return -2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //判断数组中的数据是否是从小到大有序存储</span><br><span class="line">    private boolean judgeSmallToBig(int[] arr)&#123;</span><br><span class="line">        for (int i=0; i&lt;arr.length-1; i++)&#123;</span><br><span class="line">            if (arr[i] &gt; arr[i+1])</span><br><span class="line">                return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class ProxyTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        BinaraySearch bs = new BinaraySearch();</span><br><span class="line">        SearchProxy sp = new SearchProxy(bs);</span><br><span class="line">        int[] arr = &#123;11, 22, 33, 44, 55, 66, 88, 77, 99, 100&#125;;</span><br><span class="line">        int pos = sp.search(arr, 88);</span><br><span class="line">        if (pos &gt;= 0)</span><br><span class="line">            System.out.println(&quot;查询的数据在数组中的&quot;+pos+&quot;位置&quot;);</span><br><span class="line">        if (pos == -1)</span><br><span class="line">            System.out.println(&quot;查询的数据没有在数组中&quot;);</span><br><span class="line">        if (pos == -2)</span><br><span class="line">            System.out.println(&quot;数组中的数据不是从小到大存储，不能使用该二分法查找&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h1><h2 id="一、概念：-9"><a href="#一、概念：-9" class="headerlink" title="一、概念："></a>一、概念：</h2><p>享元模式是结构型模式。</p>
<p><strong>享元模式主要用于减少创建对象的数量，以减少内存的占用，从而提高系统的效率。</strong></p>
<p><strong>享元模式尝试使用现有的同类对象，如果未找到匹配的对象，则创建新对象。</strong></p>
<p><strong>HashMap集合；一个工厂对象；</strong></p>
<h2 id="二、范例：-8"><a href="#二、范例：-8" class="headerlink" title="二、范例："></a>二、范例：</h2><p>功能：五个图形类，可以画五种图形（圆形、矩形、方形、三角形、椭圆形）；随机画5个图形。</p>
<p>补充：使用反射根据类名创建对象。</p>
<p>根据类名获取该类所对应的Class对象，使用Class类对象创建Constructor对象，使用Constructor对象创建该类对象。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">    public A()&#123;&#125;</span><br><span class="line">    public void f()&#123;</span><br><span class="line">        System.out.println(&quot;=======&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class ClassTest &#123;</span><br><span class="line">    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException &#123;</span><br><span class="line">        Class&lt;A&gt; ac = (Class&lt;A&gt;)Class.forName(&quot;cn.tedu.A&quot;);</span><br><span class="line">        Constructor&lt;A&gt; constructor = ac.getConstructor();</span><br><span class="line">        A o = constructor.newInstance();</span><br><span class="line">        o.f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>范例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface Shape&#123;</span><br><span class="line">    public void draw();</span><br><span class="line">&#125;</span><br><span class="line">class Circle implements Shape&#123;</span><br><span class="line">    public Circle()&#123;&#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void draw() &#123;</span><br><span class="line">        System.out.println(&quot;画圆形&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Rectangle implements Shape&#123;</span><br><span class="line">    public Rectangle()&#123;&#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void draw() &#123;</span><br><span class="line">        System.out.println(&quot;画矩形&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Square implements Shape&#123;</span><br><span class="line">    public Square()&#123;&#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void draw() &#123;</span><br><span class="line">        System.out.println(&quot;画方形&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Triangle implements Shape&#123;</span><br><span class="line">    public Triangle()&#123;&#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void draw() &#123;</span><br><span class="line">        System.out.println(&quot;画三角形&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Ellipse implements Shape&#123;</span><br><span class="line">    public Ellipse()&#123;&#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void draw() &#123;</span><br><span class="line">        System.out.println(&quot;画椭圆形&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class ShapeFactory&#123;</span><br><span class="line">    private HashMap&lt;String, Shape&gt; map = new HashMap&lt;String, Shape&gt;();</span><br><span class="line"></span><br><span class="line">    public Shape getShape(String name) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException &#123;</span><br><span class="line">        Shape shape = map.get(name);</span><br><span class="line">        if (shape != null)&#123;</span><br><span class="line">            System.out.println(&quot;集合中已经有了&quot;+name+&quot;对象，不再创建了&quot;);</span><br><span class="line">            return shape;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            Class&lt;Shape&gt; ac = (Class&lt;Shape&gt;)Class.forName(&quot;cn.tedu.&quot; + name);</span><br><span class="line">            Constructor&lt;Shape&gt; constructor = ac.getConstructor();</span><br><span class="line">            Shape s = constructor.newInstance();</span><br><span class="line">            map.put(name, s);</span><br><span class="line">            System.out.println(&quot;创建了一个&quot;+name+&quot;对象&quot;);</span><br><span class="line">            return s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class FlyweightTest &#123;</span><br><span class="line">    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException &#123;</span><br><span class="line">        ShapeFactory factory = new ShapeFactory();</span><br><span class="line">        String[] name = &#123;&quot;Circle&quot;, &quot;Rectangle&quot;</span><br><span class="line">                , &quot;Triangle&quot;, &quot;Ellipse&quot;, &quot;Square&quot;&#125;;</span><br><span class="line"></span><br><span class="line">        for (int i=0; i&lt;5; i++)&#123;</span><br><span class="line">            //random()：[0, 1)之间的随机小数。</span><br><span class="line">            //在[0, 4]之间取随机数。</span><br><span class="line">            int j = (int)(Math.random() * 5);</span><br><span class="line">            Shape shape = factory.getShape(name[j]);</span><br><span class="line">            shape.draw();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><h2 id="一、-概念：-1"><a href="#一、-概念：-1" class="headerlink" title="一、 概念："></a>一、 概念：</h2><p>策略模式是行为型模式。</p>
<p><strong>在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的context对象，策略对象改变context对象的执行算法。一个类的行为或算法可以在运行时更改。</strong></p>
<p><strong>定义一个个的算法，将他们一个个封装起来，并且是他们可以相互替换。实现同一个接口。</strong></p>
<h2 id="二、-范例：-1"><a href="#二、-范例：-1" class="headerlink" title="二、 范例："></a>二、 范例：</h2><p>功能：定义一个类，该类实现排序算法。可以按照从小到大排序、从大到小排序、根据平方值从小到大排序、根据平方值从大道小排序。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface Compare&#123;</span><br><span class="line">    public boolean compare(int x, int y);</span><br><span class="line">&#125;</span><br><span class="line">class FromSmallToBig implements Compare&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean compare(int x, int y) &#123;</span><br><span class="line">        if (x &gt; y)</span><br><span class="line">            return true;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class FromBigToSmall implements Compare&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean compare(int x, int y) &#123;</span><br><span class="line">        if (x &lt; y)</span><br><span class="line">            return true;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class PowFromSmallToBig implements Compare&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean compare(int x, int y) &#123;</span><br><span class="line">        if (x * x &gt; y * y)</span><br><span class="line">            return true;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class PowFromBigToSmall implements Compare&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean compare(int x, int y) &#123;</span><br><span class="line">        if (x * x &lt; y * y)</span><br><span class="line">            return true;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class SortOper&#123;</span><br><span class="line">    private Compare com;</span><br><span class="line">    public SortOper(Compare com)&#123;</span><br><span class="line">        this.com = com;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setCom(Compare com)&#123;</span><br><span class="line">        this.com = com;</span><br><span class="line">    &#125;</span><br><span class="line">    public void sort(int[] arr)&#123;</span><br><span class="line">        int len = arr.length;</span><br><span class="line">        for (int i=0; i&lt;len-1; i++)&#123;</span><br><span class="line">            for (int j=0; j&lt;len-i-1; j++)&#123;</span><br><span class="line">                //if (arr[j] &gt; arr[j+1])&#123;</span><br><span class="line">                //FromSmallToBig compare if (x&gt;y)  return true</span><br><span class="line">                //if (arr[j] &lt; arr[j+1])</span><br><span class="line">                //FromBigToSmall compare if (x&lt;y)  return true</span><br><span class="line">                if (com.compare(arr[j], arr[j+1]) == true)&#123;</span><br><span class="line">                    int t;</span><br><span class="line">                    t = arr[j];</span><br><span class="line">                    arr[j] = arr[j+1];</span><br><span class="line">                    arr[j+1] = t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class SortTest &#123;</span><br><span class="line">    static void show(int[] arr)&#123;</span><br><span class="line">        for (int a: arr)&#123;</span><br><span class="line">            System.out.print(a+&quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arr = &#123;10,41,-7,89,23,-49,20,17,-41,30,27&#125;;</span><br><span class="line">        FromSmallToBig fromSmallToBig = new FromSmallToBig();</span><br><span class="line">        FromBigToSmall fromBigToSmall = new FromBigToSmall();</span><br><span class="line">        PowFromSmallToBig powFromSmallToBig = new PowFromSmallToBig();</span><br><span class="line">        PowFromBigToSmall powFromBigToSmall = new PowFromBigToSmall();</span><br><span class="line"></span><br><span class="line">        SortOper sortOper = new SortOper(fromSmallToBig);</span><br><span class="line">        sortOper.sort(arr);</span><br><span class="line">        show(arr);</span><br><span class="line">        sortOper.setCom(fromBigToSmall);</span><br><span class="line">        sortOper.sort(arr);</span><br><span class="line">        show(arr);</span><br><span class="line">        sortOper.setCom(powFromSmallToBig);</span><br><span class="line">        sortOper.sort(arr);</span><br><span class="line">        show(arr);</span><br><span class="line">        sortOper.setCom(powFromBigToSmall);</span><br><span class="line">        sortOper.sort(arr);</span><br><span class="line">        show(arr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><h2 id="一、-概念：-2"><a href="#一、-概念：-2" class="headerlink" title="一、 概念："></a>一、 概念：</h2><p><strong>观察者模式是定义对象间的一种 一对多 的依赖关系。当一个对象的状态发生改变时，所有依赖于他的对象都得到通知，并被自动更新。</strong></p>
<p><strong>一个对象（目标对象）的状态发生改变，所有依赖对象（观察者对象）都得到通知，进行广播通知。</strong></p>
<p>目标对象中包含观察者对象。目标对象中有一个List集合，该集合中包含多个观察者对象。观察者对象中有一个目标对象。</p>
<h2 id="二、-范例：-2"><a href="#二、-范例：-2" class="headerlink" title="二、 范例："></a>二、 范例：</h2><p>气象站：测温度</p>
<p>163、搜狐、百度网站实时显示温度。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Subject&#123;</span><br><span class="line">    //目标对象中有多个观察者对象。</span><br><span class="line">    //目标对象中有观察者对象，才可以给观察者对象发送通知，并更新数据。</span><br><span class="line">    private List&lt;Observer&gt; list = new ArrayList&lt;Observer&gt;();</span><br><span class="line">    private int state;</span><br><span class="line"></span><br><span class="line">    public int getState()&#123;</span><br><span class="line">        return state;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setState(int state)&#123;</span><br><span class="line">        this.state = state;</span><br><span class="line">        notifyAllObservers();</span><br><span class="line">    &#125;</span><br><span class="line">    //将观察者对象添加到数组中。</span><br><span class="line">    public void attach(Observer observer)&#123;</span><br><span class="line">        list.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    //通知所有的观察者对象，更新观察者对象的数据</span><br><span class="line">    public void notifyAllObservers()&#123;</span><br><span class="line">        for (Observer observer: list)&#123;</span><br><span class="line">            observer.update();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">abstract class Observer&#123;</span><br><span class="line">    //观察者对象中包含了目标对象。</span><br><span class="line">    //观察者对象中有了目标对象，才能将自己添加到目标对象的集合中，才能获取目标对象中的状态值。</span><br><span class="line">    protected Subject subject;</span><br><span class="line">    public Observer(Subject subject)&#123;</span><br><span class="line">        this.subject = subject;</span><br><span class="line">    &#125;</span><br><span class="line">    abstract public void update();</span><br><span class="line">&#125;</span><br><span class="line">class Wangyi extends Observer&#123;</span><br><span class="line">    public Wangyi(Subject subject)&#123;</span><br><span class="line">        super(subject);</span><br><span class="line">        //将观察者对象自己添加到目标对象的集合中</span><br><span class="line">        subject.attach(this);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void update() &#123;</span><br><span class="line">        System.out.println(&quot;网易网站显示温度：&quot; + subject.getState());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Souhu extends Observer&#123;</span><br><span class="line">    public Souhu(Subject subject)&#123;</span><br><span class="line">        super(subject);</span><br><span class="line">        //将观察者对象自己添加到目标对象的集合中</span><br><span class="line">        subject.attach(this);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void update() &#123;</span><br><span class="line">        System.out.println(&quot;搜狐网站显示温度：&quot; + subject.getState());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Baidu extends Observer&#123;</span><br><span class="line">    public Baidu(Subject subject)&#123;</span><br><span class="line">        super(subject);</span><br><span class="line">        //将观察者对象自己添加到目标对象的集合中</span><br><span class="line">        subject.attach(this);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void update() &#123;</span><br><span class="line">        System.out.println(&quot;百度网站显示温度：&quot; + subject.getState());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class ObserverPatternDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Subject subject = new Subject();</span><br><span class="line">        Baidu baidu = new Baidu(subject);</span><br><span class="line">        Wangyi wangyi = new Wangyi(subject);</span><br><span class="line">        Souhu souhu = new Souhu(subject);</span><br><span class="line"></span><br><span class="line">        subject.setState(10);</span><br><span class="line">        subject.setState(20);</span><br><span class="line">        subject.setState(30);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h1><h2 id="一、-概念：-3"><a href="#一、-概念：-3" class="headerlink" title="一、 概念："></a>一、 概念：</h2><p>状态模式是行为型模式。</p>
<p><strong>在状态模式中，创建表示各种状态的对象，以及一个行为随着状态对象改变而改变的context对象。</strong></p>
<p>context对象的行为依赖于他的状态(属性)，并且可以根据他的状态改变而改变它的相关行为。</p>
<p><strong>代码中包含大量与对象状态有关的条件语句</strong>。</p>
<h2 id="二、-范例：-3"><a href="#二、-范例：-3" class="headerlink" title="二、 范例："></a>二、 范例：</h2><p>一个对象有四种状态—-创建状态、运行状态、阻塞状态、结束状态，四个状态之间会进行切换，不同的状态完成不同的操作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface State&#123;</span><br><span class="line">    public void dosomthing();</span><br><span class="line">    public void setStateToContext(Context context);</span><br><span class="line">&#125;</span><br><span class="line">class StateDemo01 implements State&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void dosomthing() &#123;</span><br><span class="line">        System.out.println(&quot;状态 demo01 完成的操作============&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void setStateToContext(Context context) &#123;</span><br><span class="line">        context.setState(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class StateDemo02 implements State&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void dosomthing() &#123;</span><br><span class="line">        System.out.println(&quot;状态 demo02 完成的操作============&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void setStateToContext(Context context) &#123;</span><br><span class="line">        context.setState(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class StateDemo03 implements State&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void dosomthing() &#123;</span><br><span class="line">        System.out.println(&quot;状态 demo03 完成的操作============&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void setStateToContext(Context context) &#123;</span><br><span class="line">        context.setState(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class StateDemo04 implements State&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void dosomthing() &#123;</span><br><span class="line">        System.out.println(&quot;状态 demo04 完成的操作============&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void setStateToContext(Context context) &#123;</span><br><span class="line">        context.setState(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Context&#123;</span><br><span class="line">    private State state;</span><br><span class="line">    public void setState(State state)&#123;</span><br><span class="line">        this.state = state;</span><br><span class="line">    &#125;</span><br><span class="line">    public State getState()&#123;</span><br><span class="line">        return state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class StateDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        StateDemo01 stateDemo01 = new StateDemo01();</span><br><span class="line">        StateDemo02 stateDemo02 = new StateDemo02();</span><br><span class="line">        StateDemo03 stateDemo03 = new StateDemo03();</span><br><span class="line">        StateDemo04 stateDemo04 = new StateDemo04();</span><br><span class="line">        Context context = new Context();</span><br><span class="line"></span><br><span class="line">        stateDemo01.setStateToContext(context);</span><br><span class="line">        context.getState().dosomthing();</span><br><span class="line">        stateDemo03.setStateToContext(context);</span><br><span class="line">        context.getState().dosomthing();</span><br><span class="line">        stateDemo02.setStateToContext(context);</span><br><span class="line">        context.getState().dosomthing();</span><br><span class="line">        stateDemo04.setStateToContext(context);</span><br><span class="line">        context.getState().dosomthing();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h1><h2 id="一、概念：-10"><a href="#一、概念：-10" class="headerlink" title="一、概念："></a>一、概念：</h2><p>外观模式是结构型模式。</p>
<p><strong>外观模式隐藏系统的复杂性，向客户端提供一个可以访问系统的接口。</strong></p>
<p>外观模式为子系统中的一组接口提供一个一致的界面，外观模式定义一个高层接口，这个接口使得子系统更加容易使用。</p>
<h2 id="二、范例：-9"><a href="#二、范例：-9" class="headerlink" title="二、范例："></a>二、范例：</h2><p>会计、出纳、业务、保洁分别完成提供财务报表、支出工资、提供业务报表、打扫卫生功能；秘书和以上四个对象沟通。通过秘书实现以上四个对象完成的功能。总经理类是客户端，客户端通过秘书实现以上四个功能。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Kuaiji&#123;</span><br><span class="line">    public void accountTable()&#123;</span><br><span class="line">        System.out.println(&quot;会计提供财务报表&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Chuna&#123;</span><br><span class="line">    public void money()&#123;</span><br><span class="line">        System.out.println(&quot;支出工资&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Yewu&#123;</span><br><span class="line">    public void operate()&#123;</span><br><span class="line">        System.out.println(&quot;业务提供业务报表&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Baojie&#123;</span><br><span class="line">    public void clear()&#123;</span><br><span class="line">        System.out.println(&quot;打扫卫生&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Mishu&#123;</span><br><span class="line">    private Kuaiji kuaiji = new Kuaiji();</span><br><span class="line">    private Yewu yewu = new Yewu();</span><br><span class="line">    private Baojie baojie = new Baojie();</span><br><span class="line">    private Chuna chuna = new Chuna();</span><br><span class="line"></span><br><span class="line">    public void accountTable()&#123;</span><br><span class="line">        kuaiji.accountTable();</span><br><span class="line">    &#125;</span><br><span class="line">    public void operate()&#123;</span><br><span class="line">        yewu.operate();</span><br><span class="line">    &#125;</span><br><span class="line">    public void money()&#123;</span><br><span class="line">        chuna.money();</span><br><span class="line">    &#125;</span><br><span class="line">    public void clear()&#123;</span><br><span class="line">        baojie.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Manager &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Mishu  mishu = new Mishu();</span><br><span class="line">        mishu.accountTable();</span><br><span class="line">        mishu.clear();</span><br><span class="line">        mishu.operate();</span><br><span class="line">        mishu.money();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>练习：电视机遥控器打开电视机，机顶盒遥控器打开机顶盒，音响遥控器打开音响，空调遥控器打开空调。定义总的遥控器，总的遥控器可以打开电视机、打开机顶盒、打开音响、打开空调、打开家庭影院（家庭影院包含电视机、音响、机顶盒）。定义测试类，在测试类中使用总的遥控器打开不同的设备。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>面向对象编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>运维面试题总结</title>
    <url>/p/3d2b1a04/</url>
    <content><![CDATA[<h2 id="1、什么是运维？什么是游戏运维？"><a href="#1、什么是运维？什么是游戏运维？" class="headerlink" title="1、什么是运维？什么是游戏运维？"></a><strong>1、什么是运维？什么是游戏运维？</strong></h2><p>1）运维是指大型组织已经建立好的网络软硬件的维护，就是要保证业务的上线与运作的正常，<br>在他运转的过程中，对他进行维护，他集合了网络、系统、数据库、开发、安全、监控于一身的技术<br>运维又包括很多种，有DBA运维、网站运维、虚拟化运维、监控运维、游戏运维等等</p>
<p>2）游戏运维又有分工，分为开发运维、应用运维（业务运维）和系统运维<br>开发运维：是给应用运维开发运维工具和运维平台的<br>应用运维：是给业务上线、维护和做故障排除的，用开发运维开发出来的工具给业务上线、维护、做故障排查<br>系统运维：是给应用运维提供业务上的基础设施，比如：系统、网络、监控、硬件等等</p>
<p>总结：开发运维和系统运维给应用运维提供了“工具”和“基础设施”上的支撑<br>开发运维、应用运维和系统运维他们的工作是环环相扣的</p>
<span id="more"></span>

<h2 id="2、在工作中，运维人员经常需要跟运营人员打交道，请问运营人员是做什么工作的？"><a href="#2、在工作中，运维人员经常需要跟运营人员打交道，请问运营人员是做什么工作的？" class="headerlink" title="2、在工作中，运维人员经常需要跟运营人员打交道，请问运营人员是做什么工作的？"></a><strong>2、在工作中，运维人员经常需要跟运营人员打交道，请问运营人员是做什么工作的？</strong></h2><p>以游戏运营为例子，游戏运营要做的一个事情除了协调工作以外<br>还需要与各平台沟通，做好开服的时间、开服数、用户导量、活动等计划</p>
<h2 id="3、现在给你三百台服务器，你怎么对他们进行管理？"><a href="#3、现在给你三百台服务器，你怎么对他们进行管理？" class="headerlink" title="3、现在给你三百台服务器，你怎么对他们进行管理？"></a><strong>3、现在给你三百台服务器，你怎么对他们进行管理？</strong></h2><p>管理3百台服务器的方式：<br>1）设定跳板机，使用统一账号登录，便于安全与登录的考量。<br>2）使用salt、ansible、puppet进行系统的统一调度与配置的统一管理。<br>3）建立简单的服务器的系统、配置、应用的cmdb信息管理。便于查阅每台服务器上的各种信息记录。</p>
<h2 id="4、简述RAID协议有哪些，并说明其优缺点"><a href="#4、简述RAID协议有哪些，并说明其优缺点" class="headerlink" title="4、简述RAID协议有哪些，并说明其优缺点"></a>4、简述RAID协议有哪些，并说明其优缺点</h2><p>RAID（Redundant Array of Independent Disks）是一组数据存储方案，旨在提高数据存储系统的性能、可靠性和容错性。不同的RAID级别采用不同的数据分布和冗余策略，以满足不同的需求。以下是一些常见的RAID级别以及它们的优缺点：</p>
<ol>
<li><p><strong>RAID 0：</strong></p>
<ul>
<li><strong>数据分布：</strong> 数据被均匀分布到多个磁盘上，不包含冗余数据。</li>
<li><strong>优点：</strong><ul>
<li>提高性能：RAID 0可以将读写操作并行化，提高性能。</li>
<li>最大化存储：没有冗余数据，可以充分利用所有磁盘的存储空间。</li>
</ul>
</li>
<li><strong>缺点：</strong><ul>
<li>容错性差：没有冗余数据，单个磁盘故障会导致数据丢失。</li>
<li>不适合重要数据：不建议将关键数据存储在RAID 0 中。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>RAID 1：</strong></p>
<ul>
<li><strong>数据分布：</strong> 数据被镜像在两个或更多磁盘上，包含冗余数据。</li>
<li><strong>优点：</strong><ul>
<li>高容错性：单个磁盘故障不会导致数据丢失，因为数据被镜像。</li>
<li>快速读取：可以从多个磁盘中并行读取数据，提高读取性能。</li>
</ul>
</li>
<li><strong>缺点：</strong><ul>
<li>存储效率低：需要至少两倍的磁盘空间来存储相同的数据。</li>
<li>写入性能较低：写入操作需要在所有镜像磁盘上进行，因此写入性能可能不如其他RAID级别。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>RAID 5：</strong></p>
<ul>
<li><strong>数据分布：</strong> 数据和奇偶校验信息被分布在多个磁盘上，提供冗余数据。</li>
<li><strong>优点：</strong><ul>
<li>中等容错性：可以容忍一个磁盘故障，因为数据可以通过奇偶校验信息重建。</li>
<li>合理存储效率：相对于RAID 1，RAID 5提供更高的存储效率。</li>
</ul>
</li>
<li><strong>缺点：</strong><ul>
<li>写入性能较低：写入操作需要计算奇偶校验信息，可能导致写入性能较差。</li>
<li>重建时间较长：当磁盘故障时，需要较长时间来重建数据。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>RAID 6：</strong></p>
<ul>
<li><strong>数据分布：</strong> 类似于RAID 5，但提供了更多的冗余，可以容忍两个磁盘故障。</li>
<li><strong>优点：</strong><ul>
<li>高容错性：可以容忍多个磁盘故障，提供更高的数据可靠性。</li>
<li>合理的存储效率：相对于RAID 1，RAID 6提供了更高的存储效率。</li>
</ul>
</li>
<li><strong>缺点：</strong><ul>
<li>写入性能较低：写入操作需要计算奇偶校验信息，可能导致写入性能较差。</li>
<li>重建时间较长：当多个磁盘故障时，需要更长时间来重建数据。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>RAID 10（RAID 1+0）：</strong></p>
<ul>
<li><strong>数据分布：</strong> 数据首先被镜像，然后镜像数据被分布在多个磁盘上，提供高容错性和性能。</li>
<li><strong>优点：</strong><ul>
<li>高性能：RAID 10提供了高读写性能，因为数据可以并行读取和写入。</li>
<li>高容错性：可以容忍多个磁盘故障。</li>
</ul>
</li>
<li><strong>缺点：</strong><ul>
<li>存储效率低：需要至少四倍的磁盘空间来存储相同的数据。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>选择适当的RAID级别取决于应用需求、性能要求和预算等因素。不同的RAID级别适用于不同的使用场景。要根据具体需求和数据的重要性来选择合适的RAID配置。</p>
<h2 id="5、LVS、Nginx、HAproxy有什么区别？工作中你怎么选择？"><a href="#5、LVS、Nginx、HAproxy有什么区别？工作中你怎么选择？" class="headerlink" title="5、LVS、Nginx、HAproxy有什么区别？工作中你怎么选择？"></a><strong>5、LVS、Nginx、HAproxy有什么区别？工作中你怎么选择？</strong></h2><p>LVS：是基于四层的转发<br>HAproxy：是基于四层和七层的转发，是专业的代理服务器<br>Nginx：是WEB服务器，缓存服务器，又是反向代理服务器，可以做七层的转发</p>
<p>区别：LVS由于是基于四层的转发所以只能做端口的转发、而基于URL的、基于目录的这种转发LVS就做不了</p>
<p>工作选择：HAproxy和Nginx由于可以做七层的转发，所以URL和目录的转发都可以做，在很大并发量的时候我们就要选择LVS，像中小型公司的话并发量没那么大，选择HAproxy或者Nginx足已，由于HAproxy由是专业的代理服务器，配置简单，所以中小型企业推荐使用HAproxy</p>
<h2 id="6、Squid、Varinsh和Nginx有什么区别，工作中你怎么选择？"><a href="#6、Squid、Varinsh和Nginx有什么区别，工作中你怎么选择？" class="headerlink" title="6、Squid、Varinsh和Nginx有什么区别，工作中你怎么选择？"></a><strong>6、Squid、Varinsh和Nginx有什么区别，工作中你怎么选择？</strong></h2><p>Squid、Varinsh和Nginx都是代理服务器</p>
<p><strong>什么是代理服务器：</strong></p>
<p>能代替用户去访问公网，并且能把访问到的数据缓存到服务器本地，等用户下次再访问相同的资源的时候，代理服务器直接从本地回应给用户，当本地没有的时候，我代替你去访问公网，我接收你的请求，我先在我自已的本地缓存找，如果我本地缓存有，我直接从我本地的缓存里回复你如果我在我本地没有找到你要访问的缓存的数据，那么代理服务器就会代替你去访问公网</p>
<p><strong>区别：</strong></p>
<p>1）Nginx本来是反向代理&#x2F;web服务器，用了插件可以做做这个副业<br>但是本身不支持特性挺多，只能缓存静态文件</p>
<p>2）从这些功能上。varnish和squid是专业的cache服务，而nginx这些是第三方模块完成</p>
<p>3）varnish本身的技术上优势要高于squid，它采用了可视化页面缓存技术<br>在内存的利用上，Varnish比Squid具有优势，性能要比Squid高。<br>还有强大的通过Varnish管理端口，可以使用正则表达式快速、批量地清除部分缓存<br>它是内存缓存，速度一流，但是内存缓存也限制了其容量，缓存页面和图片一般是挺好的</p>
<p>4）squid的优势在于完整的庞大的cache技术资料，和很多的应用生产环境</p>
<p><strong>工作中选择：</strong></p>
<p>要做cache服务的话，我们肯定是要选择专业的cache服务，优先选择squid或者varnish。</p>
<h2 id="7、Tomcat和Resin有什么区别，工作中你怎么选择？"><a href="#7、Tomcat和Resin有什么区别，工作中你怎么选择？" class="headerlink" title="7、Tomcat和Resin有什么区别，工作中你怎么选择？"></a><strong>7、Tomcat和Resin有什么区别，工作中你怎么选择？</strong></h2><p>区别：Tomcat用户数多，可参考文档多，Resin用户数少，可考虑文档少，最主要区别则是Tomcat是标准的java容器，不过性能方面比resin的要差一些，但稳定性和java程序的兼容性，应该是比resin的要好</p>
<p>工作中选择：现在大公司都是用resin，追求性能；而中小型公司都是用Tomcat，追求稳定和程序的兼容</p>
<h2 id="8、什么是中间件？什么是jdk？"><a href="#8、什么是中间件？什么是jdk？" class="headerlink" title="8、什么是中间件？什么是jdk？"></a><strong>8、什么是中间件？什么是jdk？</strong></h2><p>中间件是一种独立的系统软件或服务程序，分布式应用软件借助这种软件在不同的技术之间共享资源</p>
<p>中间件位于客户机&#x2F; 服务器的操作系统之上，管理计算机资源和网络通讯是连接两个独立应用程序或独立系统的软件。相连接的系统，即使它们具有不同的接口</p>
<p>但通过中间件相互之间仍能交换信息。执行中间件的一个关键途径是信息传递通过中间件，应用程序可以工作于多平台或OS环境。</p>
<p>jdk：jdk是Java的开发工具包，它是一种用于构建在 Java 平台上发布的应用程序、applet 和组件的开发环境</p>
<h2 id="9、讲述一下Tomcat8005、8009、8080三个端口的含义？"><a href="#9、讲述一下Tomcat8005、8009、8080三个端口的含义？" class="headerlink" title="9、讲述一下Tomcat8005、8009、8080三个端口的含义？"></a><strong>9、讲述一下Tomcat8005、8009、8080三个端口的含义？</strong></h2><p>8005&#x3D;&#x3D;》 关闭时使用<br>8009&#x3D;&#x3D;》 为AJP端口，即容器使用，如Apache能通过AJP协议访问Tomcat的8009端口<br>8080&#x3D;&#x3D;》 一般应用使用</p>
<h2 id="10、什么叫CDN？"><a href="#10、什么叫CDN？" class="headerlink" title="10、什么叫CDN？"></a><strong>10、什么叫CDN？</strong></h2><p>即内容分发网络，其目的是通过在现有的Internet中增加一层新的网络架构，将网站的内容发布到最接近用户的网络边缘，使用户可就近取得所需的内容，提高用户访问网站的速度。</p>
<h2 id="11、什么叫网站灰度发布？"><a href="#11、什么叫网站灰度发布？" class="headerlink" title="11、什么叫网站灰度发布？"></a><strong>11、什么叫网站灰度发布？</strong></h2><p>灰度发布是指在黑与白之间，能够平滑过渡的一种发布方式<br>AB test就是一种灰度发布方式，让一部用户继续用A，一部分用户开始用B<br>如果用户对B没有什么反对意见，那么逐步扩大范围，把所有用户都迁移到B上面 来<br>灰度发布可以保证整体系统的稳定，在初始灰度的时候就可以发现、调整问题，以保证其影响度</p>
<h2 id="12、简述DNS进行域名解析的过程？"><a href="#12、简述DNS进行域名解析的过程？" class="headerlink" title="12、简述DNS进行域名解析的过程？"></a><strong>12、简述DNS进行域名解析的过程？</strong></h2><p>用户要访问<a href="https://link.zhihu.com/?target=http://www.baidu.com">http://www.baidu.com</a>，会先找本机的host文件，再找本地设置的DNS服务器，如果也没有的话，就去网络中找根服务器，根服务器反馈结果，说只能提供一级域名服务器.cn，就去找一级域名服务器，一级域名服务器说只能提供二级域名服务器.com.cn,就去找二级域名服务器，二级域服务器只能提供三级域名服务器.<a href="https://link.zhihu.com/?target=http://baidu.com.cn">http://baidu.com.cn</a>，就去找三级域名服务器，三级域名服务器正好有这个网站<a href="https://link.zhihu.com/?target=http://www.baidu.com">http://www.baidu.com</a>，然后发给请求的服务器，保存一份之后，再发给客户端</p>
<h2 id="13、RabbitMQ是什么东西？"><a href="#13、RabbitMQ是什么东西？" class="headerlink" title="13、RabbitMQ是什么东西？"></a><strong>13、RabbitMQ是什么东西？</strong></h2><p>RabbitMQ也就是消息队列中间件，消息中间件是在消息的传息过程中保存消息的容器<br>消息中间件再将消息从它的源中到它的目标中标时充当中间人的作用<br>队列的主要目的是提供路由并保证消息的传递；如果发送消息时接收者不可用<br>消息队列不会保留消息，直到可以成功地传递为止，当然，消息队列保存消息也是有期限地</p>
<h2 id="14、讲一下Keepalived的工作原理？"><a href="#14、讲一下Keepalived的工作原理？" class="headerlink" title="14、讲一下Keepalived的工作原理？"></a><strong>14、讲一下Keepalived的工作原理？</strong></h2><p>在一个虚拟路由器中，只有作为MASTER的VRRP路由器会一直发送VRRP通告信息,<br>BACKUP不会抢占MASTER，除非它的优先级更高。当MASTER不可用时(BACKUP收不到通告信息)<br>多台BACKUP中优先级最高的这台会被抢占为MASTER。这种抢占是非常快速的(&lt;1s)，以保证服务的连续性<br>由于安全性考虑，VRRP包使用了加密协议进行加密。BACKUP不会发送通告信息，只会接收通告信息</p>
<h2 id="15、讲述一下LVS三种模式的工作过程？"><a href="#15、讲述一下LVS三种模式的工作过程？" class="headerlink" title="15、讲述一下LVS三种模式的工作过程？"></a><strong>15、讲述一下LVS三种模式的工作过程？</strong></h2><p>LVS 有三种负载均衡的模式，分别是VS&#x2F;NAT（nat 模式） VS&#x2F;DR(路由模式) VS&#x2F;TUN（隧道模式）</p>
<p><strong>一、NAT模式（VS-NAT）</strong></p>
<p>原理：就是把客户端发来的数据包的IP头的目的地址，在负载均衡器上换成其中一台RS的IP地址，并发至此RS来处理,RS处理完后把数据交给负载均衡器,负载均衡器再把数据包原IP地址改为自己的IP，将目的地址改为客户端IP地址即可期间,无论是进来的流量,还是出去的流量,都必须经过负载均衡器</p>
<p>优点：集群中的物理服务器可以使用任何支持TCP&#x2F;IP操作系统，只有负载均衡器需要一个合法的IP地址</p>
<p>缺点：扩展性有限。当服务器节点（普通PC服务器）增长过多时,负载均衡器将成为整个系统的瓶颈，因为所有的请求包和应答包的流向都经过负载均衡器。当服务器节点过多时，大量的数据包都交汇在负载均衡器那，速度就会变慢！</p>
<p><strong>二、IP隧道模式（VS-TUN）</strong></p>
<p>原理：首先要知道，互联网上的大多Internet服务的请求包很短小，而应答包通常很大，那么隧道模式就是，把客户端发来的数据包，封装一个新的IP头标记(仅目的IP)发给RS，RS收到后,先把数据包的头解开,还原数据包,处理后,直接返回给客户端,不需要再经过负载均衡器。注意,由于RS需要对负载均衡器发过来的数据包进行还原,所以说必须支持IPTUNNEL协议，所以,在RS的内核中,必须编译支持IPTUNNEL这个选项</p>
<p>优点：负载均衡器只负责将请求包分发给后端节点服务器，而RS将应答包直接发给用户，所以，减少了负载均衡器的大量数据流动，负载均衡器不再是系统的瓶颈，就能处理很巨大的请求量，这种方式，一台负载均衡器能够为很多RS进行分发。而且跑在公网上就能进行不同地域的分发。</p>
<p>缺点：隧道模式的RS节点需要合法IP，这种方式需要所有的服务器支持”IP Tunneling”(IP Encapsulation)协议，服务器可能只局限在部分Linux系统上</p>
<p><strong>三、直接路由模式（VS-DR）</strong></p>
<p>原理：负载均衡器和RS都使用同一个IP对外服务但只有DR对ARP请求进行响应，所有RS对本身这个IP的ARP请求保持静默也就是说,网关会把对这个服务IP的请求全部定向给DR，而DR收到数据包后根据调度算法,找出对应的RS,把目的MAC地址改为RS的MAC（因为IP一致），并将请求分发给这台RS这时RS收到这个数据包,处理完成之后，由于IP一致，可以直接将数据返给客户，则等于直接从客户端收到这个数据包无异,处理后直接返回给客户端，由于负载均衡器要对二层包头进行改换,所以负载均衡器和RS之间必须在一个广播域，也可以简单的理解为在同一台交换机上</p>
<p>优点：和TUN（隧道模式）一样，负载均衡器也只是分发请求，应答包通过单独的路由方法返回给客户端，与VS-TUN相比，VS-DR这种实现方式不需要隧道结构，因此可以使用大多数操作系统做为物理服务器。</p>
<p>缺点：（不能说缺点，只能说是不足）要求负载均衡器的网卡必须与物理网卡在一个物理段上。</p>
<h2 id="16、mysql的innodb如何定位锁问题，mysql如何减少主从复制延迟？"><a href="#16、mysql的innodb如何定位锁问题，mysql如何减少主从复制延迟？" class="headerlink" title="16、mysql的innodb如何定位锁问题，mysql如何减少主从复制延迟？"></a><strong>16、mysql的innodb如何定位锁问题，mysql如何减少主从复制延迟？</strong></h2><p>mysql的innodb如何定位锁问题:</p>
<p>在使用 show engine innodb status检查引擎状态时，发现了死锁问题</p>
<p>在5.5中，information_schema 库中增加了三个关于锁的表（MEMORY引擎）</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">innodb_trx         ## 当前运行的所有事务</span><br><span class="line"></span><br><span class="line">innodb_locks     ## 当前出现的锁</span><br><span class="line"></span><br><span class="line">innodb_lock_waits  ## 锁等待的对应关系</span><br></pre></td></tr></table></figure>

<p>mysql如何减少主从复制延迟:</p>
<p>如果延迟比较大，就先确认以下几个因素：</p>
<p>1.从库硬件比主库差，导致复制延迟</p>
<p>2.主从复制单线程，如果主库写并发太大，来不及传送到从库就会导致延迟。更高版本的mysql可以支持多线程复制</p>
<p>3.慢SQL语句过多</p>
<p>4.网络延迟</p>
<p>5.master负载：主库读写压力大，导致复制延迟，架构的前端要加buffer及缓存层</p>
<p>6.slave负载：一般的做法是，使用多台slave来分摊读请求，再从这些slave中取一台专用的服务器只作为备份用，不进行其他任何操作.另外， 2个可以减少延迟的参数:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">–slave-net-timeout=seconds 单位为秒 默认设置为 3600秒</span><br><span class="line"></span><br><span class="line">#参数含义：当slave从主数据库读取log数据失败后，等待多久重新建立连接并获取数据</span><br><span class="line"></span><br><span class="line">–master-connect-retry=seconds 单位为秒 默认设置为 60秒</span><br><span class="line"></span><br><span class="line">#参数含义：当重新建立主从连接时，如果连接建立失败，间隔多久后重试</span><br></pre></td></tr></table></figure>

<p>通常配置以上2个参数可以减少网络问题导致的主从数据同步延迟</p>
<p>MySQL数据库主从同步延迟解决方案</p>
<p>最简单的减少slave同步延时的方案就是在架构上做优化，尽量让主库的DDL快速执行</p>
<p>还有就是主库是写，对数据安全性较高，比如sync_binlog&#x3D;1，innodb_flush_log_at_trx_commit<br>&#x3D; 1 之类的设置，而slave则不需要这么高的数据安全，完全可以讲sync_binlog设置为0或者关闭binlog</p>
<p>innodb_flushlog也可以设置为0来提高sql的执行效率。另外就是使用比主库更好的硬件设备作为slave</p>
<h2 id="17、如何重置mysql-root密码？"><a href="#17、如何重置mysql-root密码？" class="headerlink" title="17、如何重置mysql root密码？"></a><strong>17、如何重置mysql root密码？</strong></h2><p><strong>一、 在已知MYSQL数据库的ROOT用户密码的情况下，修改密码的方法：</strong></p>
<p>在SHELL环境下，使用mysqladmin命令设置：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">mysqladmin –u root –p password “新密码”   回车后要求输入旧密码</span><br></pre></td></tr></table></figure>

<p>在mysql&gt;环境中,使用update命令，直接更新mysql库user表的数据：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Update  mysql.user  set  password=password(‘新密码’)  where  user=’root’;</span><br><span class="line"></span><br><span class="line">flush   privileges;</span><br></pre></td></tr></table></figure>

<p>注意：mysql语句要以分号”；”结束在mysql&gt;环境中，使用grant命令，修改root用户的授权权限。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">grant  all  on  *.*  to   root@’localhost’  identified  by  ‘新密码’；</span><br></pre></td></tr></table></figure>

<p><strong>二、 如忘记了mysql数据库的ROOT用户的密码，又如何做呢？方法如下：</strong></p>
<p>关闭当前运行的mysqld服务程序：service mysqld stop（要先将mysqld添加为系统服务）</p>
<p>使用mysqld_safe脚本以安全模式（不加载授权表）启动mysqld 服务</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">/usr/local/mysql/bin/mysqld_safe  --skip-grant-table  &amp;</span><br></pre></td></tr></table></figure>

<p>使用空密码的root用户登录数据库，重新设置ROOT用户的密码</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">＃mysql  -u   root</span><br><span class="line"></span><br><span class="line">Mysql&gt; Update  mysql.user  set  password=password(‘新密码’)  where  user=’root’;</span><br><span class="line"></span><br><span class="line">Mysql&gt; flush   privileges;</span><br></pre></td></tr></table></figure>



<h2 id="18、lvs-nginx-haproxy优缺点"><a href="#18、lvs-nginx-haproxy优缺点" class="headerlink" title="18、lvs&#x2F;nginx&#x2F;haproxy优缺点"></a><strong>18、lvs&#x2F;nginx&#x2F;haproxy优缺点</strong></h2><p><strong>Nginx的优点是：</strong></p>
<p>1、工作在网络的7层之上，可以针对http应用做一些分流的策略，比如针对域名、目录结构</p>
<p>它的正则规则比HAProxy更为强大和灵活，这也是它目前广泛流行的主要原因之一</p>
<p>Nginx单凭这点可利用的场合就远多于LVS了。</p>
<p>2、Nginx对网络稳定性的依赖非常小，理论上能ping通就就能进行负载功能，这个也是它的优势之一</p>
<p>相反LVS对网络稳定性依赖比较大，这点本人深有体会；</p>
<p>3、Nginx安装和配置比较简单，测试起来比较方便，它基本能把错误用日志打印出来</p>
<p>LVS的配置、测试就要花比较长的时间了，LVS对网络依赖比较大。</p>
<p>4、可以承担高负载压力且稳定，在硬件不差的情况下一般能支撑几万次的并发量，负载度比LVS相对小些。</p>
<p>5、Nginx可以通过端口检测到服务器内部的故障，比如根据服务器处理网页返回的状态码、超时等等，并且会把返回错误的请求重新提交到另一个节点，不过其中缺点就是不支持url来检测。比如用户正在上传一个文件，而处理该上传的节点刚好在上传过程中出现故障，Nginx会把上传切到另一台服务器重新处理，而LVS就直接断掉了</p>
<p>如果是上传一个很大的文件或者很重要的文件的话，用户可能会因此而不满。</p>
<p>6、Nginx不仅仅是一款优秀的负载均衡器&#x2F;反向代理软件，它同时也是功能强大的Web应用服务器</p>
<p>LNMP也是近几年非常流行的web架构，在高流量的环境中稳定性也很好。</p>
<p>7、Nginx现在作为Web反向加速缓存越来越成熟了，速度比传统的Squid服务器更快，可考虑用其作为反向代理加速器</p>
<p>8、Nginx可作为中层反向代理使用，这一层面Nginx基本上无对手，唯一可以对比Nginx的就只有lighttpd了</p>
<p>不过lighttpd目前还没有做到Nginx完全的功能，配置也不那么清晰易读，社区资料也远远没Nginx活跃</p>
<p>9、Nginx也可作为静态网页和图片服务器，这方面的性能也无对手。还有Nginx社区非常活跃，第三方模块也很多</p>
<p><strong>Nginx的缺点是：</strong></p>
<p>1、Nginx仅能支持http、https和Email协议，这样就在适用范围上面小些，这个是它的缺点</p>
<p>2、对后端服务器的健康检查，只支持通过端口来检测，不支持通过url来检测</p>
<p>不支持Session的直接保持，但能通过ip_hash来解决</p>
<p>LVS：使用Linux内核集群实现一个高性能、高可用的负载均衡服务器</p>
<p>它具有很好的可伸缩性（Scalability)、可靠性（Reliability)和可管理性（Manageability)</p>
<p><strong>LVS的优点是：</strong></p>
<p>1、抗负载能力强、是工作在网络4层之上仅作分发之用，没有流量的产生</p>
<p>这个特点也决定了它在负载均衡软件里的性能最强的，对内存和cpu资源消耗比较低</p>
<p>2、配置性比较低，这是一个缺点也是一个优点，因为没有可太多配置的东西</p>
<p>所以并不需要太多接触，大大减少了人为出错的几率</p>
<p>3、工作稳定，因为其本身抗负载能力很强，自身有完整的双机热备方案</p>
<p>如LVS+Keepalived，不过我们在项目实施中用得最多的还是LVS&#x2F;DR+Keepalived</p>
<p>4、无流量，LVS只分发请求，而流量并不从它本身出去，这点保证了均衡器IO的性能不会收到大流量的影响。</p>
<p>5、应用范围较广，因为LVS工作在4层，所以它几乎可对所有应用做负载均衡，包括http、数据库、在线聊天室等</p>
<p><strong>LVS的缺点是：</strong></p>
<p>1、软件本身不支持正则表达式处理，不能做动静分离</p>
<p>而现在许多网站在这方面都有较强的需求，这个是Nginx&#x2F;HAProxy+Keepalived的优势所在</p>
<p>2、如果是网站应用比较庞大的话，LVS&#x2F;DR+Keepalived实施起来就比较复杂了</p>
<p>特别后面有Windows Server的机器的话，如果实施及配置还有维护过程就比较复杂了</p>
<p>相对而言，Nginx&#x2F;HAProxy+Keepalived就简单多了。</p>
<p><strong>HAProxy的特点是：</strong></p>
<p>1、HAProxy也是支持虚拟主机的。</p>
<p>2、HAProxy的优点能够补充Nginx的一些缺点，比如支持Session的保持，Cookie的引导</p>
<p>同时支持通过获取指定的url来检测后端服务器的状态</p>
<p>3、HAProxy跟LVS类似，本身就只是一款负载均衡软件</p>
<p>单纯从效率上来讲HAProxy会比Nginx有更出色的负载均衡速度，在并发处理上也是优于Nginx的</p>
<p>4、HAProxy支持TCP协议的负载均衡转发，可以对MySQL读进行负载均衡</p>
<p>对后端的MySQL节点进行检测和负载均衡，大家可以用LVS+Keepalived对MySQL主从做负载均衡</p>
<p>5、HAProxy负载均衡策略非常多，HAProxy的负载均衡算法现在具体有如下8种：</p>
<ul>
<li>roundrobin，表示简单的轮询，这个不多说，这个是负载均衡基本都具备的；</li>
<li>static-rr，表示根据权重，建议关注；</li>
<li>leastconn，表示最少连接者先处理，建议关注；</li>
<li>source，表示根据请求源IP，这个跟Nginx的IP_hash机制类似,我们用其作为解决session问题的一种方法，建议关注；</li>
<li>ri，表示根据请求的URI；</li>
<li>rl_param，表示根据请求的URl参数’balance url_param’ requires an URL parameter name；</li>
<li>hdr(name)，表示根据HTTP请求头来锁定每一次HTTP请求；</li>
<li>rdp-cookie(name)，表示根据据cookie(name)来锁定并哈希每一次TCP请求。</li>
</ul>
<h2 id="19、mysql数据备份工具"><a href="#19、mysql数据备份工具" class="headerlink" title="19、mysql数据备份工具"></a><strong>19、mysql数据备份工具</strong></h2><p><strong>mysqldump工具</strong></p>
<p>mysqldump是mysql自带的备份工具，目录在bin目录下面：&#x2F;usr&#x2F;local&#x2F;mysql&#x2F;bin&#x2F;mysqldump。支持基于innodb的热备份，但是由于是逻辑备份，所以速度不是很快，适合备份数据比较小的场景，Mysqldump完全备份+二进制日志可以实现基于时间点的恢复。</p>
<p><strong>基于LVM快照备份</strong></p>
<p>在物理备份中，有基于文件系统的物理备份（LVM的快照），也可以直接用tar之类的命令对整个数据库目录，进行打包备份，但是这些只能进行冷备份，不同的存储引擎备份的也不一样，myisam自动备份到表级别，而innodb不开启独立表空间的话只能备份整个数据库。</p>
<p><strong>tar包备份</strong></p>
<p>percona提供的xtrabackup工具，支持innodb的物理热备份，支持完全备份，增量备份，而且速度非常快，支持innodb存储引起的数据在不同，数据库之间迁移，支持复制模式下的从机备份恢复备份恢复，为了让xtrabackup支持更多的功能扩展，可以设立独立表空间，打开 innodb_file_per_table功能，启用之后可以支持单独的表备份</p>
<h2 id="20、keepalive的工作原理和如何做到健康检查"><a href="#20、keepalive的工作原理和如何做到健康检查" class="headerlink" title="20、keepalive的工作原理和如何做到健康检查"></a><strong>20、keepalive的工作原理和如何做到健康检查</strong></h2><p>keepalived是以VRRP协议为实现基础的，VRRP全称Virtual Router Redundancy Protocol，即虚拟路由冗余协议。虚拟路由冗余协议，可以认为是实现路由器高可用的协议，即将N台提供相同功能的路由器组成一个路由器组，这个组里面有一个master和多个backup，master上面有一个对外提供服务的vip（该路由器所在局域网内，其他机器的默认路由为该vip），master会发组播，当backup收不到vrrp包时就认为master宕掉了，这时就需要根据VRRP的优先级来选举一个backup当master。这样就可以保证路由器的高可用了</p>
<p>keepalived主要有三个模块，分别是core、check和vrrp。core模块为keepalived的核心，负责主进程的启动、维护及全局配置文件的加载和解析。check负责健康检查，包括常见的各种检查方式，vrrp模块是来实现VRRP协议的</p>
<p><strong>Keepalived健康检查方式配置</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">HTTP_GET|SSL_GET</span><br><span class="line">HTTP_GET | SSL_GET</span><br><span class="line">&#123;</span><br><span class="line">url &#123;</span><br><span class="line">path /# HTTP/SSL 检查的url可以是多个</span><br><span class="line">digest &lt;STRING&gt; # HTTP/SSL 检查后的摘要信息用工具genhash生成</span><br><span class="line">status_code 200# HTTP/SSL 检查返回的状态码</span><br><span class="line">&#125;</span><br><span class="line">connect_port 80 # 连接端口</span><br><span class="line">bindto&lt;IPADD&gt;</span><br><span class="line">connect_timeout 3 # 连接超时时间</span><br><span class="line">nb_get_retry 3 # 重连次数</span><br><span class="line">delay_before_retry 2 #连接间隔时间</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="21、统计ip访问情况，要求分析nginx访问日志，找出访问页面数量在前十位的ip"><a href="#21、统计ip访问情况，要求分析nginx访问日志，找出访问页面数量在前十位的ip" class="headerlink" title="21、统计ip访问情况，要求分析nginx访问日志，找出访问页面数量在前十位的ip"></a><strong>21、统计ip访问情况，要求分析nginx访问日志，找出访问页面数量在前十位的ip</strong></h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat access.log | awk &#x27;&#123;print $1&#125;&#x27; | uniq -c | sort -rn | head -10</span><br></pre></td></tr></table></figure>



<h2 id="22、使用tcpdump监听主机为192-168-1-1，tcp端口为80的数据，同时将输出结果保存输出到tcpdump-log"><a href="#22、使用tcpdump监听主机为192-168-1-1，tcp端口为80的数据，同时将输出结果保存输出到tcpdump-log" class="headerlink" title="22、使用tcpdump监听主机为192.168.1.1，tcp端口为80的数据，同时将输出结果保存输出到tcpdump.log"></a><strong>22、使用tcpdump监听主机为192.168.1.1，tcp端口为80的数据，同时将输出结果保存输出到tcpdump.log</strong></h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tcpdump &#x27;host 192.168.1.1 and port 80&#x27; &gt; tcpdump.log</span><br></pre></td></tr></table></figure>



<h2 id="23、如何将本地80-端口的请求转发到8080-端口，当前主机IP-为192-168-2-1"><a href="#23、如何将本地80-端口的请求转发到8080-端口，当前主机IP-为192-168-2-1" class="headerlink" title="23、如何将本地80 端口的请求转发到8080 端口，当前主机IP 为192.168.2.1"></a><strong>23、如何将本地80 端口的请求转发到8080 端口，当前主机IP 为192.168.2.1</strong></h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -A PREROUTING -d 192.168.2.1 -p tcp -m tcp -dport 80 -j DNAT-to-destination 192.168.2.1:8080</span><br></pre></td></tr></table></figure>



<h2 id="24、简述raid0-raid1-raid5-三种工作模式的工作原理及特点"><a href="#24、简述raid0-raid1-raid5-三种工作模式的工作原理及特点" class="headerlink" title="24、简述raid0 raid1 raid5 三种工作模式的工作原理及特点"></a><strong>24、简述raid0 raid1 raid5 三种工作模式的工作原理及特点</strong></h2><p>RAID 0：带区卷，连续以位或字节为单位分割数据，并行读&#x2F;写于多个磁盘上，因此具有很高的数据传输率，但它没有数据冗余，RAID 0 只是单纯地提高性能，并没有为数据的可靠性提供保证，而且其中的一个磁盘失效将影响到所有数据。因此，RAID 0 不能应用于数据安全性要求高的场合</p>
<p>RAID 1：镜像卷，它是通过磁盘数据镜像实现数据冗余，在成对的独立磁盘上产生互为备份的数据，不能提升写数据效率。当原始数据繁忙时，可直接从镜像拷贝中读取数据，因此RAID1 可以提高读取性能，RAID 1 是磁盘阵列中单位成本最高的，镜像卷可用容量为总容量的1&#x2F;2，但提供了很高的数据安全性和可用性，当一个磁盘失效时，系统可以自动切换到镜像磁盘上读写，而不需要重组失效的数据</p>
<p>RAID5：至少由3块硬盘组成，分布式奇偶校验的独立磁盘结构，它的奇偶校验码存在于所有磁盘上，任何一个硬盘损坏，都可以根据其它硬盘上的校验位来重建损坏的数据（最多允许1块硬盘损坏），所以raid5可以实现数据冗余，确保数据的安全性，同时raid5也可以提升数据的读写性能</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>运维</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>运维</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
</search>
